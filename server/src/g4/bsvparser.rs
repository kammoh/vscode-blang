// Generated from BSV.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
use antlr_rust::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::bsvlistener::*;
use antlr_rust::lazy_static;
use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const T__0:isize=1; 
		pub const T__1:isize=2; 
		pub const T__2:isize=3; 
		pub const T__3:isize=4; 
		pub const T__4:isize=5; 
		pub const T__5:isize=6; 
		pub const T__6:isize=7; 
		pub const T__7:isize=8; 
		pub const T__8:isize=9; 
		pub const T__9:isize=10; 
		pub const T__10:isize=11; 
		pub const T__11:isize=12; 
		pub const T__12:isize=13; 
		pub const T__13:isize=14; 
		pub const T__14:isize=15; 
		pub const T__15:isize=16; 
		pub const T__16:isize=17; 
		pub const T__17:isize=18; 
		pub const T__18:isize=19; 
		pub const T__19:isize=20; 
		pub const T__20:isize=21; 
		pub const T__21:isize=22; 
		pub const T__22:isize=23; 
		pub const T__23:isize=24; 
		pub const T__24:isize=25; 
		pub const T__25:isize=26; 
		pub const T__26:isize=27; 
		pub const T__27:isize=28; 
		pub const T__28:isize=29; 
		pub const T__29:isize=30; 
		pub const T__30:isize=31; 
		pub const T__31:isize=32; 
		pub const T__32:isize=33; 
		pub const T__33:isize=34; 
		pub const T__34:isize=35; 
		pub const T__35:isize=36; 
		pub const T__36:isize=37; 
		pub const T__37:isize=38; 
		pub const T__38:isize=39; 
		pub const T__39:isize=40; 
		pub const T__40:isize=41; 
		pub const T__41:isize=42; 
		pub const T__42:isize=43; 
		pub const T__43:isize=44; 
		pub const T__44:isize=45; 
		pub const T__45:isize=46; 
		pub const T__46:isize=47; 
		pub const T__47:isize=48; 
		pub const T__48:isize=49; 
		pub const T__49:isize=50; 
		pub const T__50:isize=51; 
		pub const T__51:isize=52; 
		pub const T__52:isize=53; 
		pub const T__53:isize=54; 
		pub const T__54:isize=55; 
		pub const T__55:isize=56; 
		pub const T__56:isize=57; 
		pub const T__57:isize=58; 
		pub const T__58:isize=59; 
		pub const T__59:isize=60; 
		pub const T__60:isize=61; 
		pub const T__61:isize=62; 
		pub const T__62:isize=63; 
		pub const T__63:isize=64; 
		pub const T__64:isize=65; 
		pub const T__65:isize=66; 
		pub const T__66:isize=67; 
		pub const T__67:isize=68; 
		pub const T__68:isize=69; 
		pub const T__69:isize=70; 
		pub const T__70:isize=71; 
		pub const T__71:isize=72; 
		pub const T__72:isize=73; 
		pub const T__73:isize=74; 
		pub const T__74:isize=75; 
		pub const T__75:isize=76; 
		pub const T__76:isize=77; 
		pub const T__77:isize=78; 
		pub const T__78:isize=79; 
		pub const T__79:isize=80; 
		pub const T__80:isize=81; 
		pub const T__81:isize=82; 
		pub const T__82:isize=83; 
		pub const T__83:isize=84; 
		pub const T__84:isize=85; 
		pub const T__85:isize=86; 
		pub const T__86:isize=87; 
		pub const T__87:isize=88; 
		pub const T__88:isize=89; 
		pub const T__89:isize=90; 
		pub const T__90:isize=91; 
		pub const T__91:isize=92; 
		pub const T__92:isize=93; 
		pub const T__93:isize=94; 
		pub const T__94:isize=95; 
		pub const T__95:isize=96; 
		pub const T__96:isize=97; 
		pub const T__97:isize=98; 
		pub const T__98:isize=99; 
		pub const T__99:isize=100; 
		pub const T__100:isize=101; 
		pub const T__101:isize=102; 
		pub const T__102:isize=103; 
		pub const T__103:isize=104; 
		pub const T__104:isize=105; 
		pub const T__105:isize=106; 
		pub const T__106:isize=107; 
		pub const T__107:isize=108; 
		pub const T__108:isize=109; 
		pub const T__109:isize=110; 
		pub const T__110:isize=111; 
		pub const T__111:isize=112; 
		pub const T__112:isize=113; 
		pub const T__113:isize=114; 
		pub const T__114:isize=115; 
		pub const T__115:isize=116; 
		pub const T__116:isize=117; 
		pub const T__117:isize=118; 
		pub const T__118:isize=119; 
		pub const T__119:isize=120; 
		pub const T__120:isize=121; 
		pub const T__121:isize=122; 
		pub const T__122:isize=123; 
		pub const T__123:isize=124; 
		pub const T__124:isize=125; 
		pub const T__125:isize=126; 
		pub const T__126:isize=127; 
		pub const T__127:isize=128; 
		pub const T__128:isize=129; 
		pub const T__129:isize=130; 
		pub const T__130:isize=131; 
		pub const T__131:isize=132; 
		pub const T__132:isize=133; 
		pub const T__133:isize=134; 
		pub const T__134:isize=135; 
		pub const T__135:isize=136; 
		pub const T__136:isize=137; 
		pub const T__137:isize=138; 
		pub const T__138:isize=139; 
		pub const T__139:isize=140; 
		pub const LINE_COMMENT:isize=141; 
		pub const BLOCK_COMMENT:isize=142; 
		pub const WHITESPACE:isize=143; 
		pub const NEWLINE:isize=144; 
		pub const UPPER_IDENTIFIER:isize=145; 
		pub const LOWER_IDENTIFIER:isize=146; 
		pub const OPERATOR_IDENTIFIER:isize=147; 
		pub const SYSTEM_TASK:isize=148; 
		pub const STRING_LITERAL:isize=149; 
		pub const INT_LITERAL:isize=150; 
		pub const DECIMAL:isize=151; 
		pub const REAL_LITERAL:isize=152; 
		pub const COMPILER_DIRECTIVE:isize=153; 
		pub const MACRO_INVOCATION:isize=154;
	pub const RULE_identifier:usize = 0; 
	pub const RULE_any_identifier:usize = 1; 
	pub const RULE_top:usize = 2; 
	pub const RULE_r_package:usize = 3; 
	pub const RULE_non_package:usize = 4; 
	pub const RULE_exportDecl:usize = 5; 
	pub const RULE_exportItem:usize = 6; 
	pub const RULE_importDecl:usize = 7; 
	pub const RULE_importItem:usize = 8; 
	pub const RULE_packageStmt:usize = 9; 
	pub const RULE_package_identifier:usize = 10; 
	pub const RULE_data_type:usize = 11; 
	pub const RULE_numeric_type:usize = 12; 
	pub const RULE_primary_type:usize = 13; 
	pub const RULE_type_identifier:usize = 14; 
	pub const RULE_interfaceDecl:usize = 15; 
	pub const RULE_typeDefType:usize = 16; 
	pub const RULE_typeFormals:usize = 17; 
	pub const RULE_typeFormal:usize = 18; 
	pub const RULE_interfaceMemberDecl:usize = 19; 
	pub const RULE_methodProto:usize = 20; 
	pub const RULE_methodProtoFormals:usize = 21; 
	pub const RULE_methodProtoFormal:usize = 22; 
	pub const RULE_subinterfaceDecl:usize = 23; 
	pub const RULE_module_def:usize = 24; 
	pub const RULE_module_proto:usize = 25; 
	pub const RULE_moduleprotoformals:usize = 26; 
	pub const RULE_moduleprotoformal:usize = 27; 
	pub const RULE_moduleFormalArgs:usize = 28; 
	pub const RULE_moduleStmt:usize = 29; 
	pub const RULE_method_type:usize = 30; 
	pub const RULE_method_def:usize = 31; 
	pub const RULE_implicitCond:usize = 32; 
	pub const RULE_methodFormals:usize = 33; 
	pub const RULE_methodFormal:usize = 34; 
	pub const RULE_subinterfaceDef:usize = 35; 
	pub const RULE_interfaceStmt:usize = 36; 
	pub const RULE_expressionStmt:usize = 37; 
	pub const RULE_ruleDef:usize = 38; 
	pub const RULE_ruleCond:usize = 39; 
	pub const RULE_ruleBody:usize = 40; 
	pub const RULE_typeDef:usize = 41; 
	pub const RULE_typedefSynonym:usize = 42; 
	pub const RULE_typedefEnum:usize = 43; 
	pub const RULE_typedefEnumElements:usize = 44; 
	pub const RULE_typedefEnumElement:usize = 45; 
	pub const RULE_typedefStruct:usize = 46; 
	pub const RULE_typedefTaggedUnion:usize = 47; 
	pub const RULE_structMember:usize = 48; 
	pub const RULE_unionMember:usize = 49; 
	pub const RULE_subStruct:usize = 50; 
	pub const RULE_subUnion:usize = 51; 
	pub const RULE_variable_declaration:usize = 52; 
	pub const RULE_patternbinding:usize = 53; 
	pub const RULE_variable_initialization:usize = 54; 
	pub const RULE_variable_assignment:usize = 55; 
	pub const RULE_lvalue:usize = 56; 
	pub const RULE_regWrite:usize = 57; 
	pub const RULE_beginEndStmt_functionBodyStmt:usize = 58; 
	pub const RULE_beginEndStmt_actionStmt:usize = 59; 
	pub const RULE_beginEndStmt_actionValueStmt:usize = 60; 
	pub const RULE_beginEndStmt_moduleStmt:usize = 61; 
	pub const RULE_beginEndStmt_expressionStmt:usize = 62; 
	pub const RULE_if_functionBodyStmt:usize = 63; 
	pub const RULE_if_actionStmt:usize = 64; 
	pub const RULE_if_actionValueStmt:usize = 65; 
	pub const RULE_if_moduleStmt:usize = 66; 
	pub const RULE_if_expressionStmt:usize = 67; 
	pub const RULE_case_actionStmt:usize = 68; 
	pub const RULE_case_actionValueStmt:usize = 69; 
	pub const RULE_case_moduleStmt:usize = 70; 
	pub const RULE_case_expressionStmt:usize = 71; 
	pub const RULE_caseItem_functionBodyStmt:usize = 72; 
	pub const RULE_caseItem_actionStmt:usize = 73; 
	pub const RULE_caseItem_actionValueStmt:usize = 74; 
	pub const RULE_caseItem_moduleStmt:usize = 75; 
	pub const RULE_caseItem_expressionStmt:usize = 76; 
	pub const RULE_defaultItem_functionBodyStmt:usize = 77; 
	pub const RULE_defaultItem_actionStmt:usize = 78; 
	pub const RULE_defaultItem_actionValueStmt:usize = 79; 
	pub const RULE_defaultItem_moduleStmt:usize = 80; 
	pub const RULE_defaultItem_expressionStmt:usize = 81; 
	pub const RULE_while_functionBodyStmt:usize = 82; 
	pub const RULE_while_actionStmt:usize = 83; 
	pub const RULE_while_actionValueStmt:usize = 84; 
	pub const RULE_while_moduleStmt:usize = 85; 
	pub const RULE_while_expressionStmt:usize = 86; 
	pub const RULE_for_functionBodyStmt:usize = 87; 
	pub const RULE_for_actionStmt:usize = 88; 
	pub const RULE_for_actionValueStmt:usize = 89; 
	pub const RULE_for_moduleStmt:usize = 90; 
	pub const RULE_for_expressionStmt:usize = 91; 
	pub const RULE_simpleVarDeclAssign:usize = 92; 
	pub const RULE_forInit:usize = 93; 
	pub const RULE_forTest:usize = 94; 
	pub const RULE_forIncr:usize = 95; 
	pub const RULE_varIncr:usize = 96; 
	pub const RULE_function_def:usize = 97; 
	pub const RULE_function_proto:usize = 98; 
	pub const RULE_function_formals:usize = 99; 
	pub const RULE_functionFormal:usize = 100; 
	pub const RULE_functionBody:usize = 101; 
	pub const RULE_functionBodyStmt:usize = 102; 
	pub const RULE_returnStmt:usize = 103; 
	pub const RULE_expression:usize = 104; 
	pub const RULE_caseexprpatitem:usize = 105; 
	pub const RULE_caseexpritem:usize = 106; 
	pub const RULE_caseexprdefaultitem:usize = 107; 
	pub const RULE_patterncond:usize = 108; 
	pub const RULE_unary_operator:usize = 109; 
	pub const RULE_binary_operator:usize = 110; 
	pub const RULE_binopexpr:usize = 111; 
	pub const RULE_unopexpr:usize = 112; 
	pub const RULE_constant_expression:usize = 113; 
	pub const RULE_constant_primary:usize = 114; 
	pub const RULE_bit_concatination:usize = 115; 
	pub const RULE_primary_expression:usize = 116; 
	pub const RULE_memberbinds:usize = 117; 
	pub const RULE_memberbind:usize = 118; 
	pub const RULE_interfacestmt:usize = 119; 
	pub const RULE_cond_predicate:usize = 120; 
	pub const RULE_exprOrCondPattern:usize = 121; 
	pub const RULE_block_expression:usize = 122; 
	pub const RULE_actionBlock:usize = 123; 
	pub const RULE_actionStmt:usize = 124; 
	pub const RULE_actionValueBlock:usize = 125; 
	pub const RULE_actionValueStmt:usize = 126; 
	pub const RULE_varDeclDo:usize = 127; 
	pub const RULE_varDo:usize = 128; 
	pub const RULE_typeAssertion:usize = 129; 
	pub const RULE_structExpr:usize = 130; 
	pub const RULE_memberBind:usize = 131; 
	pub const RULE_taggedUnionExpr:usize = 132; 
	pub const RULE_interfaceExpr:usize = 133; 
	pub const RULE_rulesExpr:usize = 134; 
	pub const RULE_rulesStmt:usize = 135; 
	pub const RULE_pattern:usize = 136; 
	pub const RULE_constantPattern:usize = 137; 
	pub const RULE_taggedUnionPattern:usize = 138; 
	pub const RULE_structPattern:usize = 139; 
	pub const RULE_tuplePattern:usize = 140; 
	pub const RULE_casePatItem_functionBodyStmt:usize = 141; 
	pub const RULE_casePatItem_actionStmt:usize = 142; 
	pub const RULE_casePatItem_actionValueStmt:usize = 143; 
	pub const RULE_casePatItem_moduleStmt:usize = 144; 
	pub const RULE_casePatItem_expressionStmt:usize = 145; 
	pub const RULE_caseExpr:usize = 146; 
	pub const RULE_caseExprItem:usize = 147; 
	pub const RULE_attribute_instance:usize = 148; 
	pub const RULE_attribute_instances:usize = 149; 
	pub const RULE_attribute_spec:usize = 150; 
	pub const RULE_attrName:usize = 151; 
	pub const RULE_provisos:usize = 152; 
	pub const RULE_proviso:usize = 153; 
	pub const RULE_typeclassDef:usize = 154; 
	pub const RULE_typeclassIde:usize = 155; 
	pub const RULE_typelist:usize = 156; 
	pub const RULE_typedepends:usize = 157; 
	pub const RULE_typedepend:usize = 158; 
	pub const RULE_overloadedDef:usize = 159; 
	pub const RULE_typeclassInstanceDef:usize = 160; 
	pub const RULE_derives:usize = 161; 
	pub const RULE_externModuleImport:usize = 162; 
	pub const RULE_importBVIStmt:usize = 163; 
	pub const RULE_enabled_sel:usize = 164; 
	pub const RULE_ready_sel:usize = 165; 
	pub const RULE_clocked_by_sel:usize = 166; 
	pub const RULE_reset_by_sel:usize = 167; 
	pub const RULE_parameterBVIStmt:usize = 168; 
	pub const RULE_methodBVIStmt:usize = 169; 
	pub const RULE_portBVIStmt:usize = 170; 
	pub const RULE_inputClockBVIStmt:usize = 171; 
	pub const RULE_portsDef:usize = 172; 
	pub const RULE_portId:usize = 173; 
	pub const RULE_defaultClockBVIStmt:usize = 174; 
	pub const RULE_outputClockBVIStmt:usize = 175; 
	pub const RULE_inputResetBVIStmt:usize = 176; 
	pub const RULE_clockId:usize = 177; 
	pub const RULE_defaultResetBVIStmt:usize = 178; 
	pub const RULE_outputResetBVIStmt:usize = 179; 
	pub const RULE_ancestorBVIStmt:usize = 180; 
	pub const RULE_sameFamilyBVIStmt:usize = 181; 
	pub const RULE_scheduleBVIStmt:usize = 182; 
	pub const RULE_operatorId:usize = 183; 
	pub const RULE_pathBVIStmt:usize = 184; 
	pub const RULE_interfaceBVIStmt:usize = 185; 
	pub const RULE_interfaceBVIMembDecl:usize = 186; 
	pub const RULE_inoutBVIStmt:usize = 187; 
	pub const RULE_resetId:usize = 188; 
	pub const RULE_noResetBVIStmt:usize = 189; 
	pub const RULE_externCImport:usize = 190; 
	pub const RULE_cFuncArgs:usize = 191; 
	pub const RULE_cFuncArg:usize = 192; 
	pub const RULE_fsmStmt:usize = 193; 
	pub const RULE_exprFsmStmt:usize = 194; 
	pub const RULE_seqFsmStmt:usize = 195; 
	pub const RULE_parFsmStmt:usize = 196; 
	pub const RULE_ifFsmStmt:usize = 197; 
	pub const RULE_whileFsmStmt:usize = 198; 
	pub const RULE_forFsmStmt:usize = 199; 
	pub const RULE_returnFsmStmt:usize = 200; 
	pub const RULE_repeatFsmStmt:usize = 201; 
	pub const RULE_loopBodyFsmStmt:usize = 202;
	pub const ruleNames: [&'static str; 203] =  [
		"identifier", "any_identifier", "top", "r_package", "non_package", "exportDecl", 
		"exportItem", "importDecl", "importItem", "packageStmt", "package_identifier", 
		"data_type", "numeric_type", "primary_type", "type_identifier", "interfaceDecl", 
		"typeDefType", "typeFormals", "typeFormal", "interfaceMemberDecl", "methodProto", 
		"methodProtoFormals", "methodProtoFormal", "subinterfaceDecl", "module_def", 
		"module_proto", "moduleprotoformals", "moduleprotoformal", "moduleFormalArgs", 
		"moduleStmt", "method_type", "method_def", "implicitCond", "methodFormals", 
		"methodFormal", "subinterfaceDef", "interfaceStmt", "expressionStmt", 
		"ruleDef", "ruleCond", "ruleBody", "typeDef", "typedefSynonym", "typedefEnum", 
		"typedefEnumElements", "typedefEnumElement", "typedefStruct", "typedefTaggedUnion", 
		"structMember", "unionMember", "subStruct", "subUnion", "variable_declaration", 
		"patternbinding", "variable_initialization", "variable_assignment", "lvalue", 
		"regWrite", "beginEndStmt_functionBodyStmt", "beginEndStmt_actionStmt", 
		"beginEndStmt_actionValueStmt", "beginEndStmt_moduleStmt", "beginEndStmt_expressionStmt", 
		"if_functionBodyStmt", "if_actionStmt", "if_actionValueStmt", "if_moduleStmt", 
		"if_expressionStmt", "case_actionStmt", "case_actionValueStmt", "case_moduleStmt", 
		"case_expressionStmt", "caseItem_functionBodyStmt", "caseItem_actionStmt", 
		"caseItem_actionValueStmt", "caseItem_moduleStmt", "caseItem_expressionStmt", 
		"defaultItem_functionBodyStmt", "defaultItem_actionStmt", "defaultItem_actionValueStmt", 
		"defaultItem_moduleStmt", "defaultItem_expressionStmt", "while_functionBodyStmt", 
		"while_actionStmt", "while_actionValueStmt", "while_moduleStmt", "while_expressionStmt", 
		"for_functionBodyStmt", "for_actionStmt", "for_actionValueStmt", "for_moduleStmt", 
		"for_expressionStmt", "simpleVarDeclAssign", "forInit", "forTest", "forIncr", 
		"varIncr", "function_def", "function_proto", "function_formals", "functionFormal", 
		"functionBody", "functionBodyStmt", "returnStmt", "expression", "caseexprpatitem", 
		"caseexpritem", "caseexprdefaultitem", "patterncond", "unary_operator", 
		"binary_operator", "binopexpr", "unopexpr", "constant_expression", "constant_primary", 
		"bit_concatination", "primary_expression", "memberbinds", "memberbind", 
		"interfacestmt", "cond_predicate", "exprOrCondPattern", "block_expression", 
		"actionBlock", "actionStmt", "actionValueBlock", "actionValueStmt", "varDeclDo", 
		"varDo", "typeAssertion", "structExpr", "memberBind", "taggedUnionExpr", 
		"interfaceExpr", "rulesExpr", "rulesStmt", "pattern", "constantPattern", 
		"taggedUnionPattern", "structPattern", "tuplePattern", "casePatItem_functionBodyStmt", 
		"casePatItem_actionStmt", "casePatItem_actionValueStmt", "casePatItem_moduleStmt", 
		"casePatItem_expressionStmt", "caseExpr", "caseExprItem", "attribute_instance", 
		"attribute_instances", "attribute_spec", "attrName", "provisos", "proviso", 
		"typeclassDef", "typeclassIde", "typelist", "typedepends", "typedepend", 
		"overloadedDef", "typeclassInstanceDef", "derives", "externModuleImport", 
		"importBVIStmt", "enabled_sel", "ready_sel", "clocked_by_sel", "reset_by_sel", 
		"parameterBVIStmt", "methodBVIStmt", "portBVIStmt", "inputClockBVIStmt", 
		"portsDef", "portId", "defaultClockBVIStmt", "outputClockBVIStmt", "inputResetBVIStmt", 
		"clockId", "defaultResetBVIStmt", "outputResetBVIStmt", "ancestorBVIStmt", 
		"sameFamilyBVIStmt", "scheduleBVIStmt", "operatorId", "pathBVIStmt", "interfaceBVIStmt", 
		"interfaceBVIMembDecl", "inoutBVIStmt", "resetId", "noResetBVIStmt", "externCImport", 
		"cFuncArgs", "cFuncArg", "fsmStmt", "exprFsmStmt", "seqFsmStmt", "parFsmStmt", 
		"ifFsmStmt", "whileFsmStmt", "forFsmStmt", "returnFsmStmt", "repeatFsmStmt", 
		"loopBodyFsmStmt"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;141] = [
		None, Some("'package'"), Some("';'"), Some("'endpackage'"), Some("':'"), 
		Some("'export'"), Some("','"), Some("'::'"), Some("'*'"), Some("'('"), 
		Some("'..'"), Some("')'"), Some("'import'"), Some("'#'"), Some("'bit'"), 
		Some("'['"), Some("']'"), Some("'SizeOf'"), Some("'interface'"), Some("'endinterface'"), 
		Some("'numeric'"), Some("'type'"), Some("'method'"), Some("'endmodule'"), 
		Some("'module'"), Some("'parameter'"), Some("'[]'"), Some("'Action'"), 
		Some("'ActionValue'"), Some("'endmethod'"), Some("'='"), Some("'if'"), 
		Some("'rule'"), Some("'endrule'"), Some("'typedef'"), Some("'enum'"), 
		Some("'{'"), Some("'}'"), Some("'struct'"), Some("'union'"), Some("'tagged'"), 
		Some("'void'"), Some("'let'"), Some("'match '"), Some("'match'"), Some("'<-'"), 
		Some("'.'"), Some("'+:'"), Some("'-:'"), Some("'<='"), Some("'begin'"), 
		Some("'end'"), Some("'else'"), Some("'case'"), Some("'endcase'"), Some("'matches'"), 
		Some("'default'"), Some("'while'"), Some("'for'"), Some("'endfunction'"), 
		Some("'function'"), Some("'return'"), Some("'?'"), Some("'&&&'"), Some("'+'"), 
		Some("'-'"), Some("'!'"), Some("'~'"), Some("'&'"), Some("'~&'"), Some("'|'"), 
		Some("'~|'"), Some("'^'"), Some("'~^'"), Some("'^~'"), Some("'/'"), Some("'%'"), 
		Some("'=='"), Some("'!='"), Some("'!=='"), Some("'&&'"), Some("'||'"), 
		Some("'**'"), Some("'<'"), Some("'>'"), Some("'>='"), Some("'>>'"), Some("'<<'"), 
		Some("'valueOf'"), Some("'valueof'"), Some("'''"), Some("'when'"), Some("'clocked_by'"), 
		Some("'reset_by'"), Some("'\u{2019}'"), Some("'action'"), Some("'endaction'"), 
		Some("'actionvalue'"), Some("'endactionvalue'"), Some("'rules'"), Some("'endrules'"), 
		Some("'.*'"), Some("'(*'"), Some("'*)'"), Some("'provisos'"), Some("'typeclass'"), 
		Some("'endtypeclass'"), Some("'dependencies'"), Some("'determines'"), 
		Some("'instance'"), Some("'endinstance'"), Some("'deriving'"), Some("'\"BVI\"'"), 
		Some("'enable'"), Some("'ready'"), Some("'port'"), Some("'input_clock'"), 
		Some("'default_clock'"), Some("'output_clock'"), Some("'input_reset'"), 
		Some("'default_reset'"), Some("'output_reset'"), Some("'ancestor'"), Some("'same_family'"), 
		Some("'schedule'"), Some("'CF'"), Some("'SB'"), Some("'SBR'"), Some("'C'"), 
		Some("'path'"), Some("'inout'"), Some("'ifc_inout'"), Some("'no_reset'"), 
		Some("'\"BDPI\"'"), Some("'seq'"), Some("'endseq'"), Some("'par'"), Some("'endpar'"), 
		Some("'repeat'"), Some("'break'"), Some("'continue'")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;155]  = [
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, None, None, None, 
		None, None, None, None, None, None, None, None, None, Some("LINE_COMMENT"), 
		Some("BLOCK_COMMENT"), Some("WHITESPACE"), Some("NEWLINE"), Some("UPPER_IDENTIFIER"), 
		Some("LOWER_IDENTIFIER"), Some("OPERATOR_IDENTIFIER"), Some("SYSTEM_TASK"), 
		Some("STRING_LITERAL"), Some("INT_LITERAL"), Some("DECIMAL"), Some("REAL_LITERAL"), 
		Some("COMPILER_DIRECTIVE"), Some("MACRO_INVOCATION")
	];
	lazy_static!{
	    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
		static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}


type BaseParserType<'input, I> =
	BaseParser<'input,BSVParserExt, I, BSVParserContextType , dyn BSVListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type BSVTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, BSVParserContextType , dyn BSVListener<'input> + 'a>;

/// Parser for BSV grammar
pub struct BSVParser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Arc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","2");
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				BSVParserExt{
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> BSVParser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> BSVParser<'input, I, DefaultErrorStrategy<'input,BSVParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for BSVParser
pub trait BSVParserContext<'input>:
	for<'x> Listenable<dyn BSVListener<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=BSVParserContextType>
{}

impl<'input> BSVParserContext<'input> for TerminalNode<'input,BSVParserContextType> {}
impl<'input> BSVParserContext<'input> for ErrorNode<'input,BSVParserContextType> {}

#[antlr_rust::impl_tid]
impl<'input> antlr_rust::TidAble<'input> for dyn BSVParserContext<'input> + 'input{}

#[antlr_rust::impl_tid]
impl<'input> antlr_rust::TidAble<'input> for dyn BSVListener<'input> + 'input{}

pub struct BSVParserContextType;
antlr_rust::type_id!{BSVParserContextType}

impl<'input> ParserNodeType<'input> for BSVParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn BSVParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct BSVParserExt{
}

impl BSVParserExt{
}


impl<'input> TokenAware<'input> for BSVParserExt{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for BSVParserExt{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for BSVParserExt{
	fn get_grammar_file_name(&self) -> & str{ "BSV.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }
	fn sempred(_localctx: Option<&(dyn BSVParserContext<'input> + 'input)>, rule_index: isize, pred_index: isize,
			   recog:&mut BaseParserType<'input,I>
	)->bool{
		match rule_index {
					104 => BSVParser::<'input,I,_>::expression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					111 => BSVParser::<'input,I,_>::binopexpr_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					113 => BSVParser::<'input,I,_>::constant_expression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					116 => BSVParser::<'input,I,_>::primary_expression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
			_ => true
		}
	}
}

impl<'input, I> BSVParser<'input, I, DefaultErrorStrategy<'input,BSVParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
	fn expression_sempred(_localctx: Option<&ExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				0=>{
					recog.precpred(None, 4)
				}
				1=>{
					recog.precpred(None, 3)
				}
			_ => true
		}
	}
	fn binopexpr_sempred(_localctx: Option<&BinopexprContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				2=>{
					recog.precpred(None, 2)
				}
			_ => true
		}
	}
	fn constant_expression_sempred(_localctx: Option<&Constant_expressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				3=>{
					recog.precpred(None, 2)
				}
				4=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn primary_expression_sempred(_localctx: Option<&Primary_expressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				5=>{
					recog.precpred(None, 15)
				}
				6=>{
					recog.precpred(None, 10)
				}
				7=>{
					recog.precpred(None, 9)
				}
			_ => true
		}
	}
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;


pub type IdentifierContext<'input> = BaseParserRuleContext<'input,IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for IdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for IdentifierContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_identifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::type_id!{IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IdentifierContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<IdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LOWER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token LOWER_IDENTIFIER
fn LOWER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(LOWER_IDENTIFIER, 0)
}

}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn identifier(&mut self,)
	-> Result<Rc<IdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(406);
			recog.base.match_token(LOWER_IDENTIFIER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- any_identifier ----------------
pub type Any_identifierContextAll<'input> = Any_identifierContext<'input>;


pub type Any_identifierContext<'input> = BaseParserRuleContext<'input,Any_identifierContextExt<'input>>;

#[derive(Clone)]
pub struct Any_identifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Any_identifierContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Any_identifierContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_any_identifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for Any_identifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_any_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_any_identifier }
}
antlr_rust::type_id!{Any_identifierContextExt<'a>}

impl<'input> Any_identifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Any_identifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Any_identifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Any_identifierContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Any_identifierContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}

}

impl<'input> Any_identifierContextAttrs<'input> for Any_identifierContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn any_identifier(&mut self,)
	-> Result<Rc<Any_identifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Any_identifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_any_identifier);
        let mut _localctx: Rc<Any_identifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(410);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LOWER_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(408);
					recog.identifier()?;

					}
				}

			 UPPER_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(409);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- top ----------------
pub type TopContextAll<'input> = TopContext<'input>;


pub type TopContext<'input> = BaseParserRuleContext<'input,TopContextExt<'input>>;

#[derive(Clone)]
pub struct TopContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TopContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TopContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_top(self);
	}
}

impl<'input> CustomRuleContext<'input> for TopContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_top }
	//fn type_rule_index() -> usize where Self: Sized { RULE_top }
}
antlr_rust::type_id!{TopContextExt<'a>}

impl<'input> TopContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TopContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TopContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TopContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TopContextExt<'input>>{

fn exportDecl_all(&self) ->  Vec<Rc<ExportDeclContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn exportDecl(&self, i: usize) -> Option<Rc<ExportDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn importDecl_all(&self) ->  Vec<Rc<ImportDeclContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importDecl(&self, i: usize) -> Option<Rc<ImportDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn packageStmt_all(&self) ->  Vec<Rc<PackageStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn packageStmt(&self, i: usize) -> Option<Rc<PackageStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn r_package_all(&self) ->  Vec<Rc<R_packageContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn r_package(&self, i: usize) -> Option<Rc<R_packageContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TopContextAttrs<'input> for TopContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn top(&mut self,)
	-> Result<Rc<TopContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TopContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_top);
        let mut _localctx: Rc<TopContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(418);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__4) | (1usize << T__11) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__33) | (1usize << T__41) | (1usize << T__42) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (T__104 - 102)) | (1usize << (T__108 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
				{
				recog.base.set_state(416);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(1,&mut recog.base)? {
					1 =>{
						{
						/*InvokeRule exportDecl*/
						recog.base.set_state(412);
						recog.exportDecl()?;

						}
					}
				,
					2 =>{
						{
						/*InvokeRule importDecl*/
						recog.base.set_state(413);
						recog.importDecl()?;

						}
					}
				,
					3 =>{
						{
						/*InvokeRule packageStmt*/
						recog.base.set_state(414);
						recog.packageStmt()?;

						}
					}
				,
					4 =>{
						{
						/*InvokeRule r_package*/
						recog.base.set_state(415);
						recog.r_package()?;

						}
					}

					_ => {}
				}
				}
				recog.base.set_state(420);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- r_package ----------------
pub type R_packageContextAll<'input> = R_packageContext<'input>;


pub type R_packageContext<'input> = BaseParserRuleContext<'input,R_packageContextExt<'input>>;

#[derive(Clone)]
pub struct R_packageContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for R_packageContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for R_packageContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_r_package(self);
	}
}

impl<'input> CustomRuleContext<'input> for R_packageContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_r_package }
	//fn type_rule_index() -> usize where Self: Sized { RULE_r_package }
}
antlr_rust::type_id!{R_packageContextExt<'a>}

impl<'input> R_packageContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<R_packageContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,R_packageContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait R_packageContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<R_packageContextExt<'input>>{

fn package_identifier_all(&self) ->  Vec<Rc<Package_identifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn package_identifier(&self, i: usize) -> Option<Rc<Package_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn exportDecl_all(&self) ->  Vec<Rc<ExportDeclContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn exportDecl(&self, i: usize) -> Option<Rc<ExportDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn importDecl_all(&self) ->  Vec<Rc<ImportDeclContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importDecl(&self, i: usize) -> Option<Rc<ImportDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn packageStmt_all(&self) ->  Vec<Rc<PackageStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn packageStmt(&self, i: usize) -> Option<Rc<PackageStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> R_packageContextAttrs<'input> for R_packageContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn r_package(&mut self,)
	-> Result<Rc<R_packageContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = R_packageContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_r_package);
        let mut _localctx: Rc<R_packageContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(421);
			recog.base.match_token(T__0,&mut recog.err_handler)?;

			/*InvokeRule package_identifier*/
			recog.base.set_state(422);
			recog.package_identifier()?;

			recog.base.set_state(423);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			recog.base.set_state(429);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__4) | (1usize << T__11) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__33) | (1usize << T__41) | (1usize << T__42) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (T__104 - 102)) | (1usize << (T__108 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
				{
				recog.base.set_state(427);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(3,&mut recog.base)? {
					1 =>{
						{
						/*InvokeRule exportDecl*/
						recog.base.set_state(424);
						recog.exportDecl()?;

						}
					}
				,
					2 =>{
						{
						/*InvokeRule importDecl*/
						recog.base.set_state(425);
						recog.importDecl()?;

						}
					}
				,
					3 =>{
						{
						/*InvokeRule packageStmt*/
						recog.base.set_state(426);
						recog.packageStmt()?;

						}
					}

					_ => {}
				}
				}
				recog.base.set_state(431);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(432);
			recog.base.match_token(T__2,&mut recog.err_handler)?;

			recog.base.set_state(435);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(433);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule package_identifier*/
				recog.base.set_state(434);
				recog.package_identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- non_package ----------------
pub type Non_packageContextAll<'input> = Non_packageContext<'input>;


pub type Non_packageContext<'input> = BaseParserRuleContext<'input,Non_packageContextExt<'input>>;

#[derive(Clone)]
pub struct Non_packageContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Non_packageContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Non_packageContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_non_package(self);
	}
}

impl<'input> CustomRuleContext<'input> for Non_packageContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_non_package }
	//fn type_rule_index() -> usize where Self: Sized { RULE_non_package }
}
antlr_rust::type_id!{Non_packageContextExt<'a>}

impl<'input> Non_packageContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Non_packageContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Non_packageContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Non_packageContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Non_packageContextExt<'input>>{

fn exportDecl_all(&self) ->  Vec<Rc<ExportDeclContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn exportDecl(&self, i: usize) -> Option<Rc<ExportDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn importDecl_all(&self) ->  Vec<Rc<ImportDeclContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importDecl(&self, i: usize) -> Option<Rc<ImportDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn packageStmt_all(&self) ->  Vec<Rc<PackageStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn packageStmt(&self, i: usize) -> Option<Rc<PackageStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Non_packageContextAttrs<'input> for Non_packageContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn non_package(&mut self,)
	-> Result<Rc<Non_packageContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Non_packageContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_non_package);
        let mut _localctx: Rc<Non_packageContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(455);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(9,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(440);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__4 {
						{
						{
						/*InvokeRule exportDecl*/
						recog.base.set_state(437);
						recog.exportDecl()?;

						}
						}
						recog.base.set_state(442);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(446);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__11 {
						{
						{
						/*InvokeRule importDecl*/
						recog.base.set_state(443);
						recog.importDecl()?;

						}
						}
						recog.base.set_state(448);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(452);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__11) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__33) | (1usize << T__41) | (1usize << T__42) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (T__104 - 102)) | (1usize << (T__108 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
						{
						{
						/*InvokeRule packageStmt*/
						recog.base.set_state(449);
						recog.packageStmt()?;

						}
						}
						recog.base.set_state(454);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exportDecl ----------------
pub type ExportDeclContextAll<'input> = ExportDeclContext<'input>;


pub type ExportDeclContext<'input> = BaseParserRuleContext<'input,ExportDeclContextExt<'input>>;

#[derive(Clone)]
pub struct ExportDeclContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ExportDeclContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExportDeclContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_exportDecl(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExportDeclContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exportDecl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exportDecl }
}
antlr_rust::type_id!{ExportDeclContextExt<'a>}

impl<'input> ExportDeclContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExportDeclContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExportDeclContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExportDeclContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ExportDeclContextExt<'input>>{

fn exportItem_all(&self) ->  Vec<Rc<ExportItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn exportItem(&self, i: usize) -> Option<Rc<ExportItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ExportDeclContextAttrs<'input> for ExportDeclContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exportDecl(&mut self,)
	-> Result<Rc<ExportDeclContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExportDeclContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_exportDecl);
        let mut _localctx: Rc<ExportDeclContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(457);
			recog.base.match_token(T__4,&mut recog.err_handler)?;

			/*InvokeRule exportItem*/
			recog.base.set_state(458);
			recog.exportItem()?;

			recog.base.set_state(463);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(459);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule exportItem*/
				recog.base.set_state(460);
				recog.exportItem()?;

				}
				}
				recog.base.set_state(465);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(466);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exportItem ----------------
pub type ExportItemContextAll<'input> = ExportItemContext<'input>;


pub type ExportItemContext<'input> = BaseParserRuleContext<'input,ExportItemContextExt<'input>>;

#[derive(Clone)]
pub struct ExportItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ExportItemContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExportItemContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_exportItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExportItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exportItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exportItem }
}
antlr_rust::type_id!{ExportItemContextExt<'a>}

impl<'input> ExportItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExportItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExportItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExportItemContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ExportItemContextExt<'input>>{

fn package_identifier(&self) -> Option<Rc<Package_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn any_identifier(&self) -> Option<Rc<Any_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExportItemContextAttrs<'input> for ExportItemContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exportItem(&mut self,)
	-> Result<Rc<ExportItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExportItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_exportItem);
        let mut _localctx: Rc<ExportItemContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(478);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(12,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule package_identifier*/
					recog.base.set_state(468);
					recog.package_identifier()?;

					recog.base.set_state(469);
					recog.base.match_token(T__6,&mut recog.err_handler)?;

					recog.base.set_state(470);
					recog.base.match_token(T__7,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule any_identifier*/
					recog.base.set_state(472);
					recog.any_identifier()?;

					recog.base.set_state(476);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__8 {
						{
						recog.base.set_state(473);
						recog.base.match_token(T__8,&mut recog.err_handler)?;

						recog.base.set_state(474);
						recog.base.match_token(T__9,&mut recog.err_handler)?;

						recog.base.set_state(475);
						recog.base.match_token(T__10,&mut recog.err_handler)?;

						}
					}

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importDecl ----------------
pub type ImportDeclContextAll<'input> = ImportDeclContext<'input>;


pub type ImportDeclContext<'input> = BaseParserRuleContext<'input,ImportDeclContextExt<'input>>;

#[derive(Clone)]
pub struct ImportDeclContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ImportDeclContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ImportDeclContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_importDecl(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportDeclContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importDecl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importDecl }
}
antlr_rust::type_id!{ImportDeclContextExt<'a>}

impl<'input> ImportDeclContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportDeclContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportDeclContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportDeclContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ImportDeclContextExt<'input>>{

fn importItem_all(&self) ->  Vec<Rc<ImportItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importItem(&self, i: usize) -> Option<Rc<ImportItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ImportDeclContextAttrs<'input> for ImportDeclContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importDecl(&mut self,)
	-> Result<Rc<ImportDeclContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportDeclContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_importDecl);
        let mut _localctx: Rc<ImportDeclContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(480);
			recog.base.match_token(T__11,&mut recog.err_handler)?;

			/*InvokeRule importItem*/
			recog.base.set_state(481);
			recog.importItem()?;

			recog.base.set_state(486);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(482);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule importItem*/
				recog.base.set_state(483);
				recog.importItem()?;

				}
				}
				recog.base.set_state(488);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(489);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importItem ----------------
pub type ImportItemContextAll<'input> = ImportItemContext<'input>;


pub type ImportItemContext<'input> = BaseParserRuleContext<'input,ImportItemContextExt<'input>>;

#[derive(Clone)]
pub struct ImportItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ImportItemContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ImportItemContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_importItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importItem }
}
antlr_rust::type_id!{ImportItemContextExt<'a>}

impl<'input> ImportItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportItemContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ImportItemContextExt<'input>>{

fn package_identifier(&self) -> Option<Rc<Package_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImportItemContextAttrs<'input> for ImportItemContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importItem(&mut self,)
	-> Result<Rc<ImportItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_importItem);
        let mut _localctx: Rc<ImportItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule package_identifier*/
			recog.base.set_state(491);
			recog.package_identifier()?;

			recog.base.set_state(492);
			recog.base.match_token(T__6,&mut recog.err_handler)?;

			recog.base.set_state(493);
			recog.base.match_token(T__7,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageStmt ----------------
pub type PackageStmtContextAll<'input> = PackageStmtContext<'input>;


pub type PackageStmtContext<'input> = BaseParserRuleContext<'input,PackageStmtContextExt<'input>>;

#[derive(Clone)]
pub struct PackageStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for PackageStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for PackageStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_packageStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for PackageStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageStmt }
}
antlr_rust::type_id!{PackageStmtContextExt<'a>}

impl<'input> PackageStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<PackageStmtContextExt<'input>>{

fn module_def(&self) -> Option<Rc<Module_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDecl(&self) -> Option<Rc<InterfaceDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeDef(&self) -> Option<Rc<TypeDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_declaration(&self) -> Option<Rc<Variable_declarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_assignment(&self) -> Option<Rc<Variable_assignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_def(&self) -> Option<Rc<Function_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeclassDef(&self) -> Option<Rc<TypeclassDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeclassInstanceDef(&self) -> Option<Rc<TypeclassInstanceDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn externModuleImport(&self) -> Option<Rc<ExternModuleImportContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn externCImport(&self) -> Option<Rc<ExternCImportContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackageStmtContextAttrs<'input> for PackageStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageStmt(&mut self,)
	-> Result<Rc<PackageStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_packageStmt);
        let mut _localctx: Rc<PackageStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(505);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(14,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule module_def*/
					recog.base.set_state(495);
					recog.module_def()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule interfaceDecl*/
					recog.base.set_state(496);
					recog.interfaceDecl()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typeDef*/
					recog.base.set_state(497);
					recog.typeDef()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule variable_declaration*/
					recog.base.set_state(498);
					recog.variable_declaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule variable_assignment*/
					recog.base.set_state(499);
					recog.variable_assignment()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule function_def*/
					recog.base.set_state(500);
					recog.function_def()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule typeclassDef*/
					recog.base.set_state(501);
					recog.typeclassDef()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule typeclassInstanceDef*/
					recog.base.set_state(502);
					recog.typeclassInstanceDef()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule externModuleImport*/
					recog.base.set_state(503);
					recog.externModuleImport()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule externCImport*/
					recog.base.set_state(504);
					recog.externCImport()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- package_identifier ----------------
pub type Package_identifierContextAll<'input> = Package_identifierContext<'input>;


pub type Package_identifierContext<'input> = BaseParserRuleContext<'input,Package_identifierContextExt<'input>>;

#[derive(Clone)]
pub struct Package_identifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Package_identifierContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Package_identifierContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_package_identifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for Package_identifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_package_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_package_identifier }
}
antlr_rust::type_id!{Package_identifierContextExt<'a>}

impl<'input> Package_identifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Package_identifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Package_identifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Package_identifierContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Package_identifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}

}

impl<'input> Package_identifierContextAttrs<'input> for Package_identifierContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn package_identifier(&mut self,)
	-> Result<Rc<Package_identifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Package_identifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_package_identifier);
        let mut _localctx: Rc<Package_identifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(507);
			recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- data_type ----------------
pub type Data_typeContextAll<'input> = Data_typeContext<'input>;


pub type Data_typeContext<'input> = BaseParserRuleContext<'input,Data_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Data_typeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Data_typeContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Data_typeContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_data_type(self);
	}
}

impl<'input> CustomRuleContext<'input> for Data_typeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_data_type }
	//fn type_rule_index() -> usize where Self: Sized { RULE_data_type }
}
antlr_rust::type_id!{Data_typeContextExt<'a>}

impl<'input> Data_typeContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Data_typeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Data_typeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Data_typeContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Data_typeContextExt<'input>>{

fn primary_type(&self) -> Option<Rc<Primary_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Data_typeContextAttrs<'input> for Data_typeContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn data_type(&mut self,)
	-> Result<Rc<Data_typeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Data_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_data_type);
        let mut _localctx: Rc<Data_typeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule primary_type*/
			recog.base.set_state(509);
			recog.primary_type()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- numeric_type ----------------
pub type Numeric_typeContextAll<'input> = Numeric_typeContext<'input>;


pub type Numeric_typeContext<'input> = BaseParserRuleContext<'input,Numeric_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Numeric_typeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Numeric_typeContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Numeric_typeContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_numeric_type(self);
	}
}

impl<'input> CustomRuleContext<'input> for Numeric_typeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_numeric_type }
	//fn type_rule_index() -> usize where Self: Sized { RULE_numeric_type }
}
antlr_rust::type_id!{Numeric_typeContextExt<'a>}

impl<'input> Numeric_typeContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Numeric_typeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Numeric_typeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Numeric_typeContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Numeric_typeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INT_LITERAL
/// Returns `None` if there is no child corresponding to token INT_LITERAL
fn INT_LITERAL(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(INT_LITERAL, 0)
}

}

impl<'input> Numeric_typeContextAttrs<'input> for Numeric_typeContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn numeric_type(&mut self,)
	-> Result<Rc<Numeric_typeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Numeric_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_numeric_type);
        let mut _localctx: Rc<Numeric_typeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(511);
			recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primary_type ----------------
pub type Primary_typeContextAll<'input> = Primary_typeContext<'input>;


pub type Primary_typeContext<'input> = BaseParserRuleContext<'input,Primary_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Primary_typeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Primary_typeContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Primary_typeContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_primary_type(self);
	}
}

impl<'input> CustomRuleContext<'input> for Primary_typeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_type }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_type }
}
antlr_rust::type_id!{Primary_typeContextExt<'a>}

impl<'input> Primary_typeContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Primary_typeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Primary_typeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Primary_typeContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Primary_typeContextExt<'input>>{

fn type_identifier(&self) -> Option<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type_all(&self) ->  Vec<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn data_type(&self, i: usize) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn numeric_type_all(&self) ->  Vec<Rc<Numeric_typeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn numeric_type(&self, i: usize) -> Option<Rc<Numeric_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Primary_typeContextAttrs<'input> for Primary_typeContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primary_type(&mut self,)
	-> Result<Rc<Primary_typeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Primary_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_primary_type);
        let mut _localctx: Rc<Primary_typeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(536);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__16 | UPPER_IDENTIFIER | LOWER_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule type_identifier*/
					recog.base.set_state(513);
					recog.type_identifier()?;

					recog.base.set_state(526);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__12 {
						{
						recog.base.set_state(514);
						recog.base.match_token(T__12,&mut recog.err_handler)?;

						recog.base.set_state(515);
						recog.base.match_token(T__8,&mut recog.err_handler)?;

						/*InvokeRule data_type*/
						recog.base.set_state(516);
						recog.data_type()?;

						recog.base.set_state(521);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==T__5 {
							{
							{
							recog.base.set_state(517);
							recog.base.match_token(T__5,&mut recog.err_handler)?;

							/*InvokeRule data_type*/
							recog.base.set_state(518);
							recog.data_type()?;

							}
							}
							recog.base.set_state(523);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(524);
						recog.base.match_token(T__10,&mut recog.err_handler)?;

						}
					}

					}
				}

			 INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule numeric_type*/
					recog.base.set_state(528);
					recog.numeric_type()?;

					}
				}

			 T__13 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(529);
					recog.base.match_token(T__13,&mut recog.err_handler)?;

					recog.base.set_state(530);
					recog.base.match_token(T__14,&mut recog.err_handler)?;

					/*InvokeRule numeric_type*/
					recog.base.set_state(531);
					recog.numeric_type()?;

					recog.base.set_state(532);
					recog.base.match_token(T__3,&mut recog.err_handler)?;

					/*InvokeRule numeric_type*/
					recog.base.set_state(533);
					recog.numeric_type()?;

					recog.base.set_state(534);
					recog.base.match_token(T__15,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- type_identifier ----------------
pub type Type_identifierContextAll<'input> = Type_identifierContext<'input>;


pub type Type_identifierContext<'input> = BaseParserRuleContext<'input,Type_identifierContextExt<'input>>;

#[derive(Clone)]
pub struct Type_identifierContextExt<'input>{
	pub pkg: Option<TokenType<'input>>,
	pub name: Option<TokenType<'input>>,
	pub typevar: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Type_identifierContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Type_identifierContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_type_identifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for Type_identifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_type_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_type_identifier }
}
antlr_rust::type_id!{Type_identifierContextExt<'a>}

impl<'input> Type_identifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Type_identifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Type_identifierContextExt{
				pkg: None, name: None, 
				typevar: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait Type_identifierContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Type_identifierContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token UPPER_IDENTIFIER in current rule
fn UPPER_IDENTIFIER_all(&self) -> Vec<Rc<TerminalNode<'input,BSVParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token UPPER_IDENTIFIER, starting from 0.
/// Returns `None` if number of children corresponding to token UPPER_IDENTIFIER is less or equal than `i`.
fn UPPER_IDENTIFIER(&self, i: usize) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, i)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Type_identifierContextAttrs<'input> for Type_identifierContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn type_identifier(&mut self,)
	-> Result<Rc<Type_identifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Type_identifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_type_identifier);
        let mut _localctx: Rc<Type_identifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			recog.base.set_state(548);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 UPPER_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(542);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(18,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(538);
							let tmp = recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;
							 cast_mut::<_,Type_identifierContext >(&mut _localctx).pkg = Some(tmp.clone());
							  

							recog.base.set_state(539);
							recog.base.match_token(T__6,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(544);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(18,&mut recog.base)?;
					}
					recog.base.set_state(545);
					let tmp = recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;
					 cast_mut::<_,Type_identifierContext >(&mut _localctx).name = Some(tmp.clone());
					  

					}
				}

			 T__16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(546);
					recog.base.match_token(T__16,&mut recog.err_handler)?;

					}
				}

			 LOWER_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(547);
					let tmp = recog.identifier()?;
					 cast_mut::<_,Type_identifierContext >(&mut _localctx).typevar = Some(tmp.clone());
					  

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceDecl ----------------
pub type InterfaceDeclContextAll<'input> = InterfaceDeclContext<'input>;


pub type InterfaceDeclContext<'input> = BaseParserRuleContext<'input,InterfaceDeclContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceDeclContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InterfaceDeclContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InterfaceDeclContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_interfaceDecl(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceDeclContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceDecl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceDecl }
}
antlr_rust::type_id!{InterfaceDeclContextExt<'a>}

impl<'input> InterfaceDeclContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceDeclContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceDeclContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceDeclContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InterfaceDeclContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeDefType(&self) -> Option<Rc<TypeDefTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceMemberDecl_all(&self) ->  Vec<Rc<InterfaceMemberDeclContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceMemberDecl(&self, i: usize) -> Option<Rc<InterfaceMemberDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn type_identifier(&self) -> Option<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceDeclContextAttrs<'input> for InterfaceDeclContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceDecl(&mut self,)
	-> Result<Rc<InterfaceDeclContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceDeclContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_interfaceDecl);
        let mut _localctx: Rc<InterfaceDeclContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(550);
			recog.attribute_instances()?;

			recog.base.set_state(551);
			recog.base.match_token(T__17,&mut recog.err_handler)?;

			/*InvokeRule typeDefType*/
			recog.base.set_state(552);
			recog.typeDefType()?;

			recog.base.set_state(553);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			recog.base.set_state(557);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__17 || _la==T__21 || _la==T__101 {
				{
				{
				/*InvokeRule interfaceMemberDecl*/
				recog.base.set_state(554);
				recog.interfaceMemberDecl()?;

				}
				}
				recog.base.set_state(559);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(560);
			recog.base.match_token(T__18,&mut recog.err_handler)?;

			recog.base.set_state(563);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(561);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule type_identifier*/
				recog.base.set_state(562);
				recog.type_identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeDefType ----------------
pub type TypeDefTypeContextAll<'input> = TypeDefTypeContext<'input>;


pub type TypeDefTypeContext<'input> = BaseParserRuleContext<'input,TypeDefTypeContextExt<'input>>;

#[derive(Clone)]
pub struct TypeDefTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypeDefTypeContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeDefTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeDefType(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeDefTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeDefType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeDefType }
}
antlr_rust::type_id!{TypeDefTypeContextExt<'a>}

impl<'input> TypeDefTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeDefTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeDefTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeDefTypeContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypeDefTypeContextExt<'input>>{

fn type_identifier(&self) -> Option<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeFormals(&self) -> Option<Rc<TypeFormalsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeDefTypeContextAttrs<'input> for TypeDefTypeContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeDefType(&mut self,)
	-> Result<Rc<TypeDefTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeDefTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_typeDefType);
        let mut _localctx: Rc<TypeDefTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule type_identifier*/
			recog.base.set_state(565);
			recog.type_identifier()?;

			recog.base.set_state(567);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__12 {
				{
				/*InvokeRule typeFormals*/
				recog.base.set_state(566);
				recog.typeFormals()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeFormals ----------------
pub type TypeFormalsContextAll<'input> = TypeFormalsContext<'input>;


pub type TypeFormalsContext<'input> = BaseParserRuleContext<'input,TypeFormalsContextExt<'input>>;

#[derive(Clone)]
pub struct TypeFormalsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypeFormalsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeFormalsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeFormals(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeFormalsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeFormals }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeFormals }
}
antlr_rust::type_id!{TypeFormalsContextExt<'a>}

impl<'input> TypeFormalsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeFormalsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeFormalsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeFormalsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypeFormalsContextExt<'input>>{

fn typeFormal_all(&self) ->  Vec<Rc<TypeFormalContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeFormal(&self, i: usize) -> Option<Rc<TypeFormalContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeFormalsContextAttrs<'input> for TypeFormalsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeFormals(&mut self,)
	-> Result<Rc<TypeFormalsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeFormalsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_typeFormals);
        let mut _localctx: Rc<TypeFormalsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(569);
			recog.base.match_token(T__12,&mut recog.err_handler)?;

			recog.base.set_state(570);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule typeFormal*/
			recog.base.set_state(571);
			recog.typeFormal()?;

			recog.base.set_state(576);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(572);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule typeFormal*/
				recog.base.set_state(573);
				recog.typeFormal()?;

				}
				}
				recog.base.set_state(578);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(579);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeFormal ----------------
pub type TypeFormalContextAll<'input> = TypeFormalContext<'input>;


pub type TypeFormalContext<'input> = BaseParserRuleContext<'input,TypeFormalContextExt<'input>>;

#[derive(Clone)]
pub struct TypeFormalContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypeFormalContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeFormalContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeFormal(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeFormalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeFormal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeFormal }
}
antlr_rust::type_id!{TypeFormalContextExt<'a>}

impl<'input> TypeFormalContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeFormalContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeFormalContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeFormalContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypeFormalContextExt<'input>>{

fn type_identifier(&self) -> Option<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeFormalContextAttrs<'input> for TypeFormalContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeFormal(&mut self,)
	-> Result<Rc<TypeFormalContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeFormalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_typeFormal);
        let mut _localctx: Rc<TypeFormalContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(582);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__19 {
				{
				recog.base.set_state(581);
				recog.base.match_token(T__19,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(585);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__20 {
				{
				recog.base.set_state(584);
				recog.base.match_token(T__20,&mut recog.err_handler)?;

				}
			}

			{
			/*InvokeRule type_identifier*/
			recog.base.set_state(587);
			recog.type_identifier()?;

			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceMemberDecl ----------------
pub type InterfaceMemberDeclContextAll<'input> = InterfaceMemberDeclContext<'input>;


pub type InterfaceMemberDeclContext<'input> = BaseParserRuleContext<'input,InterfaceMemberDeclContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceMemberDeclContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InterfaceMemberDeclContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InterfaceMemberDeclContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_interfaceMemberDecl(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceMemberDeclContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceMemberDecl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceMemberDecl }
}
antlr_rust::type_id!{InterfaceMemberDeclContextExt<'a>}

impl<'input> InterfaceMemberDeclContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceMemberDeclContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceMemberDeclContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceMemberDeclContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InterfaceMemberDeclContextExt<'input>>{

fn methodProto(&self) -> Option<Rc<MethodProtoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subinterfaceDecl(&self) -> Option<Rc<SubinterfaceDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceMemberDeclContextAttrs<'input> for InterfaceMemberDeclContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceMemberDecl(&mut self,)
	-> Result<Rc<InterfaceMemberDeclContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceMemberDeclContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_interfaceMemberDecl);
        let mut _localctx: Rc<InterfaceMemberDeclContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(591);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(26,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule methodProto*/
					recog.base.set_state(589);
					recog.methodProto()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule subinterfaceDecl*/
					recog.base.set_state(590);
					recog.subinterfaceDecl()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodProto ----------------
pub type MethodProtoContextAll<'input> = MethodProtoContext<'input>;


pub type MethodProtoContext<'input> = BaseParserRuleContext<'input,MethodProtoContextExt<'input>>;

#[derive(Clone)]
pub struct MethodProtoContextExt<'input>{
	pub name: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MethodProtoContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MethodProtoContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_methodProto(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodProtoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodProto }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodProto }
}
antlr_rust::type_id!{MethodProtoContextExt<'a>}

impl<'input> MethodProtoContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodProtoContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodProtoContextExt{
				name: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodProtoContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MethodProtoContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn method_type(&self) -> Option<Rc<Method_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodProtoFormals(&self) -> Option<Rc<MethodProtoFormalsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodProtoContextAttrs<'input> for MethodProtoContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodProto(&mut self,)
	-> Result<Rc<MethodProtoContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodProtoContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_methodProto);
        let mut _localctx: Rc<MethodProtoContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(593);
			recog.attribute_instances()?;

			recog.base.set_state(594);
			recog.base.match_token(T__21,&mut recog.err_handler)?;

			/*InvokeRule method_type*/
			recog.base.set_state(595);
			recog.method_type()?;

			/*InvokeRule identifier*/
			recog.base.set_state(596);
			let tmp = recog.identifier()?;
			 cast_mut::<_,MethodProtoContext >(&mut _localctx).name = Some(tmp.clone());
			  

			recog.base.set_state(602);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__8 {
				{
				recog.base.set_state(597);
				recog.base.match_token(T__8,&mut recog.err_handler)?;

				recog.base.set_state(599);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==T__13 || _la==T__16 || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
					{
					/*InvokeRule methodProtoFormals*/
					recog.base.set_state(598);
					recog.methodProtoFormals()?;

					}
				}

				recog.base.set_state(601);
				recog.base.match_token(T__10,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(604);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodProtoFormals ----------------
pub type MethodProtoFormalsContextAll<'input> = MethodProtoFormalsContext<'input>;


pub type MethodProtoFormalsContext<'input> = BaseParserRuleContext<'input,MethodProtoFormalsContextExt<'input>>;

#[derive(Clone)]
pub struct MethodProtoFormalsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MethodProtoFormalsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MethodProtoFormalsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_methodProtoFormals(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodProtoFormalsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodProtoFormals }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodProtoFormals }
}
antlr_rust::type_id!{MethodProtoFormalsContextExt<'a>}

impl<'input> MethodProtoFormalsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodProtoFormalsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodProtoFormalsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodProtoFormalsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MethodProtoFormalsContextExt<'input>>{

fn methodProtoFormal_all(&self) ->  Vec<Rc<MethodProtoFormalContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn methodProtoFormal(&self, i: usize) -> Option<Rc<MethodProtoFormalContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodProtoFormalsContextAttrs<'input> for MethodProtoFormalsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodProtoFormals(&mut self,)
	-> Result<Rc<MethodProtoFormalsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodProtoFormalsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_methodProtoFormals);
        let mut _localctx: Rc<MethodProtoFormalsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule methodProtoFormal*/
			recog.base.set_state(606);
			recog.methodProtoFormal()?;

			recog.base.set_state(611);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(607);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule methodProtoFormal*/
				recog.base.set_state(608);
				recog.methodProtoFormal()?;

				}
				}
				recog.base.set_state(613);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodProtoFormal ----------------
pub type MethodProtoFormalContextAll<'input> = MethodProtoFormalContext<'input>;


pub type MethodProtoFormalContext<'input> = BaseParserRuleContext<'input,MethodProtoFormalContextExt<'input>>;

#[derive(Clone)]
pub struct MethodProtoFormalContextExt<'input>{
	pub name: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MethodProtoFormalContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MethodProtoFormalContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_methodProtoFormal(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodProtoFormalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodProtoFormal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodProtoFormal }
}
antlr_rust::type_id!{MethodProtoFormalContextExt<'a>}

impl<'input> MethodProtoFormalContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodProtoFormalContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodProtoFormalContextExt{
				name: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodProtoFormalContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MethodProtoFormalContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodProtoFormalContextAttrs<'input> for MethodProtoFormalContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodProtoFormal(&mut self,)
	-> Result<Rc<MethodProtoFormalContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodProtoFormalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_methodProtoFormal);
        let mut _localctx: Rc<MethodProtoFormalContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(614);
			recog.attribute_instances()?;

			recog.base.set_state(616);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(30,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule data_type*/
					recog.base.set_state(615);
					recog.data_type()?;

					}
				}

				_ => {}
			}
			/*InvokeRule identifier*/
			recog.base.set_state(618);
			let tmp = recog.identifier()?;
			 cast_mut::<_,MethodProtoFormalContext >(&mut _localctx).name = Some(tmp.clone());
			  

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subinterfaceDecl ----------------
pub type SubinterfaceDeclContextAll<'input> = SubinterfaceDeclContext<'input>;


pub type SubinterfaceDeclContext<'input> = BaseParserRuleContext<'input,SubinterfaceDeclContextExt<'input>>;

#[derive(Clone)]
pub struct SubinterfaceDeclContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for SubinterfaceDeclContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for SubinterfaceDeclContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_subinterfaceDecl(self);
	}
}

impl<'input> CustomRuleContext<'input> for SubinterfaceDeclContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subinterfaceDecl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subinterfaceDecl }
}
antlr_rust::type_id!{SubinterfaceDeclContextExt<'a>}

impl<'input> SubinterfaceDeclContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubinterfaceDeclContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubinterfaceDeclContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubinterfaceDeclContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<SubinterfaceDeclContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeDefType(&self) -> Option<Rc<TypeDefTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubinterfaceDeclContextAttrs<'input> for SubinterfaceDeclContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subinterfaceDecl(&mut self,)
	-> Result<Rc<SubinterfaceDeclContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubinterfaceDeclContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_subinterfaceDecl);
        let mut _localctx: Rc<SubinterfaceDeclContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(620);
			recog.attribute_instances()?;

			recog.base.set_state(621);
			recog.base.match_token(T__17,&mut recog.err_handler)?;

			/*InvokeRule typeDefType*/
			recog.base.set_state(622);
			recog.typeDefType()?;

			/*InvokeRule identifier*/
			recog.base.set_state(623);
			recog.identifier()?;

			recog.base.set_state(624);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- module_def ----------------
pub type Module_defContextAll<'input> = Module_defContext<'input>;


pub type Module_defContext<'input> = BaseParserRuleContext<'input,Module_defContextExt<'input>>;

#[derive(Clone)]
pub struct Module_defContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Module_defContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Module_defContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_module_def(self);
	}
}

impl<'input> CustomRuleContext<'input> for Module_defContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_module_def }
	//fn type_rule_index() -> usize where Self: Sized { RULE_module_def }
}
antlr_rust::type_id!{Module_defContextExt<'a>}

impl<'input> Module_defContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Module_defContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Module_defContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Module_defContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Module_defContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn module_proto(&self) -> Option<Rc<Module_protoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moduleStmt_all(&self) ->  Vec<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleStmt(&self, i: usize) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Module_defContextAttrs<'input> for Module_defContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn module_def(&mut self,)
	-> Result<Rc<Module_defContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Module_defContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_module_def);
        let mut _localctx: Rc<Module_defContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(626);
			recog.attribute_instances()?;

			/*InvokeRule module_proto*/
			recog.base.set_state(627);
			recog.module_proto()?;

			recog.base.set_state(631);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__21) | (1usize << T__23) | (1usize << T__30) | (1usize << T__31) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__60) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule moduleStmt*/
				recog.base.set_state(628);
				recog.moduleStmt()?;

				}
				}
				recog.base.set_state(633);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(634);
			recog.base.match_token(T__22,&mut recog.err_handler)?;

			recog.base.set_state(637);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(635);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(636);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- module_proto ----------------
pub type Module_protoContextAll<'input> = Module_protoContext<'input>;


pub type Module_protoContext<'input> = BaseParserRuleContext<'input,Module_protoContextExt<'input>>;

#[derive(Clone)]
pub struct Module_protoContextExt<'input>{
	pub monad: Option<Rc<ExpressionContextAll<'input>>>,
	pub name: Option<Rc<IdentifierContextAll<'input>>>,
	pub moduleinterface: Option<Rc<Data_typeContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Module_protoContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Module_protoContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_module_proto(self);
	}
}

impl<'input> CustomRuleContext<'input> for Module_protoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_module_proto }
	//fn type_rule_index() -> usize where Self: Sized { RULE_module_proto }
}
antlr_rust::type_id!{Module_protoContextExt<'a>}

impl<'input> Module_protoContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Module_protoContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Module_protoContextExt{
				monad: None, name: None, moduleinterface: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait Module_protoContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Module_protoContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn provisos(&self) -> Option<Rc<ProvisosContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moduleprotoformals(&self) -> Option<Rc<ModuleprotoformalsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Module_protoContextAttrs<'input> for Module_protoContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn module_proto(&mut self,)
	-> Result<Rc<Module_protoContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Module_protoContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_module_proto);
        let mut _localctx: Rc<Module_protoContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(639);
			recog.base.match_token(T__23,&mut recog.err_handler)?;

			recog.base.set_state(644);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__14 {
				{
				recog.base.set_state(640);
				recog.base.match_token(T__14,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(641);
				let tmp = recog.expression_rec(0)?;
				 cast_mut::<_,Module_protoContext >(&mut _localctx).monad = Some(tmp.clone());
				  

				recog.base.set_state(642);
				recog.base.match_token(T__15,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule identifier*/
			recog.base.set_state(646);
			let tmp = recog.identifier()?;
			 cast_mut::<_,Module_protoContext >(&mut _localctx).name = Some(tmp.clone());
			  

			recog.base.set_state(653);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__12 {
				{
				recog.base.set_state(647);
				recog.base.match_token(T__12,&mut recog.err_handler)?;

				recog.base.set_state(648);
				recog.base.match_token(T__8,&mut recog.err_handler)?;

				recog.base.set_state(650);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__24) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
					{
					/*InvokeRule moduleprotoformals*/
					recog.base.set_state(649);
					recog.moduleprotoformals()?;

					}
				}

				recog.base.set_state(652);
				recog.base.match_token(T__10,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(655);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule data_type*/
			recog.base.set_state(656);
			let tmp = recog.data_type()?;
			 cast_mut::<_,Module_protoContext >(&mut _localctx).moduleinterface = Some(tmp.clone());
			  

			recog.base.set_state(657);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(659);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__103 {
				{
				/*InvokeRule provisos*/
				recog.base.set_state(658);
				recog.provisos()?;

				}
			}

			recog.base.set_state(661);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleprotoformals ----------------
pub type ModuleprotoformalsContextAll<'input> = ModuleprotoformalsContext<'input>;


pub type ModuleprotoformalsContext<'input> = BaseParserRuleContext<'input,ModuleprotoformalsContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleprotoformalsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ModuleprotoformalsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ModuleprotoformalsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_moduleprotoformals(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModuleprotoformalsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleprotoformals }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleprotoformals }
}
antlr_rust::type_id!{ModuleprotoformalsContextExt<'a>}

impl<'input> ModuleprotoformalsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleprotoformalsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleprotoformalsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleprotoformalsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ModuleprotoformalsContextExt<'input>>{

fn moduleprotoformal_all(&self) ->  Vec<Rc<ModuleprotoformalContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleprotoformal(&self, i: usize) -> Option<Rc<ModuleprotoformalContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ModuleprotoformalsContextAttrs<'input> for ModuleprotoformalsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleprotoformals(&mut self,)
	-> Result<Rc<ModuleprotoformalsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleprotoformalsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_moduleprotoformals);
        let mut _localctx: Rc<ModuleprotoformalsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule moduleprotoformal*/
			recog.base.set_state(663);
			recog.moduleprotoformal()?;

			recog.base.set_state(668);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(664);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule moduleprotoformal*/
				recog.base.set_state(665);
				recog.moduleprotoformal()?;

				}
				}
				recog.base.set_state(670);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleprotoformal ----------------
pub type ModuleprotoformalContextAll<'input> = ModuleprotoformalContext<'input>;


pub type ModuleprotoformalContext<'input> = BaseParserRuleContext<'input,ModuleprotoformalContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleprotoformalContextExt<'input>{
	pub name: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ModuleprotoformalContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ModuleprotoformalContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_moduleprotoformal(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModuleprotoformalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleprotoformal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleprotoformal }
}
antlr_rust::type_id!{ModuleprotoformalContextExt<'a>}

impl<'input> ModuleprotoformalContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleprotoformalContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleprotoformalContextExt{
				name: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleprotoformalContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ModuleprotoformalContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_proto(&self) -> Option<Rc<Function_protoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ModuleprotoformalContextAttrs<'input> for ModuleprotoformalContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleprotoformal(&mut self,)
	-> Result<Rc<ModuleprotoformalContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleprotoformalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_moduleprotoformal);
        let mut _localctx: Rc<ModuleprotoformalContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(679);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__13 | T__16 | T__24 | T__101 | UPPER_IDENTIFIER | LOWER_IDENTIFIER |
			 INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule attribute_instances*/
					recog.base.set_state(671);
					recog.attribute_instances()?;

					recog.base.set_state(673);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__24 {
						{
						recog.base.set_state(672);
						recog.base.match_token(T__24,&mut recog.err_handler)?;

						}
					}

					/*InvokeRule data_type*/
					recog.base.set_state(675);
					recog.data_type()?;

					/*InvokeRule identifier*/
					recog.base.set_state(676);
					let tmp = recog.identifier()?;
					 cast_mut::<_,ModuleprotoformalContext >(&mut _localctx).name = Some(tmp.clone());
					  

					}
				}

			 T__59 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule function_proto*/
					recog.base.set_state(678);
					recog.function_proto()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleFormalArgs ----------------
pub type ModuleFormalArgsContextAll<'input> = ModuleFormalArgsContext<'input>;


pub type ModuleFormalArgsContext<'input> = BaseParserRuleContext<'input,ModuleFormalArgsContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleFormalArgsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ModuleFormalArgsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ModuleFormalArgsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_moduleFormalArgs(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModuleFormalArgsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleFormalArgs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleFormalArgs }
}
antlr_rust::type_id!{ModuleFormalArgsContextExt<'a>}

impl<'input> ModuleFormalArgsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleFormalArgsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleFormalArgsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleFormalArgsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ModuleFormalArgsContextExt<'input>>{

fn attribute_instances_all(&self) ->  Vec<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn attribute_instances(&self, i: usize) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn data_type_all(&self) ->  Vec<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn data_type(&self, i: usize) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ModuleFormalArgsContextAttrs<'input> for ModuleFormalArgsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleFormalArgs(&mut self,)
	-> Result<Rc<ModuleFormalArgsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleFormalArgsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_moduleFormalArgs);
        let mut _localctx: Rc<ModuleFormalArgsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(702);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(43,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule attribute_instances*/
					recog.base.set_state(681);
					recog.attribute_instances()?;

					/*InvokeRule data_type*/
					recog.base.set_state(682);
					recog.data_type()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule attribute_instances*/
					recog.base.set_state(684);
					recog.attribute_instances()?;

					{
					/*InvokeRule data_type*/
					recog.base.set_state(685);
					recog.data_type()?;

					/*InvokeRule identifier*/
					recog.base.set_state(686);
					recog.identifier()?;

					recog.base.set_state(688);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__25 {
						{
						recog.base.set_state(687);
						recog.base.match_token(T__25,&mut recog.err_handler)?;

						}
					}

					}
					recog.base.set_state(699);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__5 {
						{
						{
						recog.base.set_state(690);
						recog.base.match_token(T__5,&mut recog.err_handler)?;

						/*InvokeRule attribute_instances*/
						recog.base.set_state(691);
						recog.attribute_instances()?;

						{
						/*InvokeRule data_type*/
						recog.base.set_state(692);
						recog.data_type()?;

						/*InvokeRule identifier*/
						recog.base.set_state(693);
						recog.identifier()?;

						recog.base.set_state(695);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==T__25 {
							{
							recog.base.set_state(694);
							recog.base.match_token(T__25,&mut recog.err_handler)?;

							}
						}

						}
						}
						}
						recog.base.set_state(701);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleStmt ----------------
pub type ModuleStmtContextAll<'input> = ModuleStmtContext<'input>;


pub type ModuleStmtContext<'input> = BaseParserRuleContext<'input,ModuleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ModuleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ModuleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModuleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleStmt }
}
antlr_rust::type_id!{ModuleStmtContextExt<'a>}

impl<'input> ModuleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ModuleStmtContextExt<'input>>{

fn method_def(&self) -> Option<Rc<Method_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subinterfaceDef(&self) -> Option<Rc<SubinterfaceDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ruleDef(&self) -> Option<Rc<RuleDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn varDo(&self) -> Option<Rc<VarDoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn varDeclDo(&self) -> Option<Rc<VarDeclDoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnStmt(&self) -> Option<Rc<ReturnStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_declaration(&self) -> Option<Rc<Variable_declarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_assignment(&self) -> Option<Rc<Variable_assignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_def(&self) -> Option<Rc<Function_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn module_def(&self) -> Option<Rc<Module_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn beginEndStmt_moduleStmt(&self) -> Option<Rc<BeginEndStmt_moduleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn if_moduleStmt(&self) -> Option<Rc<If_moduleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn case_moduleStmt(&self) -> Option<Rc<Case_moduleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn for_moduleStmt(&self) -> Option<Rc<For_moduleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn while_moduleStmt(&self) -> Option<Rc<While_moduleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ModuleStmtContextAttrs<'input> for ModuleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleStmt(&mut self,)
	-> Result<Rc<ModuleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_moduleStmt);
        let mut _localctx: Rc<ModuleStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(722);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(44,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule method_def*/
					recog.base.set_state(704);
					recog.method_def()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule subinterfaceDef*/
					recog.base.set_state(705);
					recog.subinterfaceDef()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule ruleDef*/
					recog.base.set_state(706);
					recog.ruleDef()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule varDo*/
					recog.base.set_state(707);
					recog.varDo()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule varDeclDo*/
					recog.base.set_state(708);
					recog.varDeclDo()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule expression*/
					recog.base.set_state(709);
					recog.expression_rec(0)?;

					recog.base.set_state(710);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule returnStmt*/
					recog.base.set_state(712);
					recog.returnStmt()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule variable_declaration*/
					recog.base.set_state(713);
					recog.variable_declaration()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule variable_assignment*/
					recog.base.set_state(714);
					recog.variable_assignment()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule function_def*/
					recog.base.set_state(715);
					recog.function_def()?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule module_def*/
					recog.base.set_state(716);
					recog.module_def()?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule beginEndStmt_moduleStmt*/
					recog.base.set_state(717);
					recog.beginEndStmt_moduleStmt()?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule if_moduleStmt*/
					recog.base.set_state(718);
					recog.if_moduleStmt()?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule case_moduleStmt*/
					recog.base.set_state(719);
					recog.case_moduleStmt()?;

					}
				}
			,
				15 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule for_moduleStmt*/
					recog.base.set_state(720);
					recog.for_moduleStmt()?;

					}
				}
			,
				16 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					/*InvokeRule while_moduleStmt*/
					recog.base.set_state(721);
					recog.while_moduleStmt()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- method_type ----------------
pub type Method_typeContextAll<'input> = Method_typeContext<'input>;


pub type Method_typeContext<'input> = BaseParserRuleContext<'input,Method_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Method_typeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Method_typeContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Method_typeContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_method_type(self);
	}
}

impl<'input> CustomRuleContext<'input> for Method_typeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_method_type }
	//fn type_rule_index() -> usize where Self: Sized { RULE_method_type }
}
antlr_rust::type_id!{Method_typeContextExt<'a>}

impl<'input> Method_typeContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Method_typeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Method_typeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Method_typeContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Method_typeContextExt<'input>>{

fn data_type_all(&self) ->  Vec<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn data_type(&self, i: usize) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Method_typeContextAttrs<'input> for Method_typeContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn method_type(&mut self,)
	-> Result<Rc<Method_typeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Method_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_method_type);
        let mut _localctx: Rc<Method_typeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(741);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__13 | T__16 | UPPER_IDENTIFIER | LOWER_IDENTIFIER | INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(725);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(45,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule data_type*/
							recog.base.set_state(724);
							recog.data_type()?;

							}
						}

						_ => {}
					}
					}
				}

			 T__26 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(727);
					recog.base.match_token(T__26,&mut recog.err_handler)?;

					}
				}

			 T__27 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(728);
					recog.base.match_token(T__27,&mut recog.err_handler)?;

					recog.base.set_state(729);
					recog.base.match_token(T__12,&mut recog.err_handler)?;

					recog.base.set_state(730);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule data_type*/
					recog.base.set_state(731);
					recog.data_type()?;

					recog.base.set_state(736);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__5 {
						{
						{
						recog.base.set_state(732);
						recog.base.match_token(T__5,&mut recog.err_handler)?;

						/*InvokeRule data_type*/
						recog.base.set_state(733);
						recog.data_type()?;

						}
						}
						recog.base.set_state(738);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(739);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- method_def ----------------
pub type Method_defContextAll<'input> = Method_defContext<'input>;


pub type Method_defContext<'input> = BaseParserRuleContext<'input,Method_defContextExt<'input>>;

#[derive(Clone)]
pub struct Method_defContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Method_defContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Method_defContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_method_def(self);
	}
}

impl<'input> CustomRuleContext<'input> for Method_defContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_method_def }
	//fn type_rule_index() -> usize where Self: Sized { RULE_method_def }
}
antlr_rust::type_id!{Method_defContextExt<'a>}

impl<'input> Method_defContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Method_defContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Method_defContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Method_defContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Method_defContextExt<'input>>{

fn method_type(&self) -> Option<Rc<Method_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn implicitCond(&self) -> Option<Rc<ImplicitCondContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionStmt_all(&self) ->  Vec<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionStmt(&self, i: usize) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn actionValueStmt_all(&self) ->  Vec<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionValueStmt(&self, i: usize) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn methodFormals(&self) -> Option<Rc<MethodFormalsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Method_defContextAttrs<'input> for Method_defContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn method_def(&mut self,)
	-> Result<Rc<Method_defContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Method_defContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_method_def);
        let mut _localctx: Rc<Method_defContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(794);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(58,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(743);
					recog.base.match_token(T__21,&mut recog.err_handler)?;

					/*InvokeRule method_type*/
					recog.base.set_state(744);
					recog.method_type()?;

					/*InvokeRule identifier*/
					recog.base.set_state(745);
					recog.identifier()?;

					recog.base.set_state(751);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(49,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(746);
							recog.base.match_token(T__8,&mut recog.err_handler)?;

							recog.base.set_state(748);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==T__13 || _la==T__16 || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
								{
								/*InvokeRule methodFormals*/
								recog.base.set_state(747);
								recog.methodFormals()?;

								}
							}

							recog.base.set_state(750);
							recog.base.match_token(T__10,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(754);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__8 || _la==T__30 {
						{
						/*InvokeRule implicitCond*/
						recog.base.set_state(753);
						recog.implicitCond()?;

						}
					}

					recog.base.set_state(756);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					recog.base.set_state(770);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(53,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule functionBody*/
							recog.base.set_state(757);
							recog.functionBody()?;

							}
						}
					,
						2 =>{
							{
							recog.base.set_state(761);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__94 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
								{
								{
								/*InvokeRule actionStmt*/
								recog.base.set_state(758);
								recog.actionStmt()?;

								}
								}
								recog.base.set_state(763);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							}
						}
					,
						3 =>{
							{
							recog.base.set_state(767);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__1) | (1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__60) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__96 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
								{
								{
								/*InvokeRule actionValueStmt*/
								recog.base.set_state(764);
								recog.actionValueStmt()?;

								}
								}
								recog.base.set_state(769);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(772);
					recog.base.match_token(T__28,&mut recog.err_handler)?;

					recog.base.set_state(775);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__3 {
						{
						recog.base.set_state(773);
						recog.base.match_token(T__3,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(774);
						recog.identifier()?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(777);
					recog.base.match_token(T__21,&mut recog.err_handler)?;

					/*InvokeRule method_type*/
					recog.base.set_state(778);
					recog.method_type()?;

					/*InvokeRule identifier*/
					recog.base.set_state(779);
					recog.identifier()?;

					recog.base.set_state(785);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(56,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(780);
							recog.base.match_token(T__8,&mut recog.err_handler)?;

							recog.base.set_state(782);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==T__13 || _la==T__16 || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
								{
								/*InvokeRule methodFormals*/
								recog.base.set_state(781);
								recog.methodFormals()?;

								}
							}

							recog.base.set_state(784);
							recog.base.match_token(T__10,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(788);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__8 || _la==T__30 {
						{
						/*InvokeRule implicitCond*/
						recog.base.set_state(787);
						recog.implicitCond()?;

						}
					}

					recog.base.set_state(790);
					recog.base.match_token(T__29,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(791);
					recog.expression_rec(0)?;

					recog.base.set_state(792);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- implicitCond ----------------
pub type ImplicitCondContextAll<'input> = ImplicitCondContext<'input>;


pub type ImplicitCondContext<'input> = BaseParserRuleContext<'input,ImplicitCondContextExt<'input>>;

#[derive(Clone)]
pub struct ImplicitCondContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ImplicitCondContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ImplicitCondContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_implicitCond(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImplicitCondContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_implicitCond }
	//fn type_rule_index() -> usize where Self: Sized { RULE_implicitCond }
}
antlr_rust::type_id!{ImplicitCondContextExt<'a>}

impl<'input> ImplicitCondContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImplicitCondContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImplicitCondContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImplicitCondContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ImplicitCondContextExt<'input>>{

fn cond_predicate(&self) -> Option<Rc<Cond_predicateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImplicitCondContextAttrs<'input> for ImplicitCondContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn implicitCond(&mut self,)
	-> Result<Rc<ImplicitCondContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImplicitCondContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_implicitCond);
        let mut _localctx: Rc<ImplicitCondContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(797);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__30 {
				{
				recog.base.set_state(796);
				recog.base.match_token(T__30,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(799);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule cond_predicate*/
			recog.base.set_state(800);
			recog.cond_predicate()?;

			recog.base.set_state(801);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodFormals ----------------
pub type MethodFormalsContextAll<'input> = MethodFormalsContext<'input>;


pub type MethodFormalsContext<'input> = BaseParserRuleContext<'input,MethodFormalsContextExt<'input>>;

#[derive(Clone)]
pub struct MethodFormalsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MethodFormalsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MethodFormalsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_methodFormals(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodFormalsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodFormals }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodFormals }
}
antlr_rust::type_id!{MethodFormalsContextExt<'a>}

impl<'input> MethodFormalsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodFormalsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodFormalsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodFormalsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MethodFormalsContextExt<'input>>{

fn methodFormal_all(&self) ->  Vec<Rc<MethodFormalContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn methodFormal(&self, i: usize) -> Option<Rc<MethodFormalContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodFormalsContextAttrs<'input> for MethodFormalsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodFormals(&mut self,)
	-> Result<Rc<MethodFormalsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodFormalsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_methodFormals);
        let mut _localctx: Rc<MethodFormalsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule methodFormal*/
			recog.base.set_state(803);
			recog.methodFormal()?;

			recog.base.set_state(808);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(804);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule methodFormal*/
				recog.base.set_state(805);
				recog.methodFormal()?;

				}
				}
				recog.base.set_state(810);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodFormal ----------------
pub type MethodFormalContextAll<'input> = MethodFormalContext<'input>;


pub type MethodFormalContext<'input> = BaseParserRuleContext<'input,MethodFormalContextExt<'input>>;

#[derive(Clone)]
pub struct MethodFormalContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MethodFormalContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MethodFormalContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_methodFormal(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodFormalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodFormal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodFormal }
}
antlr_rust::type_id!{MethodFormalContextExt<'a>}

impl<'input> MethodFormalContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodFormalContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodFormalContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodFormalContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MethodFormalContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodFormalContextAttrs<'input> for MethodFormalContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodFormal(&mut self,)
	-> Result<Rc<MethodFormalContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodFormalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_methodFormal);
        let mut _localctx: Rc<MethodFormalContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(812);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(61,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule data_type*/
					recog.base.set_state(811);
					recog.data_type()?;

					}
				}

				_ => {}
			}
			/*InvokeRule identifier*/
			recog.base.set_state(814);
			recog.identifier()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subinterfaceDef ----------------
pub type SubinterfaceDefContextAll<'input> = SubinterfaceDefContext<'input>;


pub type SubinterfaceDefContext<'input> = BaseParserRuleContext<'input,SubinterfaceDefContextExt<'input>>;

#[derive(Clone)]
pub struct SubinterfaceDefContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for SubinterfaceDefContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for SubinterfaceDefContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_subinterfaceDef(self);
	}
}

impl<'input> CustomRuleContext<'input> for SubinterfaceDefContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subinterfaceDef }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subinterfaceDef }
}
antlr_rust::type_id!{SubinterfaceDefContextExt<'a>}

impl<'input> SubinterfaceDefContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubinterfaceDefContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubinterfaceDefContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubinterfaceDefContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<SubinterfaceDefContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn interfaceStmt_all(&self) ->  Vec<Rc<InterfaceStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceStmt(&self, i: usize) -> Option<Rc<InterfaceStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubinterfaceDefContextAttrs<'input> for SubinterfaceDefContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subinterfaceDef(&mut self,)
	-> Result<Rc<SubinterfaceDefContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubinterfaceDefContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_subinterfaceDef);
        let mut _localctx: Rc<SubinterfaceDefContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(840);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(65,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(816);
					recog.base.match_token(T__17,&mut recog.err_handler)?;

					recog.base.set_state(817);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(818);
					recog.identifier()?;

					recog.base.set_state(819);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					recog.base.set_state(823);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__21) | (1usize << T__30) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
						{
						{
						/*InvokeRule interfaceStmt*/
						recog.base.set_state(820);
						recog.interfaceStmt()?;

						}
						}
						recog.base.set_state(825);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(826);
					recog.base.match_token(T__18,&mut recog.err_handler)?;

					recog.base.set_state(829);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__3 {
						{
						recog.base.set_state(827);
						recog.base.match_token(T__3,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(828);
						recog.identifier()?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(831);
					recog.base.match_token(T__17,&mut recog.err_handler)?;

					recog.base.set_state(833);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(64,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule data_type*/
							recog.base.set_state(832);
							recog.data_type()?;

							}
						}

						_ => {}
					}
					/*InvokeRule identifier*/
					recog.base.set_state(835);
					recog.identifier()?;

					recog.base.set_state(836);
					recog.base.match_token(T__29,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(837);
					recog.expression_rec(0)?;

					recog.base.set_state(838);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceStmt ----------------
pub type InterfaceStmtContextAll<'input> = InterfaceStmtContext<'input>;


pub type InterfaceStmtContext<'input> = BaseParserRuleContext<'input,InterfaceStmtContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InterfaceStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InterfaceStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_interfaceStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceStmt }
}
antlr_rust::type_id!{InterfaceStmtContextExt<'a>}

impl<'input> InterfaceStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InterfaceStmtContextExt<'input>>{

fn method_def(&self) -> Option<Rc<Method_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subinterfaceDef(&self) -> Option<Rc<SubinterfaceDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceStmtContextAttrs<'input> for InterfaceStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceStmt(&mut self,)
	-> Result<Rc<InterfaceStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_interfaceStmt);
        let mut _localctx: Rc<InterfaceStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(845);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__21 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule method_def*/
					recog.base.set_state(842);
					recog.method_def()?;

					}
				}

			 T__17 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule subinterfaceDef*/
					recog.base.set_state(843);
					recog.subinterfaceDef()?;

					}
				}

			 T__13 | T__16 | T__30 | T__41 | T__42 | T__49 | T__52 | T__56 | T__57 |
			 T__59 | T__101 | UPPER_IDENTIFIER | LOWER_IDENTIFIER | INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule expressionStmt*/
					recog.base.set_state(844);
					recog.expressionStmt()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expressionStmt ----------------
pub type ExpressionStmtContextAll<'input> = ExpressionStmtContext<'input>;


pub type ExpressionStmtContext<'input> = BaseParserRuleContext<'input,ExpressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ExpressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExpressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expressionStmt }
}
antlr_rust::type_id!{ExpressionStmtContextExt<'a>}

impl<'input> ExpressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ExpressionStmtContextExt<'input>>{

fn variable_declaration(&self) -> Option<Rc<Variable_declarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_assignment(&self) -> Option<Rc<Variable_assignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_def(&self) -> Option<Rc<Function_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn beginEndStmt_expressionStmt(&self) -> Option<Rc<BeginEndStmt_expressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn if_expressionStmt(&self) -> Option<Rc<If_expressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn case_expressionStmt(&self) -> Option<Rc<Case_expressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn for_expressionStmt(&self) -> Option<Rc<For_expressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn while_expressionStmt(&self) -> Option<Rc<While_expressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionStmtContextAttrs<'input> for ExpressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expressionStmt(&mut self,)
	-> Result<Rc<ExpressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_expressionStmt);
        let mut _localctx: Rc<ExpressionStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(855);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(67,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule variable_declaration*/
					recog.base.set_state(847);
					recog.variable_declaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule variable_assignment*/
					recog.base.set_state(848);
					recog.variable_assignment()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule function_def*/
					recog.base.set_state(849);
					recog.function_def()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule beginEndStmt_expressionStmt*/
					recog.base.set_state(850);
					recog.beginEndStmt_expressionStmt()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule if_expressionStmt*/
					recog.base.set_state(851);
					recog.if_expressionStmt()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule case_expressionStmt*/
					recog.base.set_state(852);
					recog.case_expressionStmt()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule for_expressionStmt*/
					recog.base.set_state(853);
					recog.for_expressionStmt()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule while_expressionStmt*/
					recog.base.set_state(854);
					recog.while_expressionStmt()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ruleDef ----------------
pub type RuleDefContextAll<'input> = RuleDefContext<'input>;


pub type RuleDefContext<'input> = BaseParserRuleContext<'input,RuleDefContextExt<'input>>;

#[derive(Clone)]
pub struct RuleDefContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for RuleDefContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for RuleDefContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ruleDef(self);
	}
}

impl<'input> CustomRuleContext<'input> for RuleDefContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ruleDef }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ruleDef }
}
antlr_rust::type_id!{RuleDefContextExt<'a>}

impl<'input> RuleDefContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RuleDefContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RuleDefContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RuleDefContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<RuleDefContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn ruleBody(&self) -> Option<Rc<RuleBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ruleCond(&self) -> Option<Rc<RuleCondContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RuleDefContextAttrs<'input> for RuleDefContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ruleDef(&mut self,)
	-> Result<Rc<RuleDefContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RuleDefContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_ruleDef);
        let mut _localctx: Rc<RuleDefContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(857);
			recog.attribute_instances()?;

			recog.base.set_state(858);
			recog.base.match_token(T__31,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(859);
			recog.identifier()?;

			recog.base.set_state(861);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__8 || _la==T__30 {
				{
				/*InvokeRule ruleCond*/
				recog.base.set_state(860);
				recog.ruleCond()?;

				}
			}

			recog.base.set_state(863);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule ruleBody*/
			recog.base.set_state(864);
			recog.ruleBody()?;

			recog.base.set_state(865);
			recog.base.match_token(T__32,&mut recog.err_handler)?;

			recog.base.set_state(868);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(866);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(867);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ruleCond ----------------
pub type RuleCondContextAll<'input> = RuleCondContext<'input>;


pub type RuleCondContext<'input> = BaseParserRuleContext<'input,RuleCondContextExt<'input>>;

#[derive(Clone)]
pub struct RuleCondContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for RuleCondContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for RuleCondContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ruleCond(self);
	}
}

impl<'input> CustomRuleContext<'input> for RuleCondContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ruleCond }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ruleCond }
}
antlr_rust::type_id!{RuleCondContextExt<'a>}

impl<'input> RuleCondContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RuleCondContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RuleCondContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RuleCondContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<RuleCondContextExt<'input>>{

fn cond_predicate(&self) -> Option<Rc<Cond_predicateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RuleCondContextAttrs<'input> for RuleCondContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ruleCond(&mut self,)
	-> Result<Rc<RuleCondContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RuleCondContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_ruleCond);
        let mut _localctx: Rc<RuleCondContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(871);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__30 {
				{
				recog.base.set_state(870);
				recog.base.match_token(T__30,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(873);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule cond_predicate*/
			recog.base.set_state(874);
			recog.cond_predicate()?;

			recog.base.set_state(875);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ruleBody ----------------
pub type RuleBodyContextAll<'input> = RuleBodyContext<'input>;


pub type RuleBodyContext<'input> = BaseParserRuleContext<'input,RuleBodyContextExt<'input>>;

#[derive(Clone)]
pub struct RuleBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for RuleBodyContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for RuleBodyContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ruleBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for RuleBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ruleBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ruleBody }
}
antlr_rust::type_id!{RuleBodyContextExt<'a>}

impl<'input> RuleBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RuleBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RuleBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RuleBodyContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<RuleBodyContextExt<'input>>{

fn actionStmt_all(&self) ->  Vec<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionStmt(&self, i: usize) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> RuleBodyContextAttrs<'input> for RuleBodyContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ruleBody(&mut self,)
	-> Result<Rc<RuleBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RuleBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_ruleBody);
        let mut _localctx: Rc<RuleBodyContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(880);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__94 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule actionStmt*/
				recog.base.set_state(877);
				recog.actionStmt()?;

				}
				}
				recog.base.set_state(882);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeDef ----------------
pub type TypeDefContextAll<'input> = TypeDefContext<'input>;


pub type TypeDefContext<'input> = BaseParserRuleContext<'input,TypeDefContextExt<'input>>;

#[derive(Clone)]
pub struct TypeDefContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypeDefContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeDefContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeDef(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeDefContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeDef }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeDef }
}
antlr_rust::type_id!{TypeDefContextExt<'a>}

impl<'input> TypeDefContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeDefContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeDefContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeDefContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypeDefContextExt<'input>>{

fn typedefSynonym(&self) -> Option<Rc<TypedefSynonymContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typedefEnum(&self) -> Option<Rc<TypedefEnumContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typedefStruct(&self) -> Option<Rc<TypedefStructContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typedefTaggedUnion(&self) -> Option<Rc<TypedefTaggedUnionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeDefContextAttrs<'input> for TypeDefContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeDef(&mut self,)
	-> Result<Rc<TypeDefContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeDefContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_typeDef);
        let mut _localctx: Rc<TypeDefContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(887);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(72,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule typedefSynonym*/
					recog.base.set_state(883);
					recog.typedefSynonym()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typedefEnum*/
					recog.base.set_state(884);
					recog.typedefEnum()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typedefStruct*/
					recog.base.set_state(885);
					recog.typedefStruct()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule typedefTaggedUnion*/
					recog.base.set_state(886);
					recog.typedefTaggedUnion()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedefSynonym ----------------
pub type TypedefSynonymContextAll<'input> = TypedefSynonymContext<'input>;


pub type TypedefSynonymContext<'input> = BaseParserRuleContext<'input,TypedefSynonymContextExt<'input>>;

#[derive(Clone)]
pub struct TypedefSynonymContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypedefSynonymContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypedefSynonymContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typedefSynonym(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypedefSynonymContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedefSynonym }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedefSynonym }
}
antlr_rust::type_id!{TypedefSynonymContextExt<'a>}

impl<'input> TypedefSynonymContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedefSynonymContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedefSynonymContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedefSynonymContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypedefSynonymContextExt<'input>>{

fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeDefType(&self) -> Option<Rc<TypeDefTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypedefSynonymContextAttrs<'input> for TypedefSynonymContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedefSynonym(&mut self,)
	-> Result<Rc<TypedefSynonymContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedefSynonymContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_typedefSynonym);
        let mut _localctx: Rc<TypedefSynonymContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(889);
			recog.base.match_token(T__33,&mut recog.err_handler)?;

			/*InvokeRule data_type*/
			recog.base.set_state(890);
			recog.data_type()?;

			/*InvokeRule typeDefType*/
			recog.base.set_state(891);
			recog.typeDefType()?;

			recog.base.set_state(892);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedefEnum ----------------
pub type TypedefEnumContextAll<'input> = TypedefEnumContext<'input>;


pub type TypedefEnumContext<'input> = BaseParserRuleContext<'input,TypedefEnumContextExt<'input>>;

#[derive(Clone)]
pub struct TypedefEnumContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypedefEnumContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypedefEnumContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typedefEnum(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypedefEnumContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedefEnum }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedefEnum }
}
antlr_rust::type_id!{TypedefEnumContextExt<'a>}

impl<'input> TypedefEnumContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedefEnumContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedefEnumContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedefEnumContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypedefEnumContextExt<'input>>{

fn typedefEnumElements(&self) -> Option<Rc<TypedefEnumElementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
fn derives(&self) -> Option<Rc<DerivesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypedefEnumContextAttrs<'input> for TypedefEnumContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedefEnum(&mut self,)
	-> Result<Rc<TypedefEnumContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedefEnumContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_typedefEnum);
        let mut _localctx: Rc<TypedefEnumContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(894);
			recog.base.match_token(T__33,&mut recog.err_handler)?;

			recog.base.set_state(895);
			recog.base.match_token(T__34,&mut recog.err_handler)?;

			recog.base.set_state(896);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			/*InvokeRule typedefEnumElements*/
			recog.base.set_state(897);
			recog.typedefEnumElements()?;

			recog.base.set_state(898);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			recog.base.set_state(899);
			recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

			recog.base.set_state(901);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__110 {
				{
				/*InvokeRule derives*/
				recog.base.set_state(900);
				recog.derives()?;

				}
			}

			recog.base.set_state(903);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedefEnumElements ----------------
pub type TypedefEnumElementsContextAll<'input> = TypedefEnumElementsContext<'input>;


pub type TypedefEnumElementsContext<'input> = BaseParserRuleContext<'input,TypedefEnumElementsContextExt<'input>>;

#[derive(Clone)]
pub struct TypedefEnumElementsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypedefEnumElementsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypedefEnumElementsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typedefEnumElements(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypedefEnumElementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedefEnumElements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedefEnumElements }
}
antlr_rust::type_id!{TypedefEnumElementsContextExt<'a>}

impl<'input> TypedefEnumElementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedefEnumElementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedefEnumElementsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedefEnumElementsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypedefEnumElementsContextExt<'input>>{

fn typedefEnumElement_all(&self) ->  Vec<Rc<TypedefEnumElementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typedefEnumElement(&self, i: usize) -> Option<Rc<TypedefEnumElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypedefEnumElementsContextAttrs<'input> for TypedefEnumElementsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedefEnumElements(&mut self,)
	-> Result<Rc<TypedefEnumElementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedefEnumElementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_typedefEnumElements);
        let mut _localctx: Rc<TypedefEnumElementsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typedefEnumElement*/
			recog.base.set_state(905);
			recog.typedefEnumElement()?;

			recog.base.set_state(910);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(906);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule typedefEnumElement*/
				recog.base.set_state(907);
				recog.typedefEnumElement()?;

				}
				}
				recog.base.set_state(912);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedefEnumElement ----------------
pub type TypedefEnumElementContextAll<'input> = TypedefEnumElementContext<'input>;


pub type TypedefEnumElementContext<'input> = BaseParserRuleContext<'input,TypedefEnumElementContextExt<'input>>;

#[derive(Clone)]
pub struct TypedefEnumElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypedefEnumElementContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypedefEnumElementContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typedefEnumElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypedefEnumElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedefEnumElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedefEnumElement }
}
antlr_rust::type_id!{TypedefEnumElementContextExt<'a>}

impl<'input> TypedefEnumElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedefEnumElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedefEnumElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedefEnumElementContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypedefEnumElementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token INT_LITERAL in current rule
fn INT_LITERAL_all(&self) -> Vec<Rc<TerminalNode<'input,BSVParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token INT_LITERAL, starting from 0.
/// Returns `None` if number of children corresponding to token INT_LITERAL is less or equal than `i`.
fn INT_LITERAL(&self, i: usize) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(INT_LITERAL, i)
}

}

impl<'input> TypedefEnumElementContextAttrs<'input> for TypedefEnumElementContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedefEnumElement(&mut self,)
	-> Result<Rc<TypedefEnumElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedefEnumElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_typedefEnumElement);
        let mut _localctx: Rc<TypedefEnumElementContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(936);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(78,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(913);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					recog.base.set_state(916);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__29 {
						{
						recog.base.set_state(914);
						recog.base.match_token(T__29,&mut recog.err_handler)?;

						recog.base.set_state(915);
						recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(918);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					recog.base.set_state(919);
					recog.base.match_token(T__14,&mut recog.err_handler)?;

					recog.base.set_state(920);
					recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;

					recog.base.set_state(921);
					recog.base.match_token(T__15,&mut recog.err_handler)?;

					recog.base.set_state(924);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__29 {
						{
						recog.base.set_state(922);
						recog.base.match_token(T__29,&mut recog.err_handler)?;

						recog.base.set_state(923);
						recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;

						}
					}

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(926);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					recog.base.set_state(927);
					recog.base.match_token(T__14,&mut recog.err_handler)?;

					recog.base.set_state(928);
					recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;

					recog.base.set_state(929);
					recog.base.match_token(T__3,&mut recog.err_handler)?;

					recog.base.set_state(930);
					recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;

					recog.base.set_state(931);
					recog.base.match_token(T__15,&mut recog.err_handler)?;

					recog.base.set_state(934);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__29 {
						{
						recog.base.set_state(932);
						recog.base.match_token(T__29,&mut recog.err_handler)?;

						recog.base.set_state(933);
						recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;

						}
					}

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedefStruct ----------------
pub type TypedefStructContextAll<'input> = TypedefStructContext<'input>;


pub type TypedefStructContext<'input> = BaseParserRuleContext<'input,TypedefStructContextExt<'input>>;

#[derive(Clone)]
pub struct TypedefStructContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypedefStructContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypedefStructContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typedefStruct(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypedefStructContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedefStruct }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedefStruct }
}
antlr_rust::type_id!{TypedefStructContextExt<'a>}

impl<'input> TypedefStructContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedefStructContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedefStructContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedefStructContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypedefStructContextExt<'input>>{

fn typeDefType(&self) -> Option<Rc<TypeDefTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn structMember_all(&self) ->  Vec<Rc<StructMemberContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn structMember(&self, i: usize) -> Option<Rc<StructMemberContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn derives(&self) -> Option<Rc<DerivesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypedefStructContextAttrs<'input> for TypedefStructContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedefStruct(&mut self,)
	-> Result<Rc<TypedefStructContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedefStructContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_typedefStruct);
        let mut _localctx: Rc<TypedefStructContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(938);
			recog.base.match_token(T__33,&mut recog.err_handler)?;

			recog.base.set_state(939);
			recog.base.match_token(T__37,&mut recog.err_handler)?;

			recog.base.set_state(940);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			recog.base.set_state(944);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__38))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule structMember*/
				recog.base.set_state(941);
				recog.structMember()?;

				}
				}
				recog.base.set_state(946);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(947);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			/*InvokeRule typeDefType*/
			recog.base.set_state(948);
			recog.typeDefType()?;

			recog.base.set_state(950);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__110 {
				{
				/*InvokeRule derives*/
				recog.base.set_state(949);
				recog.derives()?;

				}
			}

			recog.base.set_state(952);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedefTaggedUnion ----------------
pub type TypedefTaggedUnionContextAll<'input> = TypedefTaggedUnionContext<'input>;


pub type TypedefTaggedUnionContext<'input> = BaseParserRuleContext<'input,TypedefTaggedUnionContextExt<'input>>;

#[derive(Clone)]
pub struct TypedefTaggedUnionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypedefTaggedUnionContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypedefTaggedUnionContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typedefTaggedUnion(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypedefTaggedUnionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedefTaggedUnion }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedefTaggedUnion }
}
antlr_rust::type_id!{TypedefTaggedUnionContextExt<'a>}

impl<'input> TypedefTaggedUnionContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedefTaggedUnionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedefTaggedUnionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedefTaggedUnionContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypedefTaggedUnionContextExt<'input>>{

fn typeDefType(&self) -> Option<Rc<TypeDefTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unionMember_all(&self) ->  Vec<Rc<UnionMemberContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unionMember(&self, i: usize) -> Option<Rc<UnionMemberContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn derives(&self) -> Option<Rc<DerivesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypedefTaggedUnionContextAttrs<'input> for TypedefTaggedUnionContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedefTaggedUnion(&mut self,)
	-> Result<Rc<TypedefTaggedUnionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedefTaggedUnionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_typedefTaggedUnion);
        let mut _localctx: Rc<TypedefTaggedUnionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(954);
			recog.base.match_token(T__33,&mut recog.err_handler)?;

			recog.base.set_state(955);
			recog.base.match_token(T__38,&mut recog.err_handler)?;

			recog.base.set_state(956);
			recog.base.match_token(T__39,&mut recog.err_handler)?;

			recog.base.set_state(957);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			recog.base.set_state(961);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__37) | (1usize << T__38) | (1usize << T__40))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule unionMember*/
				recog.base.set_state(958);
				recog.unionMember()?;

				}
				}
				recog.base.set_state(963);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(964);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			/*InvokeRule typeDefType*/
			recog.base.set_state(965);
			recog.typeDefType()?;

			recog.base.set_state(967);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__110 {
				{
				/*InvokeRule derives*/
				recog.base.set_state(966);
				recog.derives()?;

				}
			}

			recog.base.set_state(969);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- structMember ----------------
pub type StructMemberContextAll<'input> = StructMemberContext<'input>;


pub type StructMemberContext<'input> = BaseParserRuleContext<'input,StructMemberContextExt<'input>>;

#[derive(Clone)]
pub struct StructMemberContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for StructMemberContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for StructMemberContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_structMember(self);
	}
}

impl<'input> CustomRuleContext<'input> for StructMemberContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_structMember }
	//fn type_rule_index() -> usize where Self: Sized { RULE_structMember }
}
antlr_rust::type_id!{StructMemberContextExt<'a>}

impl<'input> StructMemberContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StructMemberContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StructMemberContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StructMemberContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<StructMemberContextExt<'input>>{

fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subUnion(&self) -> Option<Rc<SubUnionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StructMemberContextAttrs<'input> for StructMemberContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn structMember(&mut self,)
	-> Result<Rc<StructMemberContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StructMemberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_structMember);
        let mut _localctx: Rc<StructMemberContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(979);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__13 | T__16 | UPPER_IDENTIFIER | LOWER_IDENTIFIER | INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule data_type*/
					recog.base.set_state(971);
					recog.data_type()?;

					/*InvokeRule identifier*/
					recog.base.set_state(972);
					recog.identifier()?;

					recog.base.set_state(973);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

			 T__38 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule subUnion*/
					recog.base.set_state(975);
					recog.subUnion()?;

					/*InvokeRule identifier*/
					recog.base.set_state(976);
					recog.identifier()?;

					recog.base.set_state(977);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unionMember ----------------
pub type UnionMemberContextAll<'input> = UnionMemberContext<'input>;


pub type UnionMemberContext<'input> = BaseParserRuleContext<'input,UnionMemberContextExt<'input>>;

#[derive(Clone)]
pub struct UnionMemberContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for UnionMemberContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for UnionMemberContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unionMember(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnionMemberContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unionMember }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unionMember }
}
antlr_rust::type_id!{UnionMemberContextExt<'a>}

impl<'input> UnionMemberContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnionMemberContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnionMemberContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnionMemberContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<UnionMemberContextExt<'input>>{

fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
fn subStruct(&self) -> Option<Rc<SubStructContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subUnion(&self) -> Option<Rc<SubUnionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnionMemberContextAttrs<'input> for UnionMemberContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unionMember(&mut self,)
	-> Result<Rc<UnionMemberContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnionMemberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_unionMember);
        let mut _localctx: Rc<UnionMemberContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(996);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__13 | T__16 | UPPER_IDENTIFIER | LOWER_IDENTIFIER | INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule data_type*/
					recog.base.set_state(981);
					recog.data_type()?;

					recog.base.set_state(982);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					recog.base.set_state(983);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

			 T__37 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule subStruct*/
					recog.base.set_state(985);
					recog.subStruct()?;

					recog.base.set_state(986);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					recog.base.set_state(987);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

			 T__38 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule subUnion*/
					recog.base.set_state(989);
					recog.subUnion()?;

					recog.base.set_state(990);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					recog.base.set_state(991);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

			 T__40 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(993);
					recog.base.match_token(T__40,&mut recog.err_handler)?;

					recog.base.set_state(994);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					recog.base.set_state(995);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subStruct ----------------
pub type SubStructContextAll<'input> = SubStructContext<'input>;


pub type SubStructContext<'input> = BaseParserRuleContext<'input,SubStructContextExt<'input>>;

#[derive(Clone)]
pub struct SubStructContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for SubStructContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for SubStructContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_subStruct(self);
	}
}

impl<'input> CustomRuleContext<'input> for SubStructContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subStruct }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subStruct }
}
antlr_rust::type_id!{SubStructContextExt<'a>}

impl<'input> SubStructContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubStructContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubStructContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubStructContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<SubStructContextExt<'input>>{

fn structMember_all(&self) ->  Vec<Rc<StructMemberContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn structMember(&self, i: usize) -> Option<Rc<StructMemberContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SubStructContextAttrs<'input> for SubStructContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subStruct(&mut self,)
	-> Result<Rc<SubStructContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubStructContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_subStruct);
        let mut _localctx: Rc<SubStructContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(998);
			recog.base.match_token(T__37,&mut recog.err_handler)?;

			recog.base.set_state(999);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			recog.base.set_state(1003);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__38))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule structMember*/
				recog.base.set_state(1000);
				recog.structMember()?;

				}
				}
				recog.base.set_state(1005);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1006);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subUnion ----------------
pub type SubUnionContextAll<'input> = SubUnionContext<'input>;


pub type SubUnionContext<'input> = BaseParserRuleContext<'input,SubUnionContextExt<'input>>;

#[derive(Clone)]
pub struct SubUnionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for SubUnionContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for SubUnionContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_subUnion(self);
	}
}

impl<'input> CustomRuleContext<'input> for SubUnionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subUnion }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subUnion }
}
antlr_rust::type_id!{SubUnionContextExt<'a>}

impl<'input> SubUnionContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubUnionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubUnionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubUnionContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<SubUnionContextExt<'input>>{

fn unionMember_all(&self) ->  Vec<Rc<UnionMemberContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unionMember(&self, i: usize) -> Option<Rc<UnionMemberContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SubUnionContextAttrs<'input> for SubUnionContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subUnion(&mut self,)
	-> Result<Rc<SubUnionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubUnionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_subUnion);
        let mut _localctx: Rc<SubUnionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1008);
			recog.base.match_token(T__38,&mut recog.err_handler)?;

			recog.base.set_state(1009);
			recog.base.match_token(T__39,&mut recog.err_handler)?;

			recog.base.set_state(1010);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			recog.base.set_state(1014);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__37) | (1usize << T__38) | (1usize << T__40))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule unionMember*/
				recog.base.set_state(1011);
				recog.unionMember()?;

				}
				}
				recog.base.set_state(1016);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1017);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variable_declaration ----------------
pub type Variable_declarationContextAll<'input> = Variable_declarationContext<'input>;


pub type Variable_declarationContext<'input> = BaseParserRuleContext<'input,Variable_declarationContextExt<'input>>;

#[derive(Clone)]
pub struct Variable_declarationContextExt<'input>{
	pub t: Option<Rc<Data_typeContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Variable_declarationContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Variable_declarationContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_variable_declaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for Variable_declarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variable_declaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variable_declaration }
}
antlr_rust::type_id!{Variable_declarationContextExt<'a>}

impl<'input> Variable_declarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Variable_declarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Variable_declarationContextExt{
				t: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait Variable_declarationContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Variable_declarationContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_initialization_all(&self) ->  Vec<Rc<Variable_initializationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variable_initialization(&self, i: usize) -> Option<Rc<Variable_initializationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Variable_declarationContextAttrs<'input> for Variable_declarationContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variable_declaration(&mut self,)
	-> Result<Rc<Variable_declarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Variable_declarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_variable_declaration);
        let mut _localctx: Rc<Variable_declarationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1035);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__13 | T__16 | T__41 | T__101 | UPPER_IDENTIFIER | LOWER_IDENTIFIER |
			 INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule attribute_instances*/
					recog.base.set_state(1019);
					recog.attribute_instances()?;

					recog.base.set_state(1022);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 T__41 
						=> {
							{
							recog.base.set_state(1020);
							recog.base.match_token(T__41,&mut recog.err_handler)?;

							}
						}

					 T__13 | T__16 | UPPER_IDENTIFIER | LOWER_IDENTIFIER | INT_LITERAL 
						=> {
							{
							/*InvokeRule data_type*/
							recog.base.set_state(1021);
							let tmp = recog.data_type()?;
							 cast_mut::<_,Variable_declarationContext >(&mut _localctx).t = Some(tmp.clone());
							  

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					{
					{
					/*InvokeRule variable_initialization*/
					recog.base.set_state(1024);
					recog.variable_initialization()?;

					recog.base.set_state(1029);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__5 {
						{
						{
						recog.base.set_state(1025);
						recog.base.match_token(T__5,&mut recog.err_handler)?;

						/*InvokeRule variable_initialization*/
						recog.base.set_state(1026);
						recog.variable_initialization()?;

						}
						}
						recog.base.set_state(1031);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
					}
					recog.base.set_state(1032);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

			 T__42 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1034);
					recog.base.match_token(T__42,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- patternbinding ----------------
pub type PatternbindingContextAll<'input> = PatternbindingContext<'input>;


pub type PatternbindingContext<'input> = BaseParserRuleContext<'input,PatternbindingContextExt<'input>>;

#[derive(Clone)]
pub struct PatternbindingContextExt<'input>{
	pub op: Option<TokenType<'input>>,
	pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
	pub action: Option<Rc<ExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for PatternbindingContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for PatternbindingContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_patternbinding(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternbindingContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternbinding }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternbinding }
}
antlr_rust::type_id!{PatternbindingContextExt<'a>}

impl<'input> PatternbindingContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PatternbindingContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PatternbindingContextExt{
				op: None, 
				rhs: None, action: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait PatternbindingContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<PatternbindingContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PatternbindingContextAttrs<'input> for PatternbindingContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn patternbinding(&mut self,)
	-> Result<Rc<PatternbindingContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PatternbindingContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_patternbinding);
        let mut _localctx: Rc<PatternbindingContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1051);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(90,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule attribute_instances*/
					recog.base.set_state(1037);
					recog.attribute_instances()?;

					recog.base.set_state(1038);
					recog.base.match_token(T__43,&mut recog.err_handler)?;

					/*InvokeRule pattern*/
					recog.base.set_state(1039);
					recog.pattern()?;

					recog.base.set_state(1040);
					let tmp = recog.base.match_token(T__29,&mut recog.err_handler)?;
					 cast_mut::<_,PatternbindingContext >(&mut _localctx).op = Some(tmp.clone());
					  

					/*InvokeRule expression*/
					recog.base.set_state(1041);
					let tmp = recog.expression_rec(0)?;
					 cast_mut::<_,PatternbindingContext >(&mut _localctx).rhs = Some(tmp.clone());
					  

					recog.base.set_state(1042);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule attribute_instances*/
					recog.base.set_state(1044);
					recog.attribute_instances()?;

					recog.base.set_state(1045);
					recog.base.match_token(T__43,&mut recog.err_handler)?;

					/*InvokeRule pattern*/
					recog.base.set_state(1046);
					recog.pattern()?;

					recog.base.set_state(1047);
					let tmp = recog.base.match_token(T__44,&mut recog.err_handler)?;
					 cast_mut::<_,PatternbindingContext >(&mut _localctx).op = Some(tmp.clone());
					  

					/*InvokeRule expression*/
					recog.base.set_state(1048);
					let tmp = recog.expression_rec(0)?;
					 cast_mut::<_,PatternbindingContext >(&mut _localctx).action = Some(tmp.clone());
					  

					recog.base.set_state(1049);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variable_initialization ----------------
pub type Variable_initializationContextAll<'input> = Variable_initializationContext<'input>;


pub type Variable_initializationContext<'input> = BaseParserRuleContext<'input,Variable_initializationContextExt<'input>>;

#[derive(Clone)]
pub struct Variable_initializationContextExt<'input>{
	pub var: Option<Rc<IdentifierContextAll<'input>>>,
	pub op: Option<TokenType<'input>>,
	pub action: Option<Rc<ExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Variable_initializationContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Variable_initializationContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_variable_initialization(self);
	}
}

impl<'input> CustomRuleContext<'input> for Variable_initializationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variable_initialization }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variable_initialization }
}
antlr_rust::type_id!{Variable_initializationContextExt<'a>}

impl<'input> Variable_initializationContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Variable_initializationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Variable_initializationContextExt{
				op: None, 
				var: None, action: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait Variable_initializationContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Variable_initializationContextExt<'input>>{

fn variable_assignment(&self) -> Option<Rc<Variable_assignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Variable_initializationContextAttrs<'input> for Variable_initializationContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variable_initialization(&mut self,)
	-> Result<Rc<Variable_initializationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Variable_initializationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_variable_initialization);
        let mut _localctx: Rc<Variable_initializationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1058);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(91,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule variable_assignment*/
					recog.base.set_state(1053);
					recog.variable_assignment()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(1054);
					let tmp = recog.identifier()?;
					 cast_mut::<_,Variable_initializationContext >(&mut _localctx).var = Some(tmp.clone());
					  

					recog.base.set_state(1055);
					let tmp = recog.base.match_token(T__44,&mut recog.err_handler)?;
					 cast_mut::<_,Variable_initializationContext >(&mut _localctx).op = Some(tmp.clone());
					  

					/*InvokeRule expression*/
					recog.base.set_state(1056);
					let tmp = recog.expression_rec(0)?;
					 cast_mut::<_,Variable_initializationContext >(&mut _localctx).action = Some(tmp.clone());
					  

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variable_assignment ----------------
pub type Variable_assignmentContextAll<'input> = Variable_assignmentContext<'input>;


pub type Variable_assignmentContext<'input> = BaseParserRuleContext<'input,Variable_assignmentContextExt<'input>>;

#[derive(Clone)]
pub struct Variable_assignmentContextExt<'input>{
	pub var: Option<Rc<IdentifierContextAll<'input>>>,
	pub op: Option<TokenType<'input>>,
	pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Variable_assignmentContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Variable_assignmentContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_variable_assignment(self);
	}
}

impl<'input> CustomRuleContext<'input> for Variable_assignmentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variable_assignment }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variable_assignment }
}
antlr_rust::type_id!{Variable_assignmentContextExt<'a>}

impl<'input> Variable_assignmentContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Variable_assignmentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Variable_assignmentContextExt{
				op: None, 
				var: None, rhs: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait Variable_assignmentContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Variable_assignmentContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Variable_assignmentContextAttrs<'input> for Variable_assignmentContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variable_assignment(&mut self,)
	-> Result<Rc<Variable_assignmentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Variable_assignmentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_variable_assignment);
        let mut _localctx: Rc<Variable_assignmentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1060);
			let tmp = recog.identifier()?;
			 cast_mut::<_,Variable_assignmentContext >(&mut _localctx).var = Some(tmp.clone());
			  

			recog.base.set_state(1061);
			let tmp = recog.base.match_token(T__29,&mut recog.err_handler)?;
			 cast_mut::<_,Variable_assignmentContext >(&mut _localctx).op = Some(tmp.clone());
			  

			/*InvokeRule expression*/
			recog.base.set_state(1062);
			let tmp = recog.expression_rec(0)?;
			 cast_mut::<_,Variable_assignmentContext >(&mut _localctx).rhs = Some(tmp.clone());
			  

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lvalue ----------------
pub type LvalueContextAll<'input> = LvalueContext<'input>;


pub type LvalueContext<'input> = BaseParserRuleContext<'input,LvalueContextExt<'input>>;

#[derive(Clone)]
pub struct LvalueContextExt<'input>{
	pub index: Option<Rc<ExpressionContextAll<'input>>>,
	pub msb: Option<Rc<ExpressionContextAll<'input>>>,
	pub lsb: Option<Rc<ExpressionContextAll<'input>>>,
	pub widthup: Option<TokenType<'input>>,
	pub widthdown: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for LvalueContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for LvalueContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lvalue(self);
	}
}

impl<'input> CustomRuleContext<'input> for LvalueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lvalue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lvalue }
}
antlr_rust::type_id!{LvalueContextExt<'a>}

impl<'input> LvalueContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LvalueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LvalueContextExt{
				widthup: None, widthdown: None, 
				index: None, msb: None, lsb: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait LvalueContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<LvalueContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token INT_LITERAL
/// Returns `None` if there is no child corresponding to token INT_LITERAL
fn INT_LITERAL(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(INT_LITERAL, 0)
}

}

impl<'input> LvalueContextAttrs<'input> for LvalueContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lvalue(&mut self,)
	-> Result<Rc<LvalueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LvalueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_lvalue);
        let mut _localctx: Rc<LvalueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1087);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(93,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(1064);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule primary_expression*/
					recog.base.set_state(1065);
					recog.primary_expression_rec(0)?;

					recog.base.set_state(1066);
					recog.base.match_token(T__45,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(1067);
					recog.identifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule primary_expression*/
					recog.base.set_state(1069);
					recog.primary_expression_rec(0)?;

					recog.base.set_state(1070);
					recog.base.match_token(T__14,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1071);
					let tmp = recog.expression_rec(0)?;
					 cast_mut::<_,LvalueContext >(&mut _localctx).index = Some(tmp.clone());
					  

					recog.base.set_state(1072);
					recog.base.match_token(T__15,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule primary_expression*/
					recog.base.set_state(1074);
					recog.primary_expression_rec(0)?;

					recog.base.set_state(1075);
					recog.base.match_token(T__14,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1076);
					let tmp = recog.expression_rec(0)?;
					 cast_mut::<_,LvalueContext >(&mut _localctx).msb = Some(tmp.clone());
					  

					recog.base.set_state(1083);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 T__3 
						=> {
							{
							{
							recog.base.set_state(1077);
							recog.base.match_token(T__3,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(1078);
							let tmp = recog.expression_rec(0)?;
							 cast_mut::<_,LvalueContext >(&mut _localctx).lsb = Some(tmp.clone());
							  

							}
							}
						}

					 T__46 
						=> {
							{
							{
							recog.base.set_state(1079);
							recog.base.match_token(T__46,&mut recog.err_handler)?;

							recog.base.set_state(1080);
							let tmp = recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;
							 cast_mut::<_,LvalueContext >(&mut _localctx).widthup = Some(tmp.clone());
							  

							}
							}
						}

					 T__47 
						=> {
							{
							{
							recog.base.set_state(1081);
							recog.base.match_token(T__47,&mut recog.err_handler)?;

							recog.base.set_state(1082);
							let tmp = recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;
							 cast_mut::<_,LvalueContext >(&mut _localctx).widthdown = Some(tmp.clone());
							  

							}
							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1085);
					recog.base.match_token(T__15,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- regWrite ----------------
pub type RegWriteContextAll<'input> = RegWriteContext<'input>;


pub type RegWriteContext<'input> = BaseParserRuleContext<'input,RegWriteContextExt<'input>>;

#[derive(Clone)]
pub struct RegWriteContextExt<'input>{
	pub lhs: Option<Rc<LvalueContextAll<'input>>>,
	pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for RegWriteContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for RegWriteContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_regWrite(self);
	}
}

impl<'input> CustomRuleContext<'input> for RegWriteContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_regWrite }
	//fn type_rule_index() -> usize where Self: Sized { RULE_regWrite }
}
antlr_rust::type_id!{RegWriteContextExt<'a>}

impl<'input> RegWriteContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RegWriteContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RegWriteContextExt{
				lhs: None, rhs: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait RegWriteContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<RegWriteContextExt<'input>>{

fn lvalue(&self) -> Option<Rc<LvalueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RegWriteContextAttrs<'input> for RegWriteContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn regWrite(&mut self,)
	-> Result<Rc<RegWriteContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RegWriteContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_regWrite);
        let mut _localctx: Rc<RegWriteContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule lvalue*/
			recog.base.set_state(1089);
			let tmp = recog.lvalue()?;
			 cast_mut::<_,RegWriteContext >(&mut _localctx).lhs = Some(tmp.clone());
			  

			recog.base.set_state(1090);
			recog.base.match_token(T__48,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1091);
			let tmp = recog.expression_rec(0)?;
			 cast_mut::<_,RegWriteContext >(&mut _localctx).rhs = Some(tmp.clone());
			  

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- beginEndStmt_functionBodyStmt ----------------
pub type BeginEndStmt_functionBodyStmtContextAll<'input> = BeginEndStmt_functionBodyStmtContext<'input>;


pub type BeginEndStmt_functionBodyStmtContext<'input> = BaseParserRuleContext<'input,BeginEndStmt_functionBodyStmtContextExt<'input>>;

#[derive(Clone)]
pub struct BeginEndStmt_functionBodyStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for BeginEndStmt_functionBodyStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BeginEndStmt_functionBodyStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_beginEndStmt_functionBodyStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for BeginEndStmt_functionBodyStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_beginEndStmt_functionBodyStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_beginEndStmt_functionBodyStmt }
}
antlr_rust::type_id!{BeginEndStmt_functionBodyStmtContextExt<'a>}

impl<'input> BeginEndStmt_functionBodyStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BeginEndStmt_functionBodyStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BeginEndStmt_functionBodyStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BeginEndStmt_functionBodyStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<BeginEndStmt_functionBodyStmtContextExt<'input>>{

fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn functionBodyStmt_all(&self) ->  Vec<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionBodyStmt(&self, i: usize) -> Option<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> BeginEndStmt_functionBodyStmtContextAttrs<'input> for BeginEndStmt_functionBodyStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn beginEndStmt_functionBodyStmt(&mut self,)
	-> Result<Rc<BeginEndStmt_functionBodyStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BeginEndStmt_functionBodyStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_beginEndStmt_functionBodyStmt);
        let mut _localctx: Rc<BeginEndStmt_functionBodyStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1093);
			recog.base.match_token(T__49,&mut recog.err_handler)?;

			recog.base.set_state(1096);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1094);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1095);
				recog.identifier()?;

				}
			}

			recog.base.set_state(1101);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__30) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__60))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
				{
				{
				/*InvokeRule functionBodyStmt*/
				recog.base.set_state(1098);
				recog.functionBodyStmt()?;

				}
				}
				recog.base.set_state(1103);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1104);
			recog.base.match_token(T__50,&mut recog.err_handler)?;

			recog.base.set_state(1107);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1105);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1106);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- beginEndStmt_actionStmt ----------------
pub type BeginEndStmt_actionStmtContextAll<'input> = BeginEndStmt_actionStmtContext<'input>;


pub type BeginEndStmt_actionStmtContext<'input> = BaseParserRuleContext<'input,BeginEndStmt_actionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct BeginEndStmt_actionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for BeginEndStmt_actionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BeginEndStmt_actionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_beginEndStmt_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for BeginEndStmt_actionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_beginEndStmt_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_beginEndStmt_actionStmt }
}
antlr_rust::type_id!{BeginEndStmt_actionStmtContextExt<'a>}

impl<'input> BeginEndStmt_actionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BeginEndStmt_actionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BeginEndStmt_actionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BeginEndStmt_actionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<BeginEndStmt_actionStmtContextExt<'input>>{

fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn actionStmt_all(&self) ->  Vec<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionStmt(&self, i: usize) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> BeginEndStmt_actionStmtContextAttrs<'input> for BeginEndStmt_actionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn beginEndStmt_actionStmt(&mut self,)
	-> Result<Rc<BeginEndStmt_actionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BeginEndStmt_actionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_beginEndStmt_actionStmt);
        let mut _localctx: Rc<BeginEndStmt_actionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1109);
			recog.base.match_token(T__49,&mut recog.err_handler)?;

			recog.base.set_state(1112);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1110);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1111);
				recog.identifier()?;

				}
			}

			recog.base.set_state(1117);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__94 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule actionStmt*/
				recog.base.set_state(1114);
				recog.actionStmt()?;

				}
				}
				recog.base.set_state(1119);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1120);
			recog.base.match_token(T__50,&mut recog.err_handler)?;

			recog.base.set_state(1123);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1121);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1122);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- beginEndStmt_actionValueStmt ----------------
pub type BeginEndStmt_actionValueStmtContextAll<'input> = BeginEndStmt_actionValueStmtContext<'input>;


pub type BeginEndStmt_actionValueStmtContext<'input> = BaseParserRuleContext<'input,BeginEndStmt_actionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct BeginEndStmt_actionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for BeginEndStmt_actionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BeginEndStmt_actionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_beginEndStmt_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for BeginEndStmt_actionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_beginEndStmt_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_beginEndStmt_actionValueStmt }
}
antlr_rust::type_id!{BeginEndStmt_actionValueStmtContextExt<'a>}

impl<'input> BeginEndStmt_actionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BeginEndStmt_actionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BeginEndStmt_actionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BeginEndStmt_actionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<BeginEndStmt_actionValueStmtContextExt<'input>>{

fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn actionValueStmt_all(&self) ->  Vec<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionValueStmt(&self, i: usize) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> BeginEndStmt_actionValueStmtContextAttrs<'input> for BeginEndStmt_actionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn beginEndStmt_actionValueStmt(&mut self,)
	-> Result<Rc<BeginEndStmt_actionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BeginEndStmt_actionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_beginEndStmt_actionValueStmt);
        let mut _localctx: Rc<BeginEndStmt_actionValueStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1125);
			recog.base.match_token(T__49,&mut recog.err_handler)?;

			recog.base.set_state(1128);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1126);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1127);
				recog.identifier()?;

				}
			}

			recog.base.set_state(1133);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__1) | (1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__60) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__96 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule actionValueStmt*/
				recog.base.set_state(1130);
				recog.actionValueStmt()?;

				}
				}
				recog.base.set_state(1135);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1136);
			recog.base.match_token(T__50,&mut recog.err_handler)?;

			recog.base.set_state(1139);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1137);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1138);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- beginEndStmt_moduleStmt ----------------
pub type BeginEndStmt_moduleStmtContextAll<'input> = BeginEndStmt_moduleStmtContext<'input>;


pub type BeginEndStmt_moduleStmtContext<'input> = BaseParserRuleContext<'input,BeginEndStmt_moduleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct BeginEndStmt_moduleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for BeginEndStmt_moduleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BeginEndStmt_moduleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_beginEndStmt_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for BeginEndStmt_moduleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_beginEndStmt_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_beginEndStmt_moduleStmt }
}
antlr_rust::type_id!{BeginEndStmt_moduleStmtContextExt<'a>}

impl<'input> BeginEndStmt_moduleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BeginEndStmt_moduleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BeginEndStmt_moduleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BeginEndStmt_moduleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<BeginEndStmt_moduleStmtContextExt<'input>>{

fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn moduleStmt_all(&self) ->  Vec<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleStmt(&self, i: usize) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> BeginEndStmt_moduleStmtContextAttrs<'input> for BeginEndStmt_moduleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn beginEndStmt_moduleStmt(&mut self,)
	-> Result<Rc<BeginEndStmt_moduleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BeginEndStmt_moduleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_beginEndStmt_moduleStmt);
        let mut _localctx: Rc<BeginEndStmt_moduleStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1141);
			recog.base.match_token(T__49,&mut recog.err_handler)?;

			recog.base.set_state(1144);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1142);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1143);
				recog.identifier()?;

				}
			}

			recog.base.set_state(1149);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__21) | (1usize << T__23) | (1usize << T__30) | (1usize << T__31) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__60) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule moduleStmt*/
				recog.base.set_state(1146);
				recog.moduleStmt()?;

				}
				}
				recog.base.set_state(1151);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1152);
			recog.base.match_token(T__50,&mut recog.err_handler)?;

			recog.base.set_state(1155);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1153);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1154);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- beginEndStmt_expressionStmt ----------------
pub type BeginEndStmt_expressionStmtContextAll<'input> = BeginEndStmt_expressionStmtContext<'input>;


pub type BeginEndStmt_expressionStmtContext<'input> = BaseParserRuleContext<'input,BeginEndStmt_expressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct BeginEndStmt_expressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for BeginEndStmt_expressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BeginEndStmt_expressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_beginEndStmt_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for BeginEndStmt_expressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_beginEndStmt_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_beginEndStmt_expressionStmt }
}
antlr_rust::type_id!{BeginEndStmt_expressionStmtContextExt<'a>}

impl<'input> BeginEndStmt_expressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BeginEndStmt_expressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BeginEndStmt_expressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BeginEndStmt_expressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<BeginEndStmt_expressionStmtContextExt<'input>>{

fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn expressionStmt_all(&self) ->  Vec<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expressionStmt(&self, i: usize) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> BeginEndStmt_expressionStmtContextAttrs<'input> for BeginEndStmt_expressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn beginEndStmt_expressionStmt(&mut self,)
	-> Result<Rc<BeginEndStmt_expressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BeginEndStmt_expressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_beginEndStmt_expressionStmt);
        let mut _localctx: Rc<BeginEndStmt_expressionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1157);
			recog.base.match_token(T__49,&mut recog.err_handler)?;

			recog.base.set_state(1160);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1158);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1159);
				recog.identifier()?;

				}
			}

			recog.base.set_state(1165);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__30) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
				{
				{
				/*InvokeRule expressionStmt*/
				recog.base.set_state(1162);
				recog.expressionStmt()?;

				}
				}
				recog.base.set_state(1167);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1168);
			recog.base.match_token(T__50,&mut recog.err_handler)?;

			recog.base.set_state(1171);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1169);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1170);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- if_functionBodyStmt ----------------
pub type If_functionBodyStmtContextAll<'input> = If_functionBodyStmtContext<'input>;


pub type If_functionBodyStmtContext<'input> = BaseParserRuleContext<'input,If_functionBodyStmtContextExt<'input>>;

#[derive(Clone)]
pub struct If_functionBodyStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for If_functionBodyStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for If_functionBodyStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_if_functionBodyStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for If_functionBodyStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_if_functionBodyStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_if_functionBodyStmt }
}
antlr_rust::type_id!{If_functionBodyStmtContextExt<'a>}

impl<'input> If_functionBodyStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<If_functionBodyStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,If_functionBodyStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait If_functionBodyStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<If_functionBodyStmtContextExt<'input>>{

fn cond_predicate(&self) -> Option<Rc<Cond_predicateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBodyStmt_all(&self) ->  Vec<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionBodyStmt(&self, i: usize) -> Option<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> If_functionBodyStmtContextAttrs<'input> for If_functionBodyStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn if_functionBodyStmt(&mut self,)
	-> Result<Rc<If_functionBodyStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = If_functionBodyStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_if_functionBodyStmt);
        let mut _localctx: Rc<If_functionBodyStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1173);
			recog.base.match_token(T__30,&mut recog.err_handler)?;

			recog.base.set_state(1174);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule cond_predicate*/
			recog.base.set_state(1175);
			recog.cond_predicate()?;

			recog.base.set_state(1176);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule functionBodyStmt*/
			recog.base.set_state(1177);
			recog.functionBodyStmt()?;

			recog.base.set_state(1180);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__51 {
				{
				recog.base.set_state(1178);
				recog.base.match_token(T__51,&mut recog.err_handler)?;

				/*InvokeRule functionBodyStmt*/
				recog.base.set_state(1179);
				recog.functionBodyStmt()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- if_actionStmt ----------------
pub type If_actionStmtContextAll<'input> = If_actionStmtContext<'input>;


pub type If_actionStmtContext<'input> = BaseParserRuleContext<'input,If_actionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct If_actionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for If_actionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for If_actionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_if_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for If_actionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_if_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_if_actionStmt }
}
antlr_rust::type_id!{If_actionStmtContextExt<'a>}

impl<'input> If_actionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<If_actionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,If_actionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait If_actionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<If_actionStmtContextExt<'input>>{

fn cond_predicate(&self) -> Option<Rc<Cond_predicateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionStmt_all(&self) ->  Vec<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionStmt(&self, i: usize) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> If_actionStmtContextAttrs<'input> for If_actionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn if_actionStmt(&mut self,)
	-> Result<Rc<If_actionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = If_actionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_if_actionStmt);
        let mut _localctx: Rc<If_actionStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1182);
			recog.base.match_token(T__30,&mut recog.err_handler)?;

			recog.base.set_state(1183);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule cond_predicate*/
			recog.base.set_state(1184);
			recog.cond_predicate()?;

			recog.base.set_state(1185);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule actionStmt*/
			recog.base.set_state(1186);
			recog.actionStmt()?;

			recog.base.set_state(1189);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(110,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1187);
					recog.base.match_token(T__51,&mut recog.err_handler)?;

					/*InvokeRule actionStmt*/
					recog.base.set_state(1188);
					recog.actionStmt()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- if_actionValueStmt ----------------
pub type If_actionValueStmtContextAll<'input> = If_actionValueStmtContext<'input>;


pub type If_actionValueStmtContext<'input> = BaseParserRuleContext<'input,If_actionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct If_actionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for If_actionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for If_actionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_if_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for If_actionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_if_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_if_actionValueStmt }
}
antlr_rust::type_id!{If_actionValueStmtContextExt<'a>}

impl<'input> If_actionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<If_actionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,If_actionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait If_actionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<If_actionValueStmtContextExt<'input>>{

fn cond_predicate(&self) -> Option<Rc<Cond_predicateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionValueStmt_all(&self) ->  Vec<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionValueStmt(&self, i: usize) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> If_actionValueStmtContextAttrs<'input> for If_actionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn if_actionValueStmt(&mut self,)
	-> Result<Rc<If_actionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = If_actionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_if_actionValueStmt);
        let mut _localctx: Rc<If_actionValueStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1191);
			recog.base.match_token(T__30,&mut recog.err_handler)?;

			recog.base.set_state(1192);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule cond_predicate*/
			recog.base.set_state(1193);
			recog.cond_predicate()?;

			recog.base.set_state(1194);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule actionValueStmt*/
			recog.base.set_state(1195);
			recog.actionValueStmt()?;

			recog.base.set_state(1198);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(111,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1196);
					recog.base.match_token(T__51,&mut recog.err_handler)?;

					/*InvokeRule actionValueStmt*/
					recog.base.set_state(1197);
					recog.actionValueStmt()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- if_moduleStmt ----------------
pub type If_moduleStmtContextAll<'input> = If_moduleStmtContext<'input>;


pub type If_moduleStmtContext<'input> = BaseParserRuleContext<'input,If_moduleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct If_moduleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for If_moduleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for If_moduleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_if_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for If_moduleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_if_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_if_moduleStmt }
}
antlr_rust::type_id!{If_moduleStmtContextExt<'a>}

impl<'input> If_moduleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<If_moduleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,If_moduleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait If_moduleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<If_moduleStmtContextExt<'input>>{

fn cond_predicate(&self) -> Option<Rc<Cond_predicateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moduleStmt_all(&self) ->  Vec<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleStmt(&self, i: usize) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> If_moduleStmtContextAttrs<'input> for If_moduleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn if_moduleStmt(&mut self,)
	-> Result<Rc<If_moduleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = If_moduleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_if_moduleStmt);
        let mut _localctx: Rc<If_moduleStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1200);
			recog.base.match_token(T__30,&mut recog.err_handler)?;

			recog.base.set_state(1201);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule cond_predicate*/
			recog.base.set_state(1202);
			recog.cond_predicate()?;

			recog.base.set_state(1203);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule moduleStmt*/
			recog.base.set_state(1204);
			recog.moduleStmt()?;

			recog.base.set_state(1207);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(112,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1205);
					recog.base.match_token(T__51,&mut recog.err_handler)?;

					/*InvokeRule moduleStmt*/
					recog.base.set_state(1206);
					recog.moduleStmt()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- if_expressionStmt ----------------
pub type If_expressionStmtContextAll<'input> = If_expressionStmtContext<'input>;


pub type If_expressionStmtContext<'input> = BaseParserRuleContext<'input,If_expressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct If_expressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for If_expressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for If_expressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_if_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for If_expressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_if_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_if_expressionStmt }
}
antlr_rust::type_id!{If_expressionStmtContextExt<'a>}

impl<'input> If_expressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<If_expressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,If_expressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait If_expressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<If_expressionStmtContextExt<'input>>{

fn cond_predicate(&self) -> Option<Rc<Cond_predicateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStmt_all(&self) ->  Vec<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expressionStmt(&self, i: usize) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> If_expressionStmtContextAttrs<'input> for If_expressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn if_expressionStmt(&mut self,)
	-> Result<Rc<If_expressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = If_expressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_if_expressionStmt);
        let mut _localctx: Rc<If_expressionStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1209);
			recog.base.match_token(T__30,&mut recog.err_handler)?;

			recog.base.set_state(1210);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule cond_predicate*/
			recog.base.set_state(1211);
			recog.cond_predicate()?;

			recog.base.set_state(1212);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule expressionStmt*/
			recog.base.set_state(1213);
			recog.expressionStmt()?;

			recog.base.set_state(1216);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(113,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1214);
					recog.base.match_token(T__51,&mut recog.err_handler)?;

					/*InvokeRule expressionStmt*/
					recog.base.set_state(1215);
					recog.expressionStmt()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- case_actionStmt ----------------
pub type Case_actionStmtContextAll<'input> = Case_actionStmtContext<'input>;


pub type Case_actionStmtContext<'input> = BaseParserRuleContext<'input,Case_actionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct Case_actionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Case_actionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Case_actionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_case_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for Case_actionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_case_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_case_actionStmt }
}
antlr_rust::type_id!{Case_actionStmtContextExt<'a>}

impl<'input> Case_actionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Case_actionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Case_actionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Case_actionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Case_actionStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn caseItem_actionStmt_all(&self) ->  Vec<Rc<CaseItem_actionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn caseItem_actionStmt(&self, i: usize) -> Option<Rc<CaseItem_actionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn defaultItem_actionStmt(&self) -> Option<Rc<DefaultItem_actionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn casePatItem_actionStmt_all(&self) ->  Vec<Rc<CasePatItem_actionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn casePatItem_actionStmt(&self, i: usize) -> Option<Rc<CasePatItem_actionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Case_actionStmtContextAttrs<'input> for Case_actionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn case_actionStmt(&mut self,)
	-> Result<Rc<Case_actionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Case_actionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_case_actionStmt);
        let mut _localctx: Rc<Case_actionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1249);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(118,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1218);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1219);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1220);
					recog.expression_rec(0)?;

					recog.base.set_state(1221);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1225);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
						{
						{
						/*InvokeRule caseItem_actionStmt*/
						recog.base.set_state(1222);
						recog.caseItem_actionStmt()?;

						}
						}
						recog.base.set_state(1227);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1229);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule defaultItem_actionStmt*/
						recog.base.set_state(1228);
						recog.defaultItem_actionStmt()?;

						}
					}

					recog.base.set_state(1231);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1233);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1234);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1235);
					recog.expression_rec(0)?;

					recog.base.set_state(1236);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1237);
					recog.base.match_token(T__54,&mut recog.err_handler)?;

					recog.base.set_state(1241);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__35) | (1usize << T__39) | (1usize << T__45))) != 0) || ((((_la - 101)) & !0x3f) == 0 && ((1usize << (_la - 101)) & ((1usize << (T__100 - 101)) | (1usize << (UPPER_IDENTIFIER - 101)) | (1usize << (STRING_LITERAL - 101)) | (1usize << (INT_LITERAL - 101)) | (1usize << (REAL_LITERAL - 101)))) != 0) {
						{
						{
						/*InvokeRule casePatItem_actionStmt*/
						recog.base.set_state(1238);
						recog.casePatItem_actionStmt()?;

						}
						}
						recog.base.set_state(1243);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1245);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule defaultItem_actionStmt*/
						recog.base.set_state(1244);
						recog.defaultItem_actionStmt()?;

						}
					}

					recog.base.set_state(1247);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- case_actionValueStmt ----------------
pub type Case_actionValueStmtContextAll<'input> = Case_actionValueStmtContext<'input>;


pub type Case_actionValueStmtContext<'input> = BaseParserRuleContext<'input,Case_actionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct Case_actionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Case_actionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Case_actionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_case_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for Case_actionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_case_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_case_actionValueStmt }
}
antlr_rust::type_id!{Case_actionValueStmtContextExt<'a>}

impl<'input> Case_actionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Case_actionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Case_actionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Case_actionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Case_actionValueStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn caseItem_actionValueStmt_all(&self) ->  Vec<Rc<CaseItem_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn caseItem_actionValueStmt(&self, i: usize) -> Option<Rc<CaseItem_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn defaultItem_actionValueStmt(&self) -> Option<Rc<DefaultItem_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn casePatItem_actionValueStmt_all(&self) ->  Vec<Rc<CasePatItem_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn casePatItem_actionValueStmt(&self, i: usize) -> Option<Rc<CasePatItem_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Case_actionValueStmtContextAttrs<'input> for Case_actionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn case_actionValueStmt(&mut self,)
	-> Result<Rc<Case_actionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Case_actionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_case_actionValueStmt);
        let mut _localctx: Rc<Case_actionValueStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1282);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(123,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1251);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1252);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1253);
					recog.expression_rec(0)?;

					recog.base.set_state(1254);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1258);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
						{
						{
						/*InvokeRule caseItem_actionValueStmt*/
						recog.base.set_state(1255);
						recog.caseItem_actionValueStmt()?;

						}
						}
						recog.base.set_state(1260);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1262);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule defaultItem_actionValueStmt*/
						recog.base.set_state(1261);
						recog.defaultItem_actionValueStmt()?;

						}
					}

					recog.base.set_state(1264);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1266);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1267);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1268);
					recog.expression_rec(0)?;

					recog.base.set_state(1269);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1270);
					recog.base.match_token(T__54,&mut recog.err_handler)?;

					recog.base.set_state(1274);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__35) | (1usize << T__39) | (1usize << T__45))) != 0) || ((((_la - 101)) & !0x3f) == 0 && ((1usize << (_la - 101)) & ((1usize << (T__100 - 101)) | (1usize << (UPPER_IDENTIFIER - 101)) | (1usize << (STRING_LITERAL - 101)) | (1usize << (INT_LITERAL - 101)) | (1usize << (REAL_LITERAL - 101)))) != 0) {
						{
						{
						/*InvokeRule casePatItem_actionValueStmt*/
						recog.base.set_state(1271);
						recog.casePatItem_actionValueStmt()?;

						}
						}
						recog.base.set_state(1276);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1278);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule defaultItem_actionValueStmt*/
						recog.base.set_state(1277);
						recog.defaultItem_actionValueStmt()?;

						}
					}

					recog.base.set_state(1280);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- case_moduleStmt ----------------
pub type Case_moduleStmtContextAll<'input> = Case_moduleStmtContext<'input>;


pub type Case_moduleStmtContext<'input> = BaseParserRuleContext<'input,Case_moduleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct Case_moduleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Case_moduleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Case_moduleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_case_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for Case_moduleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_case_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_case_moduleStmt }
}
antlr_rust::type_id!{Case_moduleStmtContextExt<'a>}

impl<'input> Case_moduleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Case_moduleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Case_moduleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Case_moduleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Case_moduleStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn caseItem_moduleStmt_all(&self) ->  Vec<Rc<CaseItem_moduleStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn caseItem_moduleStmt(&self, i: usize) -> Option<Rc<CaseItem_moduleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn defaultItem_moduleStmt(&self) -> Option<Rc<DefaultItem_moduleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn casePatItem_moduleStmt_all(&self) ->  Vec<Rc<CasePatItem_moduleStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn casePatItem_moduleStmt(&self, i: usize) -> Option<Rc<CasePatItem_moduleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Case_moduleStmtContextAttrs<'input> for Case_moduleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn case_moduleStmt(&mut self,)
	-> Result<Rc<Case_moduleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Case_moduleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_case_moduleStmt);
        let mut _localctx: Rc<Case_moduleStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1315);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(128,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1284);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1285);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1286);
					recog.expression_rec(0)?;

					recog.base.set_state(1287);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1291);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
						{
						{
						/*InvokeRule caseItem_moduleStmt*/
						recog.base.set_state(1288);
						recog.caseItem_moduleStmt()?;

						}
						}
						recog.base.set_state(1293);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1295);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule defaultItem_moduleStmt*/
						recog.base.set_state(1294);
						recog.defaultItem_moduleStmt()?;

						}
					}

					recog.base.set_state(1297);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1299);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1300);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1301);
					recog.expression_rec(0)?;

					recog.base.set_state(1302);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1303);
					recog.base.match_token(T__54,&mut recog.err_handler)?;

					recog.base.set_state(1307);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__35) | (1usize << T__39) | (1usize << T__45))) != 0) || ((((_la - 101)) & !0x3f) == 0 && ((1usize << (_la - 101)) & ((1usize << (T__100 - 101)) | (1usize << (UPPER_IDENTIFIER - 101)) | (1usize << (STRING_LITERAL - 101)) | (1usize << (INT_LITERAL - 101)) | (1usize << (REAL_LITERAL - 101)))) != 0) {
						{
						{
						/*InvokeRule casePatItem_moduleStmt*/
						recog.base.set_state(1304);
						recog.casePatItem_moduleStmt()?;

						}
						}
						recog.base.set_state(1309);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1311);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule defaultItem_moduleStmt*/
						recog.base.set_state(1310);
						recog.defaultItem_moduleStmt()?;

						}
					}

					recog.base.set_state(1313);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- case_expressionStmt ----------------
pub type Case_expressionStmtContextAll<'input> = Case_expressionStmtContext<'input>;


pub type Case_expressionStmtContext<'input> = BaseParserRuleContext<'input,Case_expressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct Case_expressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Case_expressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Case_expressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_case_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for Case_expressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_case_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_case_expressionStmt }
}
antlr_rust::type_id!{Case_expressionStmtContextExt<'a>}

impl<'input> Case_expressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Case_expressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Case_expressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Case_expressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Case_expressionStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn caseItem_expressionStmt_all(&self) ->  Vec<Rc<CaseItem_expressionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn caseItem_expressionStmt(&self, i: usize) -> Option<Rc<CaseItem_expressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn defaultItem_expressionStmt(&self) -> Option<Rc<DefaultItem_expressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn casePatItem_expressionStmt_all(&self) ->  Vec<Rc<CasePatItem_expressionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn casePatItem_expressionStmt(&self, i: usize) -> Option<Rc<CasePatItem_expressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Case_expressionStmtContextAttrs<'input> for Case_expressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn case_expressionStmt(&mut self,)
	-> Result<Rc<Case_expressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Case_expressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_case_expressionStmt);
        let mut _localctx: Rc<Case_expressionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1348);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(133,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1317);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1318);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1319);
					recog.expression_rec(0)?;

					recog.base.set_state(1320);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1324);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
						{
						{
						/*InvokeRule caseItem_expressionStmt*/
						recog.base.set_state(1321);
						recog.caseItem_expressionStmt()?;

						}
						}
						recog.base.set_state(1326);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1328);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule defaultItem_expressionStmt*/
						recog.base.set_state(1327);
						recog.defaultItem_expressionStmt()?;

						}
					}

					recog.base.set_state(1330);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1332);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1333);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1334);
					recog.expression_rec(0)?;

					recog.base.set_state(1335);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1336);
					recog.base.match_token(T__54,&mut recog.err_handler)?;

					recog.base.set_state(1340);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__35) | (1usize << T__39) | (1usize << T__45))) != 0) || ((((_la - 101)) & !0x3f) == 0 && ((1usize << (_la - 101)) & ((1usize << (T__100 - 101)) | (1usize << (UPPER_IDENTIFIER - 101)) | (1usize << (STRING_LITERAL - 101)) | (1usize << (INT_LITERAL - 101)) | (1usize << (REAL_LITERAL - 101)))) != 0) {
						{
						{
						/*InvokeRule casePatItem_expressionStmt*/
						recog.base.set_state(1337);
						recog.casePatItem_expressionStmt()?;

						}
						}
						recog.base.set_state(1342);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1344);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule defaultItem_expressionStmt*/
						recog.base.set_state(1343);
						recog.defaultItem_expressionStmt()?;

						}
					}

					recog.base.set_state(1346);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseItem_functionBodyStmt ----------------
pub type CaseItem_functionBodyStmtContextAll<'input> = CaseItem_functionBodyStmtContext<'input>;


pub type CaseItem_functionBodyStmtContext<'input> = BaseParserRuleContext<'input,CaseItem_functionBodyStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CaseItem_functionBodyStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseItem_functionBodyStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseItem_functionBodyStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseItem_functionBodyStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseItem_functionBodyStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseItem_functionBodyStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseItem_functionBodyStmt }
}
antlr_rust::type_id!{CaseItem_functionBodyStmtContextExt<'a>}

impl<'input> CaseItem_functionBodyStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseItem_functionBodyStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseItem_functionBodyStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseItem_functionBodyStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseItem_functionBodyStmtContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn functionBodyStmt(&self) -> Option<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CaseItem_functionBodyStmtContextAttrs<'input> for CaseItem_functionBodyStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseItem_functionBodyStmt(&mut self,)
	-> Result<Rc<CaseItem_functionBodyStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseItem_functionBodyStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_caseItem_functionBodyStmt);
        let mut _localctx: Rc<CaseItem_functionBodyStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(1350);
			recog.expression_rec(0)?;

			recog.base.set_state(1355);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1351);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(1352);
				recog.expression_rec(0)?;

				}
				}
				recog.base.set_state(1357);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1358);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule functionBodyStmt*/
			recog.base.set_state(1359);
			recog.functionBodyStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseItem_actionStmt ----------------
pub type CaseItem_actionStmtContextAll<'input> = CaseItem_actionStmtContext<'input>;


pub type CaseItem_actionStmtContext<'input> = BaseParserRuleContext<'input,CaseItem_actionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CaseItem_actionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseItem_actionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseItem_actionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseItem_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseItem_actionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseItem_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseItem_actionStmt }
}
antlr_rust::type_id!{CaseItem_actionStmtContextExt<'a>}

impl<'input> CaseItem_actionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseItem_actionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseItem_actionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseItem_actionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseItem_actionStmtContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn actionStmt(&self) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CaseItem_actionStmtContextAttrs<'input> for CaseItem_actionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseItem_actionStmt(&mut self,)
	-> Result<Rc<CaseItem_actionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseItem_actionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_caseItem_actionStmt);
        let mut _localctx: Rc<CaseItem_actionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(1361);
			recog.expression_rec(0)?;

			recog.base.set_state(1366);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1362);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(1363);
				recog.expression_rec(0)?;

				}
				}
				recog.base.set_state(1368);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1369);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule actionStmt*/
			recog.base.set_state(1370);
			recog.actionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseItem_actionValueStmt ----------------
pub type CaseItem_actionValueStmtContextAll<'input> = CaseItem_actionValueStmtContext<'input>;


pub type CaseItem_actionValueStmtContext<'input> = BaseParserRuleContext<'input,CaseItem_actionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CaseItem_actionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseItem_actionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseItem_actionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseItem_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseItem_actionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseItem_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseItem_actionValueStmt }
}
antlr_rust::type_id!{CaseItem_actionValueStmtContextExt<'a>}

impl<'input> CaseItem_actionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseItem_actionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseItem_actionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseItem_actionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseItem_actionValueStmtContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn actionValueStmt(&self) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CaseItem_actionValueStmtContextAttrs<'input> for CaseItem_actionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseItem_actionValueStmt(&mut self,)
	-> Result<Rc<CaseItem_actionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseItem_actionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_caseItem_actionValueStmt);
        let mut _localctx: Rc<CaseItem_actionValueStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(1372);
			recog.expression_rec(0)?;

			recog.base.set_state(1377);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1373);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(1374);
				recog.expression_rec(0)?;

				}
				}
				recog.base.set_state(1379);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1380);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule actionValueStmt*/
			recog.base.set_state(1381);
			recog.actionValueStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseItem_moduleStmt ----------------
pub type CaseItem_moduleStmtContextAll<'input> = CaseItem_moduleStmtContext<'input>;


pub type CaseItem_moduleStmtContext<'input> = BaseParserRuleContext<'input,CaseItem_moduleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CaseItem_moduleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseItem_moduleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseItem_moduleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseItem_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseItem_moduleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseItem_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseItem_moduleStmt }
}
antlr_rust::type_id!{CaseItem_moduleStmtContextExt<'a>}

impl<'input> CaseItem_moduleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseItem_moduleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseItem_moduleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseItem_moduleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseItem_moduleStmtContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn moduleStmt(&self) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CaseItem_moduleStmtContextAttrs<'input> for CaseItem_moduleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseItem_moduleStmt(&mut self,)
	-> Result<Rc<CaseItem_moduleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseItem_moduleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_caseItem_moduleStmt);
        let mut _localctx: Rc<CaseItem_moduleStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(1383);
			recog.expression_rec(0)?;

			recog.base.set_state(1388);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1384);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(1385);
				recog.expression_rec(0)?;

				}
				}
				recog.base.set_state(1390);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1391);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule moduleStmt*/
			recog.base.set_state(1392);
			recog.moduleStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseItem_expressionStmt ----------------
pub type CaseItem_expressionStmtContextAll<'input> = CaseItem_expressionStmtContext<'input>;


pub type CaseItem_expressionStmtContext<'input> = BaseParserRuleContext<'input,CaseItem_expressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CaseItem_expressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseItem_expressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseItem_expressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseItem_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseItem_expressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseItem_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseItem_expressionStmt }
}
antlr_rust::type_id!{CaseItem_expressionStmtContextExt<'a>}

impl<'input> CaseItem_expressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseItem_expressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseItem_expressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseItem_expressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseItem_expressionStmtContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CaseItem_expressionStmtContextAttrs<'input> for CaseItem_expressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseItem_expressionStmt(&mut self,)
	-> Result<Rc<CaseItem_expressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseItem_expressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_caseItem_expressionStmt);
        let mut _localctx: Rc<CaseItem_expressionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(1394);
			recog.expression_rec(0)?;

			recog.base.set_state(1399);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1395);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(1396);
				recog.expression_rec(0)?;

				}
				}
				recog.base.set_state(1401);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1402);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule expressionStmt*/
			recog.base.set_state(1403);
			recog.expressionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultItem_functionBodyStmt ----------------
pub type DefaultItem_functionBodyStmtContextAll<'input> = DefaultItem_functionBodyStmtContext<'input>;


pub type DefaultItem_functionBodyStmtContext<'input> = BaseParserRuleContext<'input,DefaultItem_functionBodyStmtContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultItem_functionBodyStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for DefaultItem_functionBodyStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for DefaultItem_functionBodyStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultItem_functionBodyStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultItem_functionBodyStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultItem_functionBodyStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultItem_functionBodyStmt }
}
antlr_rust::type_id!{DefaultItem_functionBodyStmtContextExt<'a>}

impl<'input> DefaultItem_functionBodyStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultItem_functionBodyStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultItem_functionBodyStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultItem_functionBodyStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<DefaultItem_functionBodyStmtContextExt<'input>>{

fn functionBodyStmt(&self) -> Option<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultItem_functionBodyStmtContextAttrs<'input> for DefaultItem_functionBodyStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultItem_functionBodyStmt(&mut self,)
	-> Result<Rc<DefaultItem_functionBodyStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultItem_functionBodyStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_defaultItem_functionBodyStmt);
        let mut _localctx: Rc<DefaultItem_functionBodyStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1405);
			recog.base.match_token(T__55,&mut recog.err_handler)?;

			recog.base.set_state(1407);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1406);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule functionBodyStmt*/
			recog.base.set_state(1409);
			recog.functionBodyStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultItem_actionStmt ----------------
pub type DefaultItem_actionStmtContextAll<'input> = DefaultItem_actionStmtContext<'input>;


pub type DefaultItem_actionStmtContext<'input> = BaseParserRuleContext<'input,DefaultItem_actionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultItem_actionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for DefaultItem_actionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for DefaultItem_actionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultItem_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultItem_actionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultItem_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultItem_actionStmt }
}
antlr_rust::type_id!{DefaultItem_actionStmtContextExt<'a>}

impl<'input> DefaultItem_actionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultItem_actionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultItem_actionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultItem_actionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<DefaultItem_actionStmtContextExt<'input>>{

fn actionStmt(&self) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultItem_actionStmtContextAttrs<'input> for DefaultItem_actionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultItem_actionStmt(&mut self,)
	-> Result<Rc<DefaultItem_actionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultItem_actionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_defaultItem_actionStmt);
        let mut _localctx: Rc<DefaultItem_actionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1411);
			recog.base.match_token(T__55,&mut recog.err_handler)?;

			recog.base.set_state(1413);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1412);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule actionStmt*/
			recog.base.set_state(1415);
			recog.actionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultItem_actionValueStmt ----------------
pub type DefaultItem_actionValueStmtContextAll<'input> = DefaultItem_actionValueStmtContext<'input>;


pub type DefaultItem_actionValueStmtContext<'input> = BaseParserRuleContext<'input,DefaultItem_actionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultItem_actionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for DefaultItem_actionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for DefaultItem_actionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultItem_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultItem_actionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultItem_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultItem_actionValueStmt }
}
antlr_rust::type_id!{DefaultItem_actionValueStmtContextExt<'a>}

impl<'input> DefaultItem_actionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultItem_actionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultItem_actionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultItem_actionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<DefaultItem_actionValueStmtContextExt<'input>>{

fn actionValueStmt(&self) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultItem_actionValueStmtContextAttrs<'input> for DefaultItem_actionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultItem_actionValueStmt(&mut self,)
	-> Result<Rc<DefaultItem_actionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultItem_actionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_defaultItem_actionValueStmt);
        let mut _localctx: Rc<DefaultItem_actionValueStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1417);
			recog.base.match_token(T__55,&mut recog.err_handler)?;

			recog.base.set_state(1419);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1418);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule actionValueStmt*/
			recog.base.set_state(1421);
			recog.actionValueStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultItem_moduleStmt ----------------
pub type DefaultItem_moduleStmtContextAll<'input> = DefaultItem_moduleStmtContext<'input>;


pub type DefaultItem_moduleStmtContext<'input> = BaseParserRuleContext<'input,DefaultItem_moduleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultItem_moduleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for DefaultItem_moduleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for DefaultItem_moduleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultItem_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultItem_moduleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultItem_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultItem_moduleStmt }
}
antlr_rust::type_id!{DefaultItem_moduleStmtContextExt<'a>}

impl<'input> DefaultItem_moduleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultItem_moduleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultItem_moduleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultItem_moduleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<DefaultItem_moduleStmtContextExt<'input>>{

fn moduleStmt(&self) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultItem_moduleStmtContextAttrs<'input> for DefaultItem_moduleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultItem_moduleStmt(&mut self,)
	-> Result<Rc<DefaultItem_moduleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultItem_moduleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_defaultItem_moduleStmt);
        let mut _localctx: Rc<DefaultItem_moduleStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1423);
			recog.base.match_token(T__55,&mut recog.err_handler)?;

			recog.base.set_state(1425);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1424);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule moduleStmt*/
			recog.base.set_state(1427);
			recog.moduleStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultItem_expressionStmt ----------------
pub type DefaultItem_expressionStmtContextAll<'input> = DefaultItem_expressionStmtContext<'input>;


pub type DefaultItem_expressionStmtContext<'input> = BaseParserRuleContext<'input,DefaultItem_expressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultItem_expressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for DefaultItem_expressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for DefaultItem_expressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultItem_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultItem_expressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultItem_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultItem_expressionStmt }
}
antlr_rust::type_id!{DefaultItem_expressionStmtContextExt<'a>}

impl<'input> DefaultItem_expressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultItem_expressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultItem_expressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultItem_expressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<DefaultItem_expressionStmtContextExt<'input>>{

fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultItem_expressionStmtContextAttrs<'input> for DefaultItem_expressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultItem_expressionStmt(&mut self,)
	-> Result<Rc<DefaultItem_expressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultItem_expressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_defaultItem_expressionStmt);
        let mut _localctx: Rc<DefaultItem_expressionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1429);
			recog.base.match_token(T__55,&mut recog.err_handler)?;

			recog.base.set_state(1431);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1430);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule expressionStmt*/
			recog.base.set_state(1433);
			recog.expressionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- while_functionBodyStmt ----------------
pub type While_functionBodyStmtContextAll<'input> = While_functionBodyStmtContext<'input>;


pub type While_functionBodyStmtContext<'input> = BaseParserRuleContext<'input,While_functionBodyStmtContextExt<'input>>;

#[derive(Clone)]
pub struct While_functionBodyStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for While_functionBodyStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for While_functionBodyStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_while_functionBodyStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for While_functionBodyStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_while_functionBodyStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_while_functionBodyStmt }
}
antlr_rust::type_id!{While_functionBodyStmtContextExt<'a>}

impl<'input> While_functionBodyStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<While_functionBodyStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,While_functionBodyStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait While_functionBodyStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<While_functionBodyStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBodyStmt(&self) -> Option<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> While_functionBodyStmtContextAttrs<'input> for While_functionBodyStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn while_functionBodyStmt(&mut self,)
	-> Result<Rc<While_functionBodyStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = While_functionBodyStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_while_functionBodyStmt);
        let mut _localctx: Rc<While_functionBodyStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1435);
			recog.base.match_token(T__56,&mut recog.err_handler)?;

			recog.base.set_state(1436);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1437);
			recog.expression_rec(0)?;

			recog.base.set_state(1438);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule functionBodyStmt*/
			recog.base.set_state(1439);
			recog.functionBodyStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- while_actionStmt ----------------
pub type While_actionStmtContextAll<'input> = While_actionStmtContext<'input>;


pub type While_actionStmtContext<'input> = BaseParserRuleContext<'input,While_actionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct While_actionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for While_actionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for While_actionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_while_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for While_actionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_while_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_while_actionStmt }
}
antlr_rust::type_id!{While_actionStmtContextExt<'a>}

impl<'input> While_actionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<While_actionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,While_actionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait While_actionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<While_actionStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionStmt(&self) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> While_actionStmtContextAttrs<'input> for While_actionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn while_actionStmt(&mut self,)
	-> Result<Rc<While_actionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = While_actionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_while_actionStmt);
        let mut _localctx: Rc<While_actionStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1441);
			recog.base.match_token(T__56,&mut recog.err_handler)?;

			recog.base.set_state(1442);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1443);
			recog.expression_rec(0)?;

			recog.base.set_state(1444);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule actionStmt*/
			recog.base.set_state(1445);
			recog.actionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- while_actionValueStmt ----------------
pub type While_actionValueStmtContextAll<'input> = While_actionValueStmtContext<'input>;


pub type While_actionValueStmtContext<'input> = BaseParserRuleContext<'input,While_actionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct While_actionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for While_actionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for While_actionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_while_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for While_actionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_while_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_while_actionValueStmt }
}
antlr_rust::type_id!{While_actionValueStmtContextExt<'a>}

impl<'input> While_actionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<While_actionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,While_actionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait While_actionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<While_actionValueStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionValueStmt(&self) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> While_actionValueStmtContextAttrs<'input> for While_actionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn while_actionValueStmt(&mut self,)
	-> Result<Rc<While_actionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = While_actionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_while_actionValueStmt);
        let mut _localctx: Rc<While_actionValueStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1447);
			recog.base.match_token(T__56,&mut recog.err_handler)?;

			recog.base.set_state(1448);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1449);
			recog.expression_rec(0)?;

			recog.base.set_state(1450);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule actionValueStmt*/
			recog.base.set_state(1451);
			recog.actionValueStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- while_moduleStmt ----------------
pub type While_moduleStmtContextAll<'input> = While_moduleStmtContext<'input>;


pub type While_moduleStmtContext<'input> = BaseParserRuleContext<'input,While_moduleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct While_moduleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for While_moduleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for While_moduleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_while_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for While_moduleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_while_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_while_moduleStmt }
}
antlr_rust::type_id!{While_moduleStmtContextExt<'a>}

impl<'input> While_moduleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<While_moduleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,While_moduleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait While_moduleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<While_moduleStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moduleStmt(&self) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> While_moduleStmtContextAttrs<'input> for While_moduleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn while_moduleStmt(&mut self,)
	-> Result<Rc<While_moduleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = While_moduleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_while_moduleStmt);
        let mut _localctx: Rc<While_moduleStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1453);
			recog.base.match_token(T__56,&mut recog.err_handler)?;

			recog.base.set_state(1454);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1455);
			recog.expression_rec(0)?;

			recog.base.set_state(1456);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule moduleStmt*/
			recog.base.set_state(1457);
			recog.moduleStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- while_expressionStmt ----------------
pub type While_expressionStmtContextAll<'input> = While_expressionStmtContext<'input>;


pub type While_expressionStmtContext<'input> = BaseParserRuleContext<'input,While_expressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct While_expressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for While_expressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for While_expressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_while_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for While_expressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_while_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_while_expressionStmt }
}
antlr_rust::type_id!{While_expressionStmtContextExt<'a>}

impl<'input> While_expressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<While_expressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,While_expressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait While_expressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<While_expressionStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> While_expressionStmtContextAttrs<'input> for While_expressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn while_expressionStmt(&mut self,)
	-> Result<Rc<While_expressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = While_expressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_while_expressionStmt);
        let mut _localctx: Rc<While_expressionStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1459);
			recog.base.match_token(T__56,&mut recog.err_handler)?;

			recog.base.set_state(1460);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1461);
			recog.expression_rec(0)?;

			recog.base.set_state(1462);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule expressionStmt*/
			recog.base.set_state(1463);
			recog.expressionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- for_functionBodyStmt ----------------
pub type For_functionBodyStmtContextAll<'input> = For_functionBodyStmtContext<'input>;


pub type For_functionBodyStmtContext<'input> = BaseParserRuleContext<'input,For_functionBodyStmtContextExt<'input>>;

#[derive(Clone)]
pub struct For_functionBodyStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for For_functionBodyStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for For_functionBodyStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_for_functionBodyStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for For_functionBodyStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_for_functionBodyStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_for_functionBodyStmt }
}
antlr_rust::type_id!{For_functionBodyStmtContextExt<'a>}

impl<'input> For_functionBodyStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<For_functionBodyStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,For_functionBodyStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait For_functionBodyStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<For_functionBodyStmtContextExt<'input>>{

fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forTest(&self) -> Option<Rc<ForTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forIncr(&self) -> Option<Rc<ForIncrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBodyStmt(&self) -> Option<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> For_functionBodyStmtContextAttrs<'input> for For_functionBodyStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn for_functionBodyStmt(&mut self,)
	-> Result<Rc<For_functionBodyStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = For_functionBodyStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_for_functionBodyStmt);
        let mut _localctx: Rc<For_functionBodyStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1465);
			recog.base.match_token(T__57,&mut recog.err_handler)?;

			recog.base.set_state(1466);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule forInit*/
			recog.base.set_state(1467);
			recog.forInit()?;

			recog.base.set_state(1468);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forTest*/
			recog.base.set_state(1469);
			recog.forTest()?;

			recog.base.set_state(1470);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forIncr*/
			recog.base.set_state(1471);
			recog.forIncr()?;

			recog.base.set_state(1472);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule functionBodyStmt*/
			recog.base.set_state(1473);
			recog.functionBodyStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- for_actionStmt ----------------
pub type For_actionStmtContextAll<'input> = For_actionStmtContext<'input>;


pub type For_actionStmtContext<'input> = BaseParserRuleContext<'input,For_actionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct For_actionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for For_actionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for For_actionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_for_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for For_actionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_for_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_for_actionStmt }
}
antlr_rust::type_id!{For_actionStmtContextExt<'a>}

impl<'input> For_actionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<For_actionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,For_actionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait For_actionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<For_actionStmtContextExt<'input>>{

fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forTest(&self) -> Option<Rc<ForTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forIncr(&self) -> Option<Rc<ForIncrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionStmt(&self) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> For_actionStmtContextAttrs<'input> for For_actionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn for_actionStmt(&mut self,)
	-> Result<Rc<For_actionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = For_actionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_for_actionStmt);
        let mut _localctx: Rc<For_actionStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1475);
			recog.base.match_token(T__57,&mut recog.err_handler)?;

			recog.base.set_state(1476);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule forInit*/
			recog.base.set_state(1477);
			recog.forInit()?;

			recog.base.set_state(1478);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forTest*/
			recog.base.set_state(1479);
			recog.forTest()?;

			recog.base.set_state(1480);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forIncr*/
			recog.base.set_state(1481);
			recog.forIncr()?;

			recog.base.set_state(1482);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule actionStmt*/
			recog.base.set_state(1483);
			recog.actionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- for_actionValueStmt ----------------
pub type For_actionValueStmtContextAll<'input> = For_actionValueStmtContext<'input>;


pub type For_actionValueStmtContext<'input> = BaseParserRuleContext<'input,For_actionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct For_actionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for For_actionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for For_actionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_for_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for For_actionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_for_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_for_actionValueStmt }
}
antlr_rust::type_id!{For_actionValueStmtContextExt<'a>}

impl<'input> For_actionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<For_actionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,For_actionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait For_actionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<For_actionValueStmtContextExt<'input>>{

fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forTest(&self) -> Option<Rc<ForTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forIncr(&self) -> Option<Rc<ForIncrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionValueStmt(&self) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> For_actionValueStmtContextAttrs<'input> for For_actionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn for_actionValueStmt(&mut self,)
	-> Result<Rc<For_actionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = For_actionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_for_actionValueStmt);
        let mut _localctx: Rc<For_actionValueStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1485);
			recog.base.match_token(T__57,&mut recog.err_handler)?;

			recog.base.set_state(1486);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule forInit*/
			recog.base.set_state(1487);
			recog.forInit()?;

			recog.base.set_state(1488);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forTest*/
			recog.base.set_state(1489);
			recog.forTest()?;

			recog.base.set_state(1490);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forIncr*/
			recog.base.set_state(1491);
			recog.forIncr()?;

			recog.base.set_state(1492);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule actionValueStmt*/
			recog.base.set_state(1493);
			recog.actionValueStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- for_moduleStmt ----------------
pub type For_moduleStmtContextAll<'input> = For_moduleStmtContext<'input>;


pub type For_moduleStmtContext<'input> = BaseParserRuleContext<'input,For_moduleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct For_moduleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for For_moduleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for For_moduleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_for_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for For_moduleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_for_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_for_moduleStmt }
}
antlr_rust::type_id!{For_moduleStmtContextExt<'a>}

impl<'input> For_moduleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<For_moduleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,For_moduleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait For_moduleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<For_moduleStmtContextExt<'input>>{

fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forTest(&self) -> Option<Rc<ForTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forIncr(&self) -> Option<Rc<ForIncrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moduleStmt(&self) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> For_moduleStmtContextAttrs<'input> for For_moduleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn for_moduleStmt(&mut self,)
	-> Result<Rc<For_moduleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = For_moduleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_for_moduleStmt);
        let mut _localctx: Rc<For_moduleStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1495);
			recog.base.match_token(T__57,&mut recog.err_handler)?;

			recog.base.set_state(1496);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule forInit*/
			recog.base.set_state(1497);
			recog.forInit()?;

			recog.base.set_state(1498);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forTest*/
			recog.base.set_state(1499);
			recog.forTest()?;

			recog.base.set_state(1500);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forIncr*/
			recog.base.set_state(1501);
			recog.forIncr()?;

			recog.base.set_state(1502);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule moduleStmt*/
			recog.base.set_state(1503);
			recog.moduleStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- for_expressionStmt ----------------
pub type For_expressionStmtContextAll<'input> = For_expressionStmtContext<'input>;


pub type For_expressionStmtContext<'input> = BaseParserRuleContext<'input,For_expressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct For_expressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for For_expressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for For_expressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_for_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for For_expressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_for_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_for_expressionStmt }
}
antlr_rust::type_id!{For_expressionStmtContextExt<'a>}

impl<'input> For_expressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<For_expressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,For_expressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait For_expressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<For_expressionStmtContextExt<'input>>{

fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forTest(&self) -> Option<Rc<ForTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forIncr(&self) -> Option<Rc<ForIncrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> For_expressionStmtContextAttrs<'input> for For_expressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn for_expressionStmt(&mut self,)
	-> Result<Rc<For_expressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = For_expressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_for_expressionStmt);
        let mut _localctx: Rc<For_expressionStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1505);
			recog.base.match_token(T__57,&mut recog.err_handler)?;

			recog.base.set_state(1506);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule forInit*/
			recog.base.set_state(1507);
			recog.forInit()?;

			recog.base.set_state(1508);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forTest*/
			recog.base.set_state(1509);
			recog.forTest()?;

			recog.base.set_state(1510);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule forIncr*/
			recog.base.set_state(1511);
			recog.forIncr()?;

			recog.base.set_state(1512);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule expressionStmt*/
			recog.base.set_state(1513);
			recog.expressionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleVarDeclAssign ----------------
pub type SimpleVarDeclAssignContextAll<'input> = SimpleVarDeclAssignContext<'input>;


pub type SimpleVarDeclAssignContext<'input> = BaseParserRuleContext<'input,SimpleVarDeclAssignContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleVarDeclAssignContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for SimpleVarDeclAssignContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for SimpleVarDeclAssignContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_simpleVarDeclAssign(self);
	}
}

impl<'input> CustomRuleContext<'input> for SimpleVarDeclAssignContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleVarDeclAssign }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleVarDeclAssign }
}
antlr_rust::type_id!{SimpleVarDeclAssignContextExt<'a>}

impl<'input> SimpleVarDeclAssignContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleVarDeclAssignContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleVarDeclAssignContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleVarDeclAssignContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<SimpleVarDeclAssignContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SimpleVarDeclAssignContextAttrs<'input> for SimpleVarDeclAssignContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleVarDeclAssign(&mut self,)
	-> Result<Rc<SimpleVarDeclAssignContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleVarDeclAssignContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_simpleVarDeclAssign);
        let mut _localctx: Rc<SimpleVarDeclAssignContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1516);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(144,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule data_type*/
					recog.base.set_state(1515);
					recog.data_type()?;

					}
				}

				_ => {}
			}
			/*InvokeRule identifier*/
			recog.base.set_state(1518);
			recog.identifier()?;

			recog.base.set_state(1519);
			recog.base.match_token(T__29,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1520);
			recog.expression_rec(0)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forInit ----------------
pub type ForInitContextAll<'input> = ForInitContext<'input>;


pub type ForInitContext<'input> = BaseParserRuleContext<'input,ForInitContextExt<'input>>;

#[derive(Clone)]
pub struct ForInitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ForInitContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ForInitContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_forInit(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForInitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forInit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forInit }
}
antlr_rust::type_id!{ForInitContextExt<'a>}

impl<'input> ForInitContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForInitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForInitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForInitContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ForInitContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleVarDeclAssign_all(&self) ->  Vec<Rc<SimpleVarDeclAssignContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn simpleVarDeclAssign(&self, i: usize) -> Option<Rc<SimpleVarDeclAssignContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ForInitContextAttrs<'input> for ForInitContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forInit(&mut self,)
	-> Result<Rc<ForInitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForInitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_forInit);
        let mut _localctx: Rc<ForInitContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1523);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(145,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule data_type*/
					recog.base.set_state(1522);
					recog.data_type()?;

					}
				}

				_ => {}
			}
			/*InvokeRule identifier*/
			recog.base.set_state(1525);
			recog.identifier()?;

			recog.base.set_state(1526);
			recog.base.match_token(T__29,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1527);
			recog.expression_rec(0)?;

			recog.base.set_state(1532);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1528);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule simpleVarDeclAssign*/
				recog.base.set_state(1529);
				recog.simpleVarDeclAssign()?;

				}
				}
				recog.base.set_state(1534);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forTest ----------------
pub type ForTestContextAll<'input> = ForTestContext<'input>;


pub type ForTestContext<'input> = BaseParserRuleContext<'input,ForTestContextExt<'input>>;

#[derive(Clone)]
pub struct ForTestContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ForTestContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ForTestContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_forTest(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForTestContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forTest }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forTest }
}
antlr_rust::type_id!{ForTestContextExt<'a>}

impl<'input> ForTestContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForTestContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForTestContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForTestContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ForTestContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForTestContextAttrs<'input> for ForTestContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forTest(&mut self,)
	-> Result<Rc<ForTestContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForTestContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_forTest);
        let mut _localctx: Rc<ForTestContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(1535);
			recog.expression_rec(0)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forIncr ----------------
pub type ForIncrContextAll<'input> = ForIncrContext<'input>;


pub type ForIncrContext<'input> = BaseParserRuleContext<'input,ForIncrContextExt<'input>>;

#[derive(Clone)]
pub struct ForIncrContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ForIncrContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ForIncrContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_forIncr(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForIncrContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forIncr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forIncr }
}
antlr_rust::type_id!{ForIncrContextExt<'a>}

impl<'input> ForIncrContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForIncrContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForIncrContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForIncrContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ForIncrContextExt<'input>>{

fn varIncr_all(&self) ->  Vec<Rc<VarIncrContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn varIncr(&self, i: usize) -> Option<Rc<VarIncrContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ForIncrContextAttrs<'input> for ForIncrContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forIncr(&mut self,)
	-> Result<Rc<ForIncrContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForIncrContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_forIncr);
        let mut _localctx: Rc<ForIncrContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule varIncr*/
			recog.base.set_state(1537);
			recog.varIncr()?;

			recog.base.set_state(1542);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1538);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule varIncr*/
				recog.base.set_state(1539);
				recog.varIncr()?;

				}
				}
				recog.base.set_state(1544);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- varIncr ----------------
pub type VarIncrContextAll<'input> = VarIncrContext<'input>;


pub type VarIncrContext<'input> = BaseParserRuleContext<'input,VarIncrContextExt<'input>>;

#[derive(Clone)]
pub struct VarIncrContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for VarIncrContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for VarIncrContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_varIncr(self);
	}
}

impl<'input> CustomRuleContext<'input> for VarIncrContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_varIncr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_varIncr }
}
antlr_rust::type_id!{VarIncrContextExt<'a>}

impl<'input> VarIncrContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VarIncrContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VarIncrContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VarIncrContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<VarIncrContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VarIncrContextAttrs<'input> for VarIncrContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn varIncr(&mut self,)
	-> Result<Rc<VarIncrContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VarIncrContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_varIncr);
        let mut _localctx: Rc<VarIncrContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1545);
			recog.identifier()?;

			recog.base.set_state(1546);
			recog.base.match_token(T__29,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1547);
			recog.expression_rec(0)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- function_def ----------------
pub type Function_defContextAll<'input> = Function_defContext<'input>;


pub type Function_defContext<'input> = BaseParserRuleContext<'input,Function_defContextExt<'input>>;

#[derive(Clone)]
pub struct Function_defContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Function_defContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Function_defContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_function_def(self);
	}
}

impl<'input> CustomRuleContext<'input> for Function_defContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_function_def }
	//fn type_rule_index() -> usize where Self: Sized { RULE_function_def }
}
antlr_rust::type_id!{Function_defContextExt<'a>}

impl<'input> Function_defContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Function_defContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Function_defContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Function_defContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Function_defContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_proto(&self) -> Option<Rc<Function_protoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_IDENTIFIER
/// Returns `None` if there is no child corresponding to token OPERATOR_IDENTIFIER
fn OPERATOR_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_IDENTIFIER, 0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_formals(&self) -> Option<Rc<Function_formalsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn provisos(&self) -> Option<Rc<ProvisosContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Function_defContextAttrs<'input> for Function_defContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn function_def(&mut self,)
	-> Result<Rc<Function_defContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Function_defContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_function_def);
        let mut _localctx: Rc<Function_defContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1577);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(153,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule attribute_instances*/
					recog.base.set_state(1549);
					recog.attribute_instances()?;

					/*InvokeRule function_proto*/
					recog.base.set_state(1550);
					recog.function_proto()?;

					/*InvokeRule functionBody*/
					recog.base.set_state(1551);
					recog.functionBody()?;

					recog.base.set_state(1552);
					recog.base.match_token(T__58,&mut recog.err_handler)?;

					recog.base.set_state(1555);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__3 {
						{
						recog.base.set_state(1553);
						recog.base.match_token(T__3,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(1554);
						recog.identifier()?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1557);
					recog.base.match_token(T__59,&mut recog.err_handler)?;

					recog.base.set_state(1559);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(149,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule data_type*/
							recog.base.set_state(1558);
							recog.data_type()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1563);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 LOWER_IDENTIFIER 
						=> {
							{
							/*InvokeRule identifier*/
							recog.base.set_state(1561);
							recog.identifier()?;

							}
						}

					 OPERATOR_IDENTIFIER 
						=> {
							{
							recog.base.set_state(1562);
							recog.base.match_token(OPERATOR_IDENTIFIER,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1565);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					recog.base.set_state(1567);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__13 || _la==T__16 || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
						{
						/*InvokeRule function_formals*/
						recog.base.set_state(1566);
						recog.function_formals()?;

						}
					}

					recog.base.set_state(1569);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1571);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__103 {
						{
						/*InvokeRule provisos*/
						recog.base.set_state(1570);
						recog.provisos()?;

						}
					}

					recog.base.set_state(1573);
					recog.base.match_token(T__29,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1574);
					recog.expression_rec(0)?;

					recog.base.set_state(1575);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- function_proto ----------------
pub type Function_protoContextAll<'input> = Function_protoContext<'input>;


pub type Function_protoContext<'input> = BaseParserRuleContext<'input,Function_protoContextExt<'input>>;

#[derive(Clone)]
pub struct Function_protoContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Function_protoContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Function_protoContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_function_proto(self);
	}
}

impl<'input> CustomRuleContext<'input> for Function_protoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_function_proto }
	//fn type_rule_index() -> usize where Self: Sized { RULE_function_proto }
}
antlr_rust::type_id!{Function_protoContextExt<'a>}

impl<'input> Function_protoContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Function_protoContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Function_protoContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Function_protoContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Function_protoContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_IDENTIFIER
/// Returns `None` if there is no child corresponding to token OPERATOR_IDENTIFIER
fn OPERATOR_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_IDENTIFIER, 0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn provisos(&self) -> Option<Rc<ProvisosContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_formals(&self) -> Option<Rc<Function_formalsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Function_protoContextAttrs<'input> for Function_protoContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn function_proto(&mut self,)
	-> Result<Rc<Function_protoContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Function_protoContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_function_proto);
        let mut _localctx: Rc<Function_protoContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1579);
			recog.base.match_token(T__59,&mut recog.err_handler)?;

			recog.base.set_state(1581);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(154,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule data_type*/
					recog.base.set_state(1580);
					recog.data_type()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1585);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LOWER_IDENTIFIER 
				=> {
					{
					/*InvokeRule identifier*/
					recog.base.set_state(1583);
					recog.identifier()?;

					}
				}

			 OPERATOR_IDENTIFIER 
				=> {
					{
					recog.base.set_state(1584);
					recog.base.match_token(OPERATOR_IDENTIFIER,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1592);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__8 {
				{
				recog.base.set_state(1587);
				recog.base.match_token(T__8,&mut recog.err_handler)?;

				recog.base.set_state(1589);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==T__13 || _la==T__16 || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
					{
					/*InvokeRule function_formals*/
					recog.base.set_state(1588);
					recog.function_formals()?;

					}
				}

				recog.base.set_state(1591);
				recog.base.match_token(T__10,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1595);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__103 {
				{
				/*InvokeRule provisos*/
				recog.base.set_state(1594);
				recog.provisos()?;

				}
			}

			recog.base.set_state(1597);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- function_formals ----------------
pub type Function_formalsContextAll<'input> = Function_formalsContext<'input>;


pub type Function_formalsContext<'input> = BaseParserRuleContext<'input,Function_formalsContextExt<'input>>;

#[derive(Clone)]
pub struct Function_formalsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Function_formalsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Function_formalsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_function_formals(self);
	}
}

impl<'input> CustomRuleContext<'input> for Function_formalsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_function_formals }
	//fn type_rule_index() -> usize where Self: Sized { RULE_function_formals }
}
antlr_rust::type_id!{Function_formalsContextExt<'a>}

impl<'input> Function_formalsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Function_formalsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Function_formalsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Function_formalsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Function_formalsContextExt<'input>>{

fn functionFormal_all(&self) ->  Vec<Rc<FunctionFormalContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionFormal(&self, i: usize) -> Option<Rc<FunctionFormalContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Function_formalsContextAttrs<'input> for Function_formalsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn function_formals(&mut self,)
	-> Result<Rc<Function_formalsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Function_formalsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_function_formals);
        let mut _localctx: Rc<Function_formalsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule functionFormal*/
			recog.base.set_state(1599);
			recog.functionFormal()?;

			recog.base.set_state(1604);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1600);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule functionFormal*/
				recog.base.set_state(1601);
				recog.functionFormal()?;

				}
				}
				recog.base.set_state(1606);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionFormal ----------------
pub type FunctionFormalContextAll<'input> = FunctionFormalContext<'input>;


pub type FunctionFormalContext<'input> = BaseParserRuleContext<'input,FunctionFormalContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionFormalContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for FunctionFormalContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for FunctionFormalContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionFormal(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionFormalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionFormal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionFormal }
}
antlr_rust::type_id!{FunctionFormalContextExt<'a>}

impl<'input> FunctionFormalContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionFormalContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionFormalContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionFormalContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<FunctionFormalContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_formals(&self) -> Option<Rc<Function_formalsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionFormalContextAttrs<'input> for FunctionFormalContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionFormal(&mut self,)
	-> Result<Rc<FunctionFormalContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionFormalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_functionFormal);
        let mut _localctx: Rc<FunctionFormalContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1608);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(160,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule data_type*/
					recog.base.set_state(1607);
					recog.data_type()?;

					}
				}

				_ => {}
			}
			/*InvokeRule identifier*/
			recog.base.set_state(1610);
			recog.identifier()?;

			recog.base.set_state(1616);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__8 {
				{
				recog.base.set_state(1611);
				recog.base.match_token(T__8,&mut recog.err_handler)?;

				recog.base.set_state(1613);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==T__13 || _la==T__16 || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
					{
					/*InvokeRule function_formals*/
					recog.base.set_state(1612);
					recog.function_formals()?;

					}
				}

				recog.base.set_state(1615);
				recog.base.match_token(T__10,&mut recog.err_handler)?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionBody ----------------
pub type FunctionBodyContextAll<'input> = FunctionBodyContext<'input>;


pub type FunctionBodyContext<'input> = BaseParserRuleContext<'input,FunctionBodyContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for FunctionBodyContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for FunctionBodyContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionBody }
}
antlr_rust::type_id!{FunctionBodyContextExt<'a>}

impl<'input> FunctionBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionBodyContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<FunctionBodyContextExt<'input>>{

fn actionBlock(&self) -> Option<Rc<ActionBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionValueBlock(&self) -> Option<Rc<ActionValueBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBodyStmt_all(&self) ->  Vec<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionBodyStmt(&self, i: usize) -> Option<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> FunctionBodyContextAttrs<'input> for FunctionBodyContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionBody(&mut self,)
	-> Result<Rc<FunctionBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_functionBody);
        let mut _localctx: Rc<FunctionBodyContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1626);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__94 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule actionBlock*/
					recog.base.set_state(1618);
					recog.actionBlock()?;

					}
				}

			 T__96 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule actionValueBlock*/
					recog.base.set_state(1619);
					recog.actionValueBlock()?;

					}
				}

			 T__13 | T__16 | T__28 | T__30 | T__41 | T__42 | T__49 | T__52 | T__56 |
			 T__57 | T__58 | T__59 | T__60 | T__101 | UPPER_IDENTIFIER | LOWER_IDENTIFIER |
			 INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1623);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__30) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__60))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
						{
						{
						/*InvokeRule functionBodyStmt*/
						recog.base.set_state(1620);
						recog.functionBodyStmt()?;

						}
						}
						recog.base.set_state(1625);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionBodyStmt ----------------
pub type FunctionBodyStmtContextAll<'input> = FunctionBodyStmtContext<'input>;


pub type FunctionBodyStmtContext<'input> = BaseParserRuleContext<'input,FunctionBodyStmtContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionBodyStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for FunctionBodyStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for FunctionBodyStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionBodyStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionBodyStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionBodyStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionBodyStmt }
}
antlr_rust::type_id!{FunctionBodyStmtContextExt<'a>}

impl<'input> FunctionBodyStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionBodyStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionBodyStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionBodyStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<FunctionBodyStmtContextExt<'input>>{

fn returnStmt(&self) -> Option<Rc<ReturnStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionBodyStmtContextAttrs<'input> for FunctionBodyStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionBodyStmt(&mut self,)
	-> Result<Rc<FunctionBodyStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionBodyStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_functionBodyStmt);
        let mut _localctx: Rc<FunctionBodyStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1630);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__60 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule returnStmt*/
					recog.base.set_state(1628);
					recog.returnStmt()?;

					}
				}

			 T__13 | T__16 | T__30 | T__41 | T__42 | T__49 | T__52 | T__56 | T__57 |
			 T__59 | T__101 | UPPER_IDENTIFIER | LOWER_IDENTIFIER | INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expressionStmt*/
					recog.base.set_state(1629);
					recog.expressionStmt()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnStmt ----------------
pub type ReturnStmtContextAll<'input> = ReturnStmtContext<'input>;


pub type ReturnStmtContext<'input> = BaseParserRuleContext<'input,ReturnStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ReturnStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ReturnStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_returnStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReturnStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnStmt }
}
antlr_rust::type_id!{ReturnStmtContextExt<'a>}

impl<'input> ReturnStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ReturnStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReturnStmtContextAttrs<'input> for ReturnStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnStmt(&mut self,)
	-> Result<Rc<ReturnStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_returnStmt);
        let mut _localctx: Rc<ReturnStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1632);
			recog.base.match_token(T__60,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1633);
			recog.expression_rec(0)?;

			recog.base.set_state(1634);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expression ----------------
#[derive(Debug)]
pub enum ExpressionContextAll<'input>{
	OperatorexprContext(OperatorexprContext<'input>),
	CaseexprContext(CaseexprContext<'input>),
	CondExprContext(CondExprContext<'input>),
	MatchesexprContext(MatchesexprContext<'input>),
Error(ExpressionContext<'input>)
}
antlr_rust::type_id!{ExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ExpressionContextAll<'input>{}

impl<'input> BSVParserContext<'input> for ExpressionContextAll<'input>{}

impl<'input> Deref for ExpressionContextAll<'input>{
	type Target = dyn ExpressionContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use ExpressionContextAll::*;
		match self{
			OperatorexprContext(inner) => inner,
			CaseexprContext(inner) => inner,
			CondExprContext(inner) => inner,
			MatchesexprContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExpressionContextAll<'input>{
    fn enter(&self, listener: &mut (dyn BSVListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn BSVListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type ExpressionContext<'input> = BaseParserRuleContext<'input,ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExpressionContext<'input>{
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::type_id!{ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionContextAll<'input>> {
		Rc::new(
		ExpressionContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait ExpressionContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>{


}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input>{}

pub type OperatorexprContext<'input> = BaseParserRuleContext<'input,OperatorexprContextExt<'input>>;

pub trait OperatorexprContextAttrs<'input>: BSVParserContext<'input>{
	fn binopexpr(&self) -> Option<Rc<BinopexprContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> OperatorexprContextAttrs<'input> for OperatorexprContext<'input>{}

pub struct OperatorexprContextExt<'input>{
	base:ExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{OperatorexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for OperatorexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for OperatorexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_operatorexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for OperatorexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for OperatorexprContext<'input>{
	fn borrow(&self) -> &ExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for OperatorexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ExpressionContextAttrs<'input> for OperatorexprContext<'input> {}

impl<'input> OperatorexprContextExt<'input>{
	fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>>  {
		Rc::new(
			ExpressionContextAll::OperatorexprContext(
				BaseParserRuleContext::copy_from(ctx,OperatorexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CaseexprContext<'input> = BaseParserRuleContext<'input,CaseexprContextExt<'input>>;

pub trait CaseexprContextAttrs<'input>: BSVParserContext<'input>{
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn caseexprdefaultitem(&self) -> Option<Rc<CaseexprdefaultitemContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn caseexpritem_all(&self) ->  Vec<Rc<CaseexpritemContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn caseexpritem(&self, i: usize) -> Option<Rc<CaseexpritemContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn caseexprpatitem_all(&self) ->  Vec<Rc<CaseexprpatitemContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn caseexprpatitem(&self, i: usize) -> Option<Rc<CaseexprpatitemContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> CaseexprContextAttrs<'input> for CaseexprContext<'input>{}

pub struct CaseexprContextExt<'input>{
	base:ExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{CaseexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for CaseexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for CaseexprContext<'input>{
	fn borrow(&self) -> &ExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for CaseexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ExpressionContextAttrs<'input> for CaseexprContext<'input> {}

impl<'input> CaseexprContextExt<'input>{
	fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>>  {
		Rc::new(
			ExpressionContextAll::CaseexprContext(
				BaseParserRuleContext::copy_from(ctx,CaseexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CondExprContext<'input> = BaseParserRuleContext<'input,CondExprContextExt<'input>>;

pub trait CondExprContextAttrs<'input>: BSVParserContext<'input>{
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> CondExprContextAttrs<'input> for CondExprContext<'input>{}

pub struct CondExprContextExt<'input>{
	base:ExpressionContextExt<'input>,
	pub pred: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{CondExprContextExt<'a>}

impl<'input> BSVParserContext<'input> for CondExprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CondExprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_condExpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for CondExprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for CondExprContext<'input>{
	fn borrow(&self) -> &ExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for CondExprContext<'input>{
	fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ExpressionContextAttrs<'input> for CondExprContext<'input> {}

impl<'input> CondExprContextExt<'input>{
	fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>>  {
		Rc::new(
			ExpressionContextAll::CondExprContext(
				BaseParserRuleContext::copy_from(ctx,CondExprContextExt{
        			pred:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type MatchesexprContext<'input> = BaseParserRuleContext<'input,MatchesexprContextExt<'input>>;

pub trait MatchesexprContextAttrs<'input>: BSVParserContext<'input>{
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn patterncond_all(&self) ->  Vec<Rc<PatterncondContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn patterncond(&self, i: usize) -> Option<Rc<PatterncondContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> MatchesexprContextAttrs<'input> for MatchesexprContext<'input>{}

pub struct MatchesexprContextExt<'input>{
	base:ExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{MatchesexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for MatchesexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MatchesexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_matchesexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for MatchesexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for MatchesexprContext<'input>{
	fn borrow(&self) -> &ExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for MatchesexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ExpressionContextAttrs<'input> for MatchesexprContext<'input> {}

impl<'input> MatchesexprContextExt<'input>{
	fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>>  {
		Rc::new(
			ExpressionContextAll::MatchesexprContext(
				BaseParserRuleContext::copy_from(ctx,MatchesexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  expression(&mut self,)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		self.expression_rec(0)
	}

	fn expression_rec(&mut self, _p: isize)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 208, RULE_expression, _p);
	    let mut _localctx: Rc<ExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 208;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1661);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__52 
				=> {
					{
					let mut tmp = CaseexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();


					recog.base.set_state(1637);
					recog.base.match_token(T__52,&mut recog.err_handler)?;

					recog.base.set_state(1638);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1639);
					recog.expression_rec(0)?;

					recog.base.set_state(1640);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(1653);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 T__54 
						=> {
							{
							{
							recog.base.set_state(1641);
							recog.base.match_token(T__54,&mut recog.err_handler)?;

							recog.base.set_state(1643); 
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							loop {
								{
								{
								/*InvokeRule caseexprpatitem*/
								recog.base.set_state(1642);
								recog.caseexprpatitem()?;

								}
								}
								recog.base.set_state(1645); 
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
								if !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__35) | (1usize << T__39) | (1usize << T__45))) != 0) || ((((_la - 101)) & !0x3f) == 0 && ((1usize << (_la - 101)) & ((1usize << (T__100 - 101)) | (1usize << (UPPER_IDENTIFIER - 101)) | (1usize << (STRING_LITERAL - 101)) | (1usize << (INT_LITERAL - 101)) | (1usize << (REAL_LITERAL - 101)))) != 0)) {break}
							}
							}
							}
						}

					 T__8 | T__13 | T__16 | T__17 | T__35 | T__39 | T__49 | T__52 | T__53 |
					 T__55 | T__61 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 |
					 T__70 | T__71 | T__72 | T__73 | T__87 | T__88 | T__90 | T__91 | T__92 |
					 UPPER_IDENTIFIER | LOWER_IDENTIFIER | SYSTEM_TASK | STRING_LITERAL |
					 INT_LITERAL | REAL_LITERAL 
						=> {
							{
							recog.base.set_state(1650);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
								{
								{
								/*InvokeRule caseexpritem*/
								recog.base.set_state(1647);
								recog.caseexpritem()?;

								}
								}
								recog.base.set_state(1652);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1656);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__55 {
						{
						/*InvokeRule caseexprdefaultitem*/
						recog.base.set_state(1655);
						recog.caseexprdefaultitem()?;

						}
					}

					recog.base.set_state(1658);
					recog.base.match_token(T__53,&mut recog.err_handler)?;

					}
				}

			 T__8 | T__13 | T__16 | T__17 | T__35 | T__39 | T__49 | T__61 | T__63 |
			 T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 |
			 T__73 | T__87 | T__88 | T__90 | T__91 | T__92 | UPPER_IDENTIFIER | LOWER_IDENTIFIER |
			 SYSTEM_TASK | STRING_LITERAL | INT_LITERAL | REAL_LITERAL 
				=> {
					{
					let mut tmp = OperatorexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule binopexpr*/
					recog.base.set_state(1660);
					recog.binopexpr_rec(0)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(1680);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(173,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(1678);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(172,&mut recog.base)? {
						1 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = CondExprContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let ExpressionContextAll::CondExprContext(ctx) = cast_mut::<_,ExpressionContextAll >(&mut tmp){
								ctx.pred = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
							_localctx = tmp;
							recog.base.set_state(1663);
							if !({recog.precpred(None, 4)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 4)".to_owned()), None))?;
							}
							recog.base.set_state(1664);
							recog.base.match_token(T__61,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(1665);
							recog.expression_rec(0)?;

							recog.base.set_state(1666);
							recog.base.match_token(T__3,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(1667);
							recog.expression_rec(5)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = MatchesexprContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
							_localctx = tmp;
							recog.base.set_state(1669);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(1670);
							recog.base.match_token(T__54,&mut recog.err_handler)?;

							/*InvokeRule pattern*/
							recog.base.set_state(1671);
							recog.pattern()?;

							recog.base.set_state(1675);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(171,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									/*InvokeRule patterncond*/
									recog.base.set_state(1672);
									recog.patterncond()?;

									}
									} 
								}
								recog.base.set_state(1677);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(171,&mut recog.base)?;
							}
							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(1682);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(173,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- caseexprpatitem ----------------
pub type CaseexprpatitemContextAll<'input> = CaseexprpatitemContext<'input>;


pub type CaseexprpatitemContext<'input> = BaseParserRuleContext<'input,CaseexprpatitemContextExt<'input>>;

#[derive(Clone)]
pub struct CaseexprpatitemContextExt<'input>{
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseexprpatitemContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseexprpatitemContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseexprpatitem(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseexprpatitemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseexprpatitem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseexprpatitem }
}
antlr_rust::type_id!{CaseexprpatitemContextExt<'a>}

impl<'input> CaseexprpatitemContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseexprpatitemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseexprpatitemContextExt{
				body: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseexprpatitemContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseexprpatitemContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn patterncond_all(&self) ->  Vec<Rc<PatterncondContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn patterncond(&self, i: usize) -> Option<Rc<PatterncondContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CaseexprpatitemContextAttrs<'input> for CaseexprpatitemContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseexprpatitem(&mut self,)
	-> Result<Rc<CaseexprpatitemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseexprpatitemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_caseexprpatitem);
        let mut _localctx: Rc<CaseexprpatitemContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule pattern*/
			recog.base.set_state(1683);
			recog.pattern()?;

			recog.base.set_state(1687);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__62 {
				{
				{
				/*InvokeRule patterncond*/
				recog.base.set_state(1684);
				recog.patterncond()?;

				}
				}
				recog.base.set_state(1689);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			recog.base.set_state(1690);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1691);
			let tmp = recog.expression_rec(0)?;
			 cast_mut::<_,CaseexprpatitemContext >(&mut _localctx).body = Some(tmp.clone());
			  

			recog.base.set_state(1692);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseexpritem ----------------
pub type CaseexpritemContextAll<'input> = CaseexpritemContext<'input>;


pub type CaseexpritemContext<'input> = BaseParserRuleContext<'input,CaseexpritemContextExt<'input>>;

#[derive(Clone)]
pub struct CaseexpritemContextExt<'input>{
	pub match_: Option<Rc<ExpressionContextAll<'input>>>,
	pub altmatches: Option<Rc<ExpressionContextAll<'input>>>,
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseexpritemContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseexpritemContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseexpritem(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseexpritemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseexpritem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseexpritem }
}
antlr_rust::type_id!{CaseexpritemContextExt<'a>}

impl<'input> CaseexpritemContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseexpritemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseexpritemContextExt{
				match_: None, altmatches: None, body: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseexpritemContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseexpritemContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CaseexpritemContextAttrs<'input> for CaseexpritemContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseexpritem(&mut self,)
	-> Result<Rc<CaseexpritemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseexpritemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_caseexpritem);
        let mut _localctx: Rc<CaseexpritemContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(1694);
			let tmp = recog.expression_rec(0)?;
			 cast_mut::<_,CaseexpritemContext >(&mut _localctx).match_ = Some(tmp.clone());
			  

			recog.base.set_state(1699);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1695);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(1696);
				let tmp = recog.expression_rec(0)?;
				 cast_mut::<_,CaseexpritemContext >(&mut _localctx).altmatches = Some(tmp.clone());
				  

				}
				}
				recog.base.set_state(1701);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1702);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1703);
			let tmp = recog.expression_rec(0)?;
			 cast_mut::<_,CaseexpritemContext >(&mut _localctx).body = Some(tmp.clone());
			  

			recog.base.set_state(1704);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseexprdefaultitem ----------------
pub type CaseexprdefaultitemContextAll<'input> = CaseexprdefaultitemContext<'input>;


pub type CaseexprdefaultitemContext<'input> = BaseParserRuleContext<'input,CaseexprdefaultitemContextExt<'input>>;

#[derive(Clone)]
pub struct CaseexprdefaultitemContextExt<'input>{
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseexprdefaultitemContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseexprdefaultitemContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseexprdefaultitem(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseexprdefaultitemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseexprdefaultitem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseexprdefaultitem }
}
antlr_rust::type_id!{CaseexprdefaultitemContextExt<'a>}

impl<'input> CaseexprdefaultitemContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseexprdefaultitemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseexprdefaultitemContextExt{
				body: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseexprdefaultitemContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseexprdefaultitemContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CaseexprdefaultitemContextAttrs<'input> for CaseexprdefaultitemContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseexprdefaultitem(&mut self,)
	-> Result<Rc<CaseexprdefaultitemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseexprdefaultitemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_caseexprdefaultitem);
        let mut _localctx: Rc<CaseexprdefaultitemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1706);
			recog.base.match_token(T__55,&mut recog.err_handler)?;

			recog.base.set_state(1707);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1708);
			let tmp = recog.expression_rec(0)?;
			 cast_mut::<_,CaseexprdefaultitemContext >(&mut _localctx).body = Some(tmp.clone());
			  

			recog.base.set_state(1709);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- patterncond ----------------
pub type PatterncondContextAll<'input> = PatterncondContext<'input>;


pub type PatterncondContext<'input> = BaseParserRuleContext<'input,PatterncondContextExt<'input>>;

#[derive(Clone)]
pub struct PatterncondContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for PatterncondContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for PatterncondContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_patterncond(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatterncondContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patterncond }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patterncond }
}
antlr_rust::type_id!{PatterncondContextExt<'a>}

impl<'input> PatterncondContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PatterncondContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PatterncondContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PatterncondContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<PatterncondContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PatterncondContextAttrs<'input> for PatterncondContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn patterncond(&mut self,)
	-> Result<Rc<PatterncondContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PatterncondContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_patterncond);
        let mut _localctx: Rc<PatterncondContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(1711);
			recog.base.match_token(T__62,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1712);
			recog.expression_rec(0)?;

			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unary_operator ----------------
pub type Unary_operatorContextAll<'input> = Unary_operatorContext<'input>;


pub type Unary_operatorContext<'input> = BaseParserRuleContext<'input,Unary_operatorContextExt<'input>>;

#[derive(Clone)]
pub struct Unary_operatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Unary_operatorContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Unary_operatorContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unary_operator(self);
	}
}

impl<'input> CustomRuleContext<'input> for Unary_operatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unary_operator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unary_operator }
}
antlr_rust::type_id!{Unary_operatorContextExt<'a>}

impl<'input> Unary_operatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Unary_operatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Unary_operatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Unary_operatorContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Unary_operatorContextExt<'input>>{


}

impl<'input> Unary_operatorContextAttrs<'input> for Unary_operatorContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unary_operator(&mut self,)
	-> Result<Rc<Unary_operatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Unary_operatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_unary_operator);
        let mut _localctx: Rc<Unary_operatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1714);
			_la = recog.base.input.la(1);
			if { !(((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- binary_operator ----------------
pub type Binary_operatorContextAll<'input> = Binary_operatorContext<'input>;


pub type Binary_operatorContext<'input> = BaseParserRuleContext<'input,Binary_operatorContextExt<'input>>;

#[derive(Clone)]
pub struct Binary_operatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Binary_operatorContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Binary_operatorContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_binary_operator(self);
	}
}

impl<'input> CustomRuleContext<'input> for Binary_operatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_binary_operator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_binary_operator }
}
antlr_rust::type_id!{Binary_operatorContextExt<'a>}

impl<'input> Binary_operatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Binary_operatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Binary_operatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Binary_operatorContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Binary_operatorContextExt<'input>>{


}

impl<'input> Binary_operatorContextAttrs<'input> for Binary_operatorContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn binary_operator(&mut self,)
	-> Result<Rc<Binary_operatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Binary_operatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_binary_operator);
        let mut _localctx: Rc<Binary_operatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1716);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__7) | (1usize << T__48) | (1usize << T__62))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__74 - 64)) | (1usize << (T__75 - 64)) | (1usize << (T__76 - 64)) | (1usize << (T__77 - 64)) | (1usize << (T__78 - 64)) | (1usize << (T__79 - 64)) | (1usize << (T__80 - 64)) | (1usize << (T__81 - 64)) | (1usize << (T__82 - 64)) | (1usize << (T__83 - 64)) | (1usize << (T__84 - 64)) | (1usize << (T__85 - 64)) | (1usize << (T__86 - 64)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- binopexpr ----------------
pub type BinopexprContextAll<'input> = BinopexprContext<'input>;


pub type BinopexprContext<'input> = BaseParserRuleContext<'input,BinopexprContextExt<'input>>;

#[derive(Clone)]
pub struct BinopexprContextExt<'input>{
	pub left: Option<Rc<BinopexprContextAll<'input>>>,
	pub op: Option<Rc<Binary_operatorContextAll<'input>>>,
	pub right: Option<Rc<BinopexprContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for BinopexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BinopexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_binopexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for BinopexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_binopexpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_binopexpr }
}
antlr_rust::type_id!{BinopexprContextExt<'a>}

impl<'input> BinopexprContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BinopexprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BinopexprContextExt{
				left: None, op: None, right: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait BinopexprContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<BinopexprContextExt<'input>>{

fn unopexpr(&self) -> Option<Rc<UnopexprContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn binopexpr_all(&self) ->  Vec<Rc<BinopexprContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn binopexpr(&self, i: usize) -> Option<Rc<BinopexprContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn binary_operator(&self) -> Option<Rc<Binary_operatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BinopexprContextAttrs<'input> for BinopexprContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  binopexpr(&mut self,)
	-> Result<Rc<BinopexprContextAll<'input>>,ANTLRError> {
		self.binopexpr_rec(0)
	}

	fn binopexpr_rec(&mut self, _p: isize)
	-> Result<Rc<BinopexprContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = BinopexprContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 222, RULE_binopexpr, _p);
	    let mut _localctx: Rc<BinopexprContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 222;
		let result: Result<(), ANTLRError> = try {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule unopexpr*/
			recog.base.set_state(1719);
			recog.unopexpr()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(1727);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(176,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = BinopexprContextExt::new(_parentctx.clone(), _parentState);
					(cast_mut::<_,BinopexprContext>(&mut tmp)).left = Some(_prevctx.clone());
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_binopexpr);
					_localctx = tmp;
					recog.base.set_state(1721);
					if !({recog.precpred(None, 2)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
					}
					/*InvokeRule binary_operator*/
					recog.base.set_state(1722);
					let tmp = recog.binary_operator()?;
					 cast_mut::<_,BinopexprContext >(&mut _localctx).op = Some(tmp.clone());
					  

					/*InvokeRule binopexpr*/
					recog.base.set_state(1723);
					let tmp = recog.binopexpr_rec(3)?;
					 cast_mut::<_,BinopexprContext >(&mut _localctx).right = Some(tmp.clone());
					  

					}
					} 
				}
				recog.base.set_state(1729);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(176,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- unopexpr ----------------
pub type UnopexprContextAll<'input> = UnopexprContext<'input>;


pub type UnopexprContext<'input> = BaseParserRuleContext<'input,UnopexprContextExt<'input>>;

#[derive(Clone)]
pub struct UnopexprContextExt<'input>{
	pub op: Option<TokenType<'input>>,
	pub right: Option<Rc<Primary_expressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for UnopexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for UnopexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unopexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnopexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unopexpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unopexpr }
}
antlr_rust::type_id!{UnopexprContextExt<'a>}

impl<'input> UnopexprContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnopexprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnopexprContextExt{
				op: None, 
				right: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait UnopexprContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<UnopexprContextExt<'input>>{

fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnopexprContextAttrs<'input> for UnopexprContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unopexpr(&mut self,)
	-> Result<Rc<UnopexprContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnopexprContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_unopexpr);
        let mut _localctx: Rc<UnopexprContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1735);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(177,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1730);
					 cast_mut::<_,UnopexprContext >(&mut _localctx).op = recog.base.input.lt(1).cloned();
					 
					_la = recog.base.input.la(1);
					if { !(((((_la - 66)) & !0x3f) == 0 && ((1usize << (_la - 66)) & ((1usize << (T__65 - 66)) | (1usize << (T__66 - 66)) | (1usize << (T__67 - 66)) | (1usize << (T__68 - 66)) | (1usize << (T__69 - 66)) | (1usize << (T__70 - 66)) | (1usize << (T__71 - 66)) | (1usize << (T__72 - 66)) | (1usize << (T__73 - 66)))) != 0)) } {
						let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
						 cast_mut::<_,UnopexprContext >(&mut _localctx).op = Some(tmp.clone());
						  

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule primary_expression*/
					recog.base.set_state(1731);
					recog.primary_expression_rec(0)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1732);
					 cast_mut::<_,UnopexprContext >(&mut _localctx).op = recog.base.input.lt(1).cloned();
					 
					_la = recog.base.input.la(1);
					if { !(_la==T__63 || _la==T__64) } {
						let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
						 cast_mut::<_,UnopexprContext >(&mut _localctx).op = Some(tmp.clone());
						  

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule primary_expression*/
					recog.base.set_state(1733);
					let tmp = recog.primary_expression_rec(0)?;
					 cast_mut::<_,UnopexprContext >(&mut _localctx).right = Some(tmp.clone());
					  

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule primary_expression*/
					recog.base.set_state(1734);
					recog.primary_expression_rec(0)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constant_expression ----------------
pub type Constant_expressionContextAll<'input> = Constant_expressionContext<'input>;


pub type Constant_expressionContext<'input> = BaseParserRuleContext<'input,Constant_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Constant_expressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Constant_expressionContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Constant_expressionContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_constant_expression(self);
	}
}

impl<'input> CustomRuleContext<'input> for Constant_expressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant_expression }
}
antlr_rust::type_id!{Constant_expressionContextExt<'a>}

impl<'input> Constant_expressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Constant_expressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Constant_expressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Constant_expressionContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Constant_expressionContextExt<'input>>{

fn constant_primary(&self) -> Option<Rc<Constant_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unary_operator(&self) -> Option<Rc<Unary_operatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constant_expression_all(&self) ->  Vec<Rc<Constant_expressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constant_expression(&self, i: usize) -> Option<Rc<Constant_expressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn binary_operator(&self) -> Option<Rc<Binary_operatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Constant_expressionContextAttrs<'input> for Constant_expressionContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  constant_expression(&mut self,)
	-> Result<Rc<Constant_expressionContextAll<'input>>,ANTLRError> {
		self.constant_expression_rec(0)
	}

	fn constant_expression_rec(&mut self, _p: isize)
	-> Result<Rc<Constant_expressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = Constant_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 226, RULE_constant_expression, _p);
	    let mut _localctx: Rc<Constant_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 226;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(1739);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)))) != 0) {
				{
				/*InvokeRule unary_operator*/
				recog.base.set_state(1738);
				recog.unary_operator()?;

				}
			}

			/*InvokeRule constant_primary*/
			recog.base.set_state(1741);
			recog.constant_primary()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(1755);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(180,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(1753);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(179,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = Constant_expressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_constant_expression);
							_localctx = tmp;
							recog.base.set_state(1743);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							/*InvokeRule binary_operator*/
							recog.base.set_state(1744);
							recog.binary_operator()?;

							/*InvokeRule constant_expression*/
							recog.base.set_state(1745);
							recog.constant_expression_rec(3)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = Constant_expressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_constant_expression);
							_localctx = tmp;
							recog.base.set_state(1747);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(1748);
							recog.base.match_token(T__61,&mut recog.err_handler)?;

							/*InvokeRule constant_expression*/
							recog.base.set_state(1749);
							recog.constant_expression_rec(0)?;

							recog.base.set_state(1750);
							recog.base.match_token(T__3,&mut recog.err_handler)?;

							/*InvokeRule constant_expression*/
							recog.base.set_state(1751);
							recog.constant_expression_rec(2)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(1757);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(180,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- constant_primary ----------------
pub type Constant_primaryContextAll<'input> = Constant_primaryContext<'input>;


pub type Constant_primaryContext<'input> = BaseParserRuleContext<'input,Constant_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct Constant_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Constant_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Constant_primaryContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_constant_primary(self);
	}
}

impl<'input> CustomRuleContext<'input> for Constant_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant_primary }
}
antlr_rust::type_id!{Constant_primaryContextExt<'a>}

impl<'input> Constant_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Constant_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Constant_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Constant_primaryContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Constant_primaryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INT_LITERAL
/// Returns `None` if there is no child corresponding to token INT_LITERAL
fn INT_LITERAL(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(INT_LITERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token REAL_LITERAL
/// Returns `None` if there is no child corresponding to token REAL_LITERAL
fn REAL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(REAL_LITERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token STRING_LITERAL
/// Returns `None` if there is no child corresponding to token STRING_LITERAL
fn STRING_LITERAL(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(STRING_LITERAL, 0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Constant_primaryContextAttrs<'input> for Constant_primaryContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constant_primary(&mut self,)
	-> Result<Rc<Constant_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Constant_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_constant_primary);
        let mut _localctx: Rc<Constant_primaryContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1767);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1758);
					recog.base.match_token(INT_LITERAL,&mut recog.err_handler)?;

					}
				}

			 REAL_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1759);
					recog.base.match_token(REAL_LITERAL,&mut recog.err_handler)?;

					}
				}

			 STRING_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1760);
					recog.base.match_token(STRING_LITERAL,&mut recog.err_handler)?;

					}
				}

			 T__61 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1761);
					recog.base.match_token(T__61,&mut recog.err_handler)?;

					}
				}

			 T__87 | T__88 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1762);
					_la = recog.base.input.la(1);
					if { !(_la==T__87 || _la==T__88) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(1763);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule data_type*/
					recog.base.set_state(1764);
					recog.data_type()?;

					recog.base.set_state(1765);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- bit_concatination ----------------
pub type Bit_concatinationContextAll<'input> = Bit_concatinationContext<'input>;


pub type Bit_concatinationContext<'input> = BaseParserRuleContext<'input,Bit_concatinationContextExt<'input>>;

#[derive(Clone)]
pub struct Bit_concatinationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Bit_concatinationContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Bit_concatinationContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_bit_concatination(self);
	}
}

impl<'input> CustomRuleContext<'input> for Bit_concatinationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_bit_concatination }
	//fn type_rule_index() -> usize where Self: Sized { RULE_bit_concatination }
}
antlr_rust::type_id!{Bit_concatinationContextExt<'a>}

impl<'input> Bit_concatinationContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Bit_concatinationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Bit_concatinationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Bit_concatinationContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Bit_concatinationContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Bit_concatinationContextAttrs<'input> for Bit_concatinationContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn bit_concatination(&mut self,)
	-> Result<Rc<Bit_concatinationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Bit_concatinationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_bit_concatination);
        let mut _localctx: Rc<Bit_concatinationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1769);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1770);
			recog.expression_rec(0)?;

			recog.base.set_state(1775);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1771);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(1772);
				recog.expression_rec(0)?;

				}
				}
				recog.base.set_state(1777);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1778);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primary_expression ----------------
#[derive(Debug)]
pub enum Primary_expressionContextAll<'input>{
	BitconcatContext(BitconcatContext<'input>),
	WhenexprContext(WhenexprContext<'input>),
	VarexprContext(VarexprContext<'input>),
	InterfaceexprContext(InterfaceexprContext<'input>),
	BlockexprContext(BlockexprContext<'input>),
	ConstexprContext(ConstexprContext<'input>),
	SyscallexprContext(SyscallexprContext<'input>),
	CallexprContext(CallexprContext<'input>),
	CastexprContext(CastexprContext<'input>),
	TypeassertionexprContext(TypeassertionexprContext<'input>),
	BitselectContext(BitselectContext<'input>),
	ResetbyexprContext(ResetbyexprContext<'input>),
	TaggedunionexprContext(TaggedunionexprContext<'input>),
	ClockedbyexprContext(ClockedbyexprContext<'input>),
	FieldexprContext(FieldexprContext<'input>),
	ParenexprContext(ParenexprContext<'input>),
Error(Primary_expressionContext<'input>)
}
antlr_rust::type_id!{Primary_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Primary_expressionContextAll<'input>{}

impl<'input> BSVParserContext<'input> for Primary_expressionContextAll<'input>{}

impl<'input> Deref for Primary_expressionContextAll<'input>{
	type Target = dyn Primary_expressionContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use Primary_expressionContextAll::*;
		match self{
			BitconcatContext(inner) => inner,
			WhenexprContext(inner) => inner,
			VarexprContext(inner) => inner,
			InterfaceexprContext(inner) => inner,
			BlockexprContext(inner) => inner,
			ConstexprContext(inner) => inner,
			SyscallexprContext(inner) => inner,
			CallexprContext(inner) => inner,
			CastexprContext(inner) => inner,
			TypeassertionexprContext(inner) => inner,
			BitselectContext(inner) => inner,
			ResetbyexprContext(inner) => inner,
			TaggedunionexprContext(inner) => inner,
			ClockedbyexprContext(inner) => inner,
			FieldexprContext(inner) => inner,
			ParenexprContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Primary_expressionContextAll<'input>{
    fn enter(&self, listener: &mut (dyn BSVListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn BSVListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type Primary_expressionContext<'input> = BaseParserRuleContext<'input,Primary_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Primary_expressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Primary_expressionContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Primary_expressionContext<'input>{
}

impl<'input> CustomRuleContext<'input> for Primary_expressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}
antlr_rust::type_id!{Primary_expressionContextExt<'a>}

impl<'input> Primary_expressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Primary_expressionContextAll<'input>> {
		Rc::new(
		Primary_expressionContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Primary_expressionContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait Primary_expressionContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Primary_expressionContextExt<'input>>{


}

impl<'input> Primary_expressionContextAttrs<'input> for Primary_expressionContext<'input>{}

pub type BitconcatContext<'input> = BaseParserRuleContext<'input,BitconcatContextExt<'input>>;

pub trait BitconcatContextAttrs<'input>: BSVParserContext<'input>{
	fn bit_concatination(&self) -> Option<Rc<Bit_concatinationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> BitconcatContextAttrs<'input> for BitconcatContext<'input>{}

pub struct BitconcatContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{BitconcatContextExt<'a>}

impl<'input> BSVParserContext<'input> for BitconcatContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BitconcatContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_bitconcat(self);
	}
}

impl<'input> CustomRuleContext<'input> for BitconcatContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for BitconcatContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for BitconcatContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for BitconcatContext<'input> {}

impl<'input> BitconcatContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::BitconcatContext(
				BaseParserRuleContext::copy_from(ctx,BitconcatContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type WhenexprContext<'input> = BaseParserRuleContext<'input,WhenexprContextExt<'input>>;

pub trait WhenexprContextAttrs<'input>: BSVParserContext<'input>{
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> WhenexprContextAttrs<'input> for WhenexprContext<'input>{}

pub struct WhenexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{WhenexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for WhenexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for WhenexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_whenexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for WhenexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for WhenexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for WhenexprContext<'input> {}

impl<'input> WhenexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::WhenexprContext(
				BaseParserRuleContext::copy_from(ctx,WhenexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type VarexprContext<'input> = BaseParserRuleContext<'input,VarexprContextExt<'input>>;

pub trait VarexprContextAttrs<'input>: BSVParserContext<'input>{
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token UPPER_IDENTIFIER in current rule
	fn UPPER_IDENTIFIER_all(&self) -> Vec<Rc<TerminalNode<'input,BSVParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token UPPER_IDENTIFIER, starting from 0.
	/// Returns `None` if number of children corresponding to token UPPER_IDENTIFIER is less or equal than `i`.
	fn UPPER_IDENTIFIER(&self, i: usize) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
		self.get_token(UPPER_IDENTIFIER, i)
	}
}

impl<'input> VarexprContextAttrs<'input> for VarexprContext<'input>{}

pub struct VarexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	pub pkg: Option<TokenType<'input>>,
	pub var: Option<Rc<IdentifierContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{VarexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for VarexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for VarexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_varexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for VarexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for VarexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for VarexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for VarexprContext<'input> {}

impl<'input> VarexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::VarexprContext(
				BaseParserRuleContext::copy_from(ctx,VarexprContextExt{
					pkg:None, 
        			var:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type InterfaceexprContext<'input> = BaseParserRuleContext<'input,InterfaceexprContextExt<'input>>;

pub trait InterfaceexprContextAttrs<'input>: BSVParserContext<'input>{
	fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn interfacestmt_all(&self) ->  Vec<Rc<InterfacestmtContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn interfacestmt(&self, i: usize) -> Option<Rc<InterfacestmtContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn type_identifier(&self) -> Option<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> InterfaceexprContextAttrs<'input> for InterfaceexprContext<'input>{}

pub struct InterfaceexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{InterfaceexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for InterfaceexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InterfaceexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_interfaceexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for InterfaceexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for InterfaceexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for InterfaceexprContext<'input> {}

impl<'input> InterfaceexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::InterfaceexprContext(
				BaseParserRuleContext::copy_from(ctx,InterfaceexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type BlockexprContext<'input> = BaseParserRuleContext<'input,BlockexprContextExt<'input>>;

pub trait BlockexprContextAttrs<'input>: BSVParserContext<'input>{
	fn block_expression(&self) -> Option<Rc<Block_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> BlockexprContextAttrs<'input> for BlockexprContext<'input>{}

pub struct BlockexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{BlockexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for BlockexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BlockexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_blockexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for BlockexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for BlockexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for BlockexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for BlockexprContext<'input> {}

impl<'input> BlockexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::BlockexprContext(
				BaseParserRuleContext::copy_from(ctx,BlockexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ConstexprContext<'input> = BaseParserRuleContext<'input,ConstexprContextExt<'input>>;

pub trait ConstexprContextAttrs<'input>: BSVParserContext<'input>{
	fn constant_expression(&self) -> Option<Rc<Constant_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ConstexprContextAttrs<'input> for ConstexprContext<'input>{}

pub struct ConstexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{ConstexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for ConstexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ConstexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_constexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for ConstexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for ConstexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for ConstexprContext<'input> {}

impl<'input> ConstexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::ConstexprContext(
				BaseParserRuleContext::copy_from(ctx,ConstexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SyscallexprContext<'input> = BaseParserRuleContext<'input,SyscallexprContextExt<'input>>;

pub trait SyscallexprContextAttrs<'input>: BSVParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token SYSTEM_TASK
	/// Returns `None` if there is no child corresponding to token SYSTEM_TASK
	fn SYSTEM_TASK(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
		self.get_token(SYSTEM_TASK, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> SyscallexprContextAttrs<'input> for SyscallexprContext<'input>{}

pub struct SyscallexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	pub fcn: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{SyscallexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for SyscallexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for SyscallexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syscallexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyscallexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for SyscallexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for SyscallexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for SyscallexprContext<'input> {}

impl<'input> SyscallexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::SyscallexprContext(
				BaseParserRuleContext::copy_from(ctx,SyscallexprContextExt{
					fcn:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CallexprContext<'input> = BaseParserRuleContext<'input,CallexprContextExt<'input>>;

pub trait CallexprContextAttrs<'input>: BSVParserContext<'input>{
	fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> CallexprContextAttrs<'input> for CallexprContext<'input>{}

pub struct CallexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	pub fcn: Option<Rc<Primary_expressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{CallexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for CallexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CallexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_callexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for CallexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for CallexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for CallexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for CallexprContext<'input> {}

impl<'input> CallexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::CallexprContext(
				BaseParserRuleContext::copy_from(ctx,CallexprContextExt{
        			fcn:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CastexprContext<'input> = BaseParserRuleContext<'input,CastexprContextExt<'input>>;

pub trait CastexprContextAttrs<'input>: BSVParserContext<'input>{
	fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> CastexprContextAttrs<'input> for CastexprContext<'input>{}

pub struct CastexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{CastexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for CastexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CastexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_castexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for CastexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for CastexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for CastexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for CastexprContext<'input> {}

impl<'input> CastexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::CastexprContext(
				BaseParserRuleContext::copy_from(ctx,CastexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TypeassertionexprContext<'input> = BaseParserRuleContext<'input,TypeassertionexprContextExt<'input>>;

pub trait TypeassertionexprContextAttrs<'input>: BSVParserContext<'input>{
	fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> TypeassertionexprContextAttrs<'input> for TypeassertionexprContext<'input>{}

pub struct TypeassertionexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{TypeassertionexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for TypeassertionexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeassertionexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeassertionexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeassertionexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for TypeassertionexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for TypeassertionexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for TypeassertionexprContext<'input> {}

impl<'input> TypeassertionexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::TypeassertionexprContext(
				BaseParserRuleContext::copy_from(ctx,TypeassertionexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type BitselectContext<'input> = BaseParserRuleContext<'input,BitselectContextExt<'input>>;

pub trait BitselectContextAttrs<'input>: BSVParserContext<'input>{
	fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn constant_expression_all(&self) ->  Vec<Rc<Constant_expressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn constant_expression(&self, i: usize) -> Option<Rc<Constant_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> BitselectContextAttrs<'input> for BitselectContext<'input>{}

pub struct BitselectContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	pub array: Option<Rc<Primary_expressionContextAll<'input>>>,
	pub msb: Option<Rc<Constant_expressionContextAll<'input>>>,
	pub lsb: Option<Rc<Constant_expressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{BitselectContextExt<'a>}

impl<'input> BSVParserContext<'input> for BitselectContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for BitselectContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_bitselect(self);
	}
}

impl<'input> CustomRuleContext<'input> for BitselectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for BitselectContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for BitselectContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for BitselectContext<'input> {}

impl<'input> BitselectContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::BitselectContext(
				BaseParserRuleContext::copy_from(ctx,BitselectContextExt{
        			array:None, msb:None, lsb:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ResetbyexprContext<'input> = BaseParserRuleContext<'input,ResetbyexprContextExt<'input>>;

pub trait ResetbyexprContextAttrs<'input>: BSVParserContext<'input>{
	fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ResetbyexprContextAttrs<'input> for ResetbyexprContext<'input>{}

pub struct ResetbyexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{ResetbyexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for ResetbyexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ResetbyexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_resetbyexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for ResetbyexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for ResetbyexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for ResetbyexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for ResetbyexprContext<'input> {}

impl<'input> ResetbyexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::ResetbyexprContext(
				BaseParserRuleContext::copy_from(ctx,ResetbyexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TaggedunionexprContext<'input> = BaseParserRuleContext<'input,TaggedunionexprContextExt<'input>>;

pub trait TaggedunionexprContextAttrs<'input>: BSVParserContext<'input>{
	/// Retrieves all `TerminalNode`s corresponding to token UPPER_IDENTIFIER in current rule
	fn UPPER_IDENTIFIER_all(&self) -> Vec<Rc<TerminalNode<'input,BSVParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token UPPER_IDENTIFIER, starting from 0.
	/// Returns `None` if number of children corresponding to token UPPER_IDENTIFIER is less or equal than `i`.
	fn UPPER_IDENTIFIER(&self, i: usize) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
		self.get_token(UPPER_IDENTIFIER, i)
	}
	fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn memberbinds(&self) -> Option<Rc<MemberbindsContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> TaggedunionexprContextAttrs<'input> for TaggedunionexprContext<'input>{}

pub struct TaggedunionexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	pub tag: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{TaggedunionexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for TaggedunionexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TaggedunionexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_taggedunionexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for TaggedunionexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for TaggedunionexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for TaggedunionexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for TaggedunionexprContext<'input> {}

impl<'input> TaggedunionexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::TaggedunionexprContext(
				BaseParserRuleContext::copy_from(ctx,TaggedunionexprContextExt{
					tag:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ClockedbyexprContext<'input> = BaseParserRuleContext<'input,ClockedbyexprContextExt<'input>>;

pub trait ClockedbyexprContextAttrs<'input>: BSVParserContext<'input>{
	fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ClockedbyexprContextAttrs<'input> for ClockedbyexprContext<'input>{}

pub struct ClockedbyexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{ClockedbyexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for ClockedbyexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ClockedbyexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_clockedbyexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClockedbyexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for ClockedbyexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for ClockedbyexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for ClockedbyexprContext<'input> {}

impl<'input> ClockedbyexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::ClockedbyexprContext(
				BaseParserRuleContext::copy_from(ctx,ClockedbyexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type FieldexprContext<'input> = BaseParserRuleContext<'input,FieldexprContextExt<'input>>;

pub trait FieldexprContextAttrs<'input>: BSVParserContext<'input>{
	fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn any_identifier(&self) -> Option<Rc<Any_identifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> FieldexprContextAttrs<'input> for FieldexprContext<'input>{}

pub struct FieldexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	pub field: Option<Rc<Any_identifierContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{FieldexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for FieldexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for FieldexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_fieldexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for FieldexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for FieldexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for FieldexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for FieldexprContext<'input> {}

impl<'input> FieldexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::FieldexprContext(
				BaseParserRuleContext::copy_from(ctx,FieldexprContextExt{
        			field:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ParenexprContext<'input> = BaseParserRuleContext<'input,ParenexprContextExt<'input>>;

pub trait ParenexprContextAttrs<'input>: BSVParserContext<'input>{
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ParenexprContextAttrs<'input> for ParenexprContext<'input>{}

pub struct ParenexprContextExt<'input>{
	base:Primary_expressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::type_id!{ParenexprContextExt<'a>}

impl<'input> BSVParserContext<'input> for ParenexprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ParenexprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parenexpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenexprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary_expression }
}

impl<'input> Borrow<Primary_expressionContextExt<'input>> for ParenexprContext<'input>{
	fn borrow(&self) -> &Primary_expressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Primary_expressionContextExt<'input>> for ParenexprContext<'input>{
	fn borrow_mut(&mut self) -> &mut Primary_expressionContextExt<'input> { &mut self.base }
}

impl<'input> Primary_expressionContextAttrs<'input> for ParenexprContext<'input> {}

impl<'input> ParenexprContextExt<'input>{
	fn new(ctx: &dyn Primary_expressionContextAttrs<'input>) -> Rc<Primary_expressionContextAll<'input>>  {
		Rc::new(
			Primary_expressionContextAll::ParenexprContext(
				BaseParserRuleContext::copy_from(ctx,ParenexprContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  primary_expression(&mut self,)
	-> Result<Rc<Primary_expressionContextAll<'input>>,ANTLRError> {
		self.primary_expression_rec(0)
	}

	fn primary_expression_rec(&mut self, _p: isize)
	-> Result<Rc<Primary_expressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = Primary_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 232, RULE_primary_expression, _p);
	    let mut _localctx: Rc<Primary_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 232;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1892);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(198,&mut recog.base)? {
				1 =>{
					{
					let mut tmp = ParenexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();


					recog.base.set_state(1781);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1782);
					recog.expression_rec(0)?;

					recog.base.set_state(1783);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					{
					let mut tmp = CastexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(1790);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 T__13 | T__16 | UPPER_IDENTIFIER | LOWER_IDENTIFIER | INT_LITERAL 
						=> {
							{
							/*InvokeRule data_type*/
							recog.base.set_state(1785);
							recog.data_type()?;

							}
						}

					 T__8 
						=> {
							{
							{
							recog.base.set_state(1786);
							recog.base.match_token(T__8,&mut recog.err_handler)?;

							/*InvokeRule data_type*/
							recog.base.set_state(1787);
							recog.data_type()?;

							recog.base.set_state(1788);
							recog.base.match_token(T__10,&mut recog.err_handler)?;

							}
							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1792);
					recog.base.match_token(T__89,&mut recog.err_handler)?;

					/*InvokeRule primary_expression*/
					recog.base.set_state(1793);
					recog.primary_expression_rec(14)?;

					}
				}
			,
				3 =>{
					{
					let mut tmp = VarexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(1799);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==UPPER_IDENTIFIER {
						{
						{
						recog.base.set_state(1795);
						let tmp = recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;
						if let Primary_expressionContextAll::VarexprContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut _localctx){
						ctx.pkg = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						recog.base.set_state(1796);
						recog.base.match_token(T__6,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1801);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(1802);
					let tmp = recog.identifier()?;
					if let Primary_expressionContextAll::VarexprContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut _localctx){
					ctx.var = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				4 =>{
					{
					let mut tmp = ConstexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule constant_expression*/
					recog.base.set_state(1803);
					recog.constant_expression_rec(0)?;

					}
				}
			,
				5 =>{
					{
					let mut tmp = BitconcatContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule bit_concatination*/
					recog.base.set_state(1804);
					recog.bit_concatination()?;

					}
				}
			,
				6 =>{
					{
					let mut tmp = WhenexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(1805);
					recog.base.match_token(T__90,&mut recog.err_handler)?;

					recog.base.set_state(1806);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					recog.base.set_state(1815);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
						{
						/*InvokeRule expression*/
						recog.base.set_state(1807);
						recog.expression_rec(0)?;

						recog.base.set_state(1812);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==T__5 {
							{
							{
							recog.base.set_state(1808);
							recog.base.match_token(T__5,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(1809);
							recog.expression_rec(0)?;

							}
							}
							recog.base.set_state(1814);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(1817);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					{
					let mut tmp = SyscallexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(1818);
					let tmp = recog.base.match_token(SYSTEM_TASK,&mut recog.err_handler)?;
					if let Primary_expressionContextAll::SyscallexprContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut _localctx){
					ctx.fcn = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1831);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(189,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1819);
							recog.base.match_token(T__8,&mut recog.err_handler)?;

							recog.base.set_state(1828);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
								{
								/*InvokeRule expression*/
								recog.base.set_state(1820);
								recog.expression_rec(0)?;

								recog.base.set_state(1825);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
								while _la==T__5 {
									{
									{
									recog.base.set_state(1821);
									recog.base.match_token(T__5,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(1822);
									recog.expression_rec(0)?;

									}
									}
									recog.base.set_state(1827);
									recog.err_handler.sync(&mut recog.base)?;
									_la = recog.base.input.la(1);
								}
								}
							}

							recog.base.set_state(1830);
							recog.base.match_token(T__10,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				8 =>{
					{
					let mut tmp = ClockedbyexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(1833);
					recog.base.match_token(T__91,&mut recog.err_handler)?;

					/*InvokeRule primary_expression*/
					recog.base.set_state(1834);
					recog.primary_expression_rec(6)?;

					}
				}
			,
				9 =>{
					{
					let mut tmp = ResetbyexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(1835);
					recog.base.match_token(T__92,&mut recog.err_handler)?;

					/*InvokeRule primary_expression*/
					recog.base.set_state(1836);
					recog.primary_expression_rec(5)?;

					}
				}
			,
				10 =>{
					{
					let mut tmp = TypeassertionexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule data_type*/
					recog.base.set_state(1837);
					recog.data_type()?;

					recog.base.set_state(1838);
					recog.base.match_token(T__93,&mut recog.err_handler)?;

					recog.base.set_state(1854);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 T__35 
						=> {
							{
							{
							recog.base.set_state(1839);
							recog.base.match_token(T__35,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(1840);
							recog.expression_rec(0)?;

							recog.base.set_state(1845);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==T__5 {
								{
								{
								recog.base.set_state(1841);
								recog.base.match_token(T__5,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(1842);
								recog.expression_rec(0)?;

								}
								}
								recog.base.set_state(1847);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(1848);
							recog.base.match_token(T__36,&mut recog.err_handler)?;

							}
							}
						}

					 T__8 
						=> {
							{
							{
							recog.base.set_state(1850);
							recog.base.match_token(T__8,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(1851);
							recog.expression_rec(0)?;

							recog.base.set_state(1852);
							recog.base.match_token(T__10,&mut recog.err_handler)?;

							}
							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}
			,
				11 =>{
					{
					let mut tmp = TaggedunionexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(1857);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__39 {
						{
						recog.base.set_state(1856);
						recog.base.match_token(T__39,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1863);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(193,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1859);
							recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

							recog.base.set_state(1860);
							recog.base.match_token(T__6,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1865);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(193,&mut recog.base)?;
					}
					recog.base.set_state(1866);
					let tmp = recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;
					if let Primary_expressionContextAll::TaggedunionexprContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut _localctx){
					ctx.tag = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1873);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(194,&mut recog.base)? {
						1 =>{
							{
							{
							recog.base.set_state(1867);
							recog.base.match_token(T__35,&mut recog.err_handler)?;

							/*InvokeRule memberbinds*/
							recog.base.set_state(1868);
							recog.memberbinds()?;

							recog.base.set_state(1869);
							recog.base.match_token(T__36,&mut recog.err_handler)?;

							}
							}
						}
					,
						2 =>{
							{
							/*InvokeRule primary_expression*/
							recog.base.set_state(1871);
							recog.primary_expression_rec(0)?;

							}
						}
					,
						3 =>{
							{
							}
						}

						_ => {}
					}
					}
				}
			,
				12 =>{
					{
					let mut tmp = InterfaceexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(1875);
					recog.base.match_token(T__17,&mut recog.err_handler)?;

					/*InvokeRule data_type*/
					recog.base.set_state(1876);
					recog.data_type()?;

					recog.base.set_state(1878);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__1 {
						{
						recog.base.set_state(1877);
						recog.base.match_token(T__1,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1883);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__21) | (1usize << T__41) | (1usize << T__42))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
						{
						{
						/*InvokeRule interfacestmt*/
						recog.base.set_state(1880);
						recog.interfacestmt()?;

						}
						}
						recog.base.set_state(1885);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1886);
					recog.base.match_token(T__18,&mut recog.err_handler)?;

					recog.base.set_state(1889);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(197,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1887);
							recog.base.match_token(T__3,&mut recog.err_handler)?;

							/*InvokeRule type_identifier*/
							recog.base.set_state(1888);
							recog.type_identifier()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				13 =>{
					{
					let mut tmp = BlockexprContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule block_expression*/
					recog.base.set_state(1891);
					recog.block_expression()?;

					}
				}

				_ => {}
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(1921);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(203,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(1919);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(202,&mut recog.base)? {
						1 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = FieldexprContextExt::new(&**Primary_expressionContextExt::new(_parentctx.clone(), _parentState));
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_primary_expression);
							_localctx = tmp;
							recog.base.set_state(1894);
							if !({recog.precpred(None, 15)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 15)".to_owned()), None))?;
							}
							recog.base.set_state(1895);
							recog.base.match_token(T__45,&mut recog.err_handler)?;

							/*InvokeRule any_identifier*/
							recog.base.set_state(1896);
							let tmp = recog.any_identifier()?;
							if let Primary_expressionContextAll::FieldexprContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut _localctx){
							ctx.field = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}
					,
						2 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = BitselectContextExt::new(&**Primary_expressionContextExt::new(_parentctx.clone(), _parentState));
							if let Primary_expressionContextAll::BitselectContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut tmp){
								ctx.array = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_primary_expression);
							_localctx = tmp;
							recog.base.set_state(1897);
							if !({recog.precpred(None, 10)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 10)".to_owned()), None))?;
							}
							recog.base.set_state(1898);
							recog.base.match_token(T__14,&mut recog.err_handler)?;

							/*InvokeRule constant_expression*/
							recog.base.set_state(1899);
							let tmp = recog.constant_expression_rec(0)?;
							if let Primary_expressionContextAll::BitselectContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut _localctx){
							ctx.msb = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							recog.base.set_state(1902);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==T__3 {
								{
								{
								recog.base.set_state(1900);
								recog.base.match_token(T__3,&mut recog.err_handler)?;

								/*InvokeRule constant_expression*/
								recog.base.set_state(1901);
								let tmp = recog.constant_expression_rec(0)?;
								if let Primary_expressionContextAll::BitselectContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut _localctx){
								ctx.lsb = Some(tmp.clone()); } else {unreachable!("cant cast");}  

								}
								}
							}

							recog.base.set_state(1904);
							recog.base.match_token(T__15,&mut recog.err_handler)?;

							}
						}
					,
						3 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = CallexprContextExt::new(&**Primary_expressionContextExt::new(_parentctx.clone(), _parentState));
							if let Primary_expressionContextAll::CallexprContext(ctx) = cast_mut::<_,Primary_expressionContextAll >(&mut tmp){
								ctx.fcn = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_primary_expression);
							_localctx = tmp;
							recog.base.set_state(1906);
							if !({recog.precpred(None, 9)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 9)".to_owned()), None))?;
							}
							recog.base.set_state(1907);
							recog.base.match_token(T__8,&mut recog.err_handler)?;

							recog.base.set_state(1916);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
								{
								/*InvokeRule expression*/
								recog.base.set_state(1908);
								recog.expression_rec(0)?;

								recog.base.set_state(1913);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
								while _la==T__5 {
									{
									{
									recog.base.set_state(1909);
									recog.base.match_token(T__5,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(1910);
									recog.expression_rec(0)?;

									}
									}
									recog.base.set_state(1915);
									recog.err_handler.sync(&mut recog.base)?;
									_la = recog.base.input.la(1);
								}
								}
							}

							recog.base.set_state(1918);
							recog.base.match_token(T__10,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(1923);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(203,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- memberbinds ----------------
pub type MemberbindsContextAll<'input> = MemberbindsContext<'input>;


pub type MemberbindsContext<'input> = BaseParserRuleContext<'input,MemberbindsContextExt<'input>>;

#[derive(Clone)]
pub struct MemberbindsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MemberbindsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MemberbindsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_memberbinds(self);
	}
}

impl<'input> CustomRuleContext<'input> for MemberbindsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberbinds }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberbinds }
}
antlr_rust::type_id!{MemberbindsContextExt<'a>}

impl<'input> MemberbindsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberbindsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberbindsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberbindsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MemberbindsContextExt<'input>>{

fn memberbind_all(&self) ->  Vec<Rc<MemberbindContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn memberbind(&self, i: usize) -> Option<Rc<MemberbindContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MemberbindsContextAttrs<'input> for MemberbindsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberbinds(&mut self,)
	-> Result<Rc<MemberbindsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberbindsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_memberbinds);
        let mut _localctx: Rc<MemberbindsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule memberbind*/
			recog.base.set_state(1924);
			recog.memberbind()?;

			recog.base.set_state(1929);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(1925);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule memberbind*/
				recog.base.set_state(1926);
				recog.memberbind()?;

				}
				}
				recog.base.set_state(1931);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberbind ----------------
pub type MemberbindContextAll<'input> = MemberbindContext<'input>;


pub type MemberbindContext<'input> = BaseParserRuleContext<'input,MemberbindContextExt<'input>>;

#[derive(Clone)]
pub struct MemberbindContextExt<'input>{
	pub field: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MemberbindContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MemberbindContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_memberbind(self);
	}
}

impl<'input> CustomRuleContext<'input> for MemberbindContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberbind }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberbind }
}
antlr_rust::type_id!{MemberbindContextExt<'a>}

impl<'input> MemberbindContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberbindContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberbindContextExt{
				field: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberbindContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MemberbindContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MemberbindContextAttrs<'input> for MemberbindContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberbind(&mut self,)
	-> Result<Rc<MemberbindContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberbindContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_memberbind);
        let mut _localctx: Rc<MemberbindContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1932);
			let tmp = recog.identifier()?;
			 cast_mut::<_,MemberbindContext >(&mut _localctx).field = Some(tmp.clone());
			  

			recog.base.set_state(1933);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1934);
			recog.expression_rec(0)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfacestmt ----------------
pub type InterfacestmtContextAll<'input> = InterfacestmtContext<'input>;


pub type InterfacestmtContext<'input> = BaseParserRuleContext<'input,InterfacestmtContextExt<'input>>;

#[derive(Clone)]
pub struct InterfacestmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InterfacestmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InterfacestmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_interfacestmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfacestmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfacestmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfacestmt }
}
antlr_rust::type_id!{InterfacestmtContextExt<'a>}

impl<'input> InterfacestmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfacestmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfacestmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfacestmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InterfacestmtContextExt<'input>>{

fn method_def(&self) -> Option<Rc<Method_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subinterfaceDef(&self) -> Option<Rc<SubinterfaceDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_declaration(&self) -> Option<Rc<Variable_declarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_assignment(&self) -> Option<Rc<Variable_assignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfacestmtContextAttrs<'input> for InterfacestmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfacestmt(&mut self,)
	-> Result<Rc<InterfacestmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfacestmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_interfacestmt);
        let mut _localctx: Rc<InterfacestmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1940);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(205,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule method_def*/
					recog.base.set_state(1936);
					recog.method_def()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule subinterfaceDef*/
					recog.base.set_state(1937);
					recog.subinterfaceDef()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule variable_declaration*/
					recog.base.set_state(1938);
					recog.variable_declaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule variable_assignment*/
					recog.base.set_state(1939);
					recog.variable_assignment()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cond_predicate ----------------
pub type Cond_predicateContextAll<'input> = Cond_predicateContext<'input>;


pub type Cond_predicateContext<'input> = BaseParserRuleContext<'input,Cond_predicateContextExt<'input>>;

#[derive(Clone)]
pub struct Cond_predicateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Cond_predicateContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Cond_predicateContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_cond_predicate(self);
	}
}

impl<'input> CustomRuleContext<'input> for Cond_predicateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cond_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cond_predicate }
}
antlr_rust::type_id!{Cond_predicateContextExt<'a>}

impl<'input> Cond_predicateContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Cond_predicateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Cond_predicateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Cond_predicateContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Cond_predicateContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn pattern_all(&self) ->  Vec<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn pattern(&self, i: usize) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Cond_predicateContextAttrs<'input> for Cond_predicateContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cond_predicate(&mut self,)
	-> Result<Rc<Cond_predicateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Cond_predicateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_cond_predicate);
        let mut _localctx: Rc<Cond_predicateContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1947);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(206,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule expression*/
					recog.base.set_state(1942);
					recog.expression_rec(0)?;

					}
				}
			,
				2 =>{
					{
					{
					/*InvokeRule expression*/
					recog.base.set_state(1943);
					recog.expression_rec(0)?;

					recog.base.set_state(1944);
					recog.base.match_token(T__54,&mut recog.err_handler)?;

					/*InvokeRule pattern*/
					recog.base.set_state(1945);
					recog.pattern()?;

					}
					}
				}

				_ => {}
			}
			recog.base.set_state(1959);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__62 {
				{
				{
				recog.base.set_state(1949);
				recog.base.match_token(T__62,&mut recog.err_handler)?;

				recog.base.set_state(1955);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(207,&mut recog.base)? {
					1 =>{
						{
						/*InvokeRule expression*/
						recog.base.set_state(1950);
						recog.expression_rec(0)?;

						}
					}
				,
					2 =>{
						{
						{
						/*InvokeRule expression*/
						recog.base.set_state(1951);
						recog.expression_rec(0)?;

						recog.base.set_state(1952);
						recog.base.match_token(T__54,&mut recog.err_handler)?;

						/*InvokeRule pattern*/
						recog.base.set_state(1953);
						recog.pattern()?;

						}
						}
					}

					_ => {}
				}
				}
				}
				recog.base.set_state(1961);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exprOrCondPattern ----------------
pub type ExprOrCondPatternContextAll<'input> = ExprOrCondPatternContext<'input>;


pub type ExprOrCondPatternContext<'input> = BaseParserRuleContext<'input,ExprOrCondPatternContextExt<'input>>;

#[derive(Clone)]
pub struct ExprOrCondPatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ExprOrCondPatternContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExprOrCondPatternContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_exprOrCondPattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExprOrCondPatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exprOrCondPattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exprOrCondPattern }
}
antlr_rust::type_id!{ExprOrCondPatternContextExt<'a>}

impl<'input> ExprOrCondPatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExprOrCondPatternContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExprOrCondPatternContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExprOrCondPatternContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ExprOrCondPatternContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExprOrCondPatternContextAttrs<'input> for ExprOrCondPatternContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exprOrCondPattern(&mut self,)
	-> Result<Rc<ExprOrCondPatternContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExprOrCondPatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_exprOrCondPattern);
        let mut _localctx: Rc<ExprOrCondPatternContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1967);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(209,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(1962);
					recog.expression_rec(0)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expression*/
					recog.base.set_state(1963);
					recog.expression_rec(0)?;

					recog.base.set_state(1964);
					recog.base.match_token(T__54,&mut recog.err_handler)?;

					/*InvokeRule pattern*/
					recog.base.set_state(1965);
					recog.pattern()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- block_expression ----------------
pub type Block_expressionContextAll<'input> = Block_expressionContext<'input>;


pub type Block_expressionContext<'input> = BaseParserRuleContext<'input,Block_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Block_expressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Block_expressionContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Block_expressionContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_block_expression(self);
	}
}

impl<'input> CustomRuleContext<'input> for Block_expressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_block_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_block_expression }
}
antlr_rust::type_id!{Block_expressionContextExt<'a>}

impl<'input> Block_expressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Block_expressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Block_expressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Block_expressionContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Block_expressionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn expressionStmt_all(&self) ->  Vec<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expressionStmt(&self, i: usize) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Block_expressionContextAttrs<'input> for Block_expressionContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn block_expression(&mut self,)
	-> Result<Rc<Block_expressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Block_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_block_expression);
        let mut _localctx: Rc<Block_expressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1969);
			recog.base.match_token(T__49,&mut recog.err_handler)?;

			recog.base.set_state(1972);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(1970);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(1971);
				recog.identifier()?;

				}
			}

			recog.base.set_state(1977);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(211,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule expressionStmt*/
					recog.base.set_state(1974);
					recog.expressionStmt()?;

					}
					} 
				}
				recog.base.set_state(1979);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(211,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(1980);
			recog.expression_rec(0)?;

			recog.base.set_state(1981);
			recog.base.match_token(T__50,&mut recog.err_handler)?;

			recog.base.set_state(1984);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(212,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1982);
					recog.base.match_token(T__3,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(1983);
					recog.identifier()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- actionBlock ----------------
pub type ActionBlockContextAll<'input> = ActionBlockContext<'input>;


pub type ActionBlockContext<'input> = BaseParserRuleContext<'input,ActionBlockContextExt<'input>>;

#[derive(Clone)]
pub struct ActionBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ActionBlockContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ActionBlockContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_actionBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for ActionBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_actionBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_actionBlock }
}
antlr_rust::type_id!{ActionBlockContextExt<'a>}

impl<'input> ActionBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ActionBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ActionBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ActionBlockContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ActionBlockContextExt<'input>>{

fn actionStmt_all(&self) ->  Vec<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionStmt(&self, i: usize) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ActionBlockContextAttrs<'input> for ActionBlockContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn actionBlock(&mut self,)
	-> Result<Rc<ActionBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ActionBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_actionBlock);
        let mut _localctx: Rc<ActionBlockContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1986);
			recog.base.match_token(T__94,&mut recog.err_handler)?;

			recog.base.set_state(1990);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__94 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule actionStmt*/
				recog.base.set_state(1987);
				recog.actionStmt()?;

				}
				}
				recog.base.set_state(1992);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1993);
			recog.base.match_token(T__95,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- actionStmt ----------------
pub type ActionStmtContextAll<'input> = ActionStmtContext<'input>;


pub type ActionStmtContext<'input> = BaseParserRuleContext<'input,ActionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ActionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ActionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ActionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ActionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_actionStmt }
}
antlr_rust::type_id!{ActionStmtContextExt<'a>}

impl<'input> ActionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ActionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ActionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ActionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ActionStmtContextExt<'input>>{

fn regWrite(&self) -> Option<Rc<RegWriteContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn varDo(&self) -> Option<Rc<VarDoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn varDeclDo(&self) -> Option<Rc<VarDeclDoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionBlock(&self) -> Option<Rc<ActionBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_def(&self) -> Option<Rc<Function_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn module_def(&self) -> Option<Rc<Module_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_declaration(&self) -> Option<Rc<Variable_declarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn beginEndStmt_actionStmt(&self) -> Option<Rc<BeginEndStmt_actionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn if_actionStmt(&self) -> Option<Rc<If_actionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn case_actionStmt(&self) -> Option<Rc<Case_actionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn for_actionStmt(&self) -> Option<Rc<For_actionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn while_actionStmt(&self) -> Option<Rc<While_actionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ActionStmtContextAttrs<'input> for ActionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn actionStmt(&mut self,)
	-> Result<Rc<ActionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ActionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 248, RULE_actionStmt);
        let mut _localctx: Rc<ActionStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2011);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(214,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule regWrite*/
					recog.base.set_state(1995);
					recog.regWrite()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule varDo*/
					recog.base.set_state(1996);
					recog.varDo()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule varDeclDo*/
					recog.base.set_state(1997);
					recog.varDeclDo()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule expression*/
					recog.base.set_state(1998);
					recog.expression_rec(0)?;

					recog.base.set_state(1999);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule actionBlock*/
					recog.base.set_state(2001);
					recog.actionBlock()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule expressionStmt*/
					recog.base.set_state(2002);
					recog.expressionStmt()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule function_def*/
					recog.base.set_state(2003);
					recog.function_def()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule module_def*/
					recog.base.set_state(2004);
					recog.module_def()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule variable_declaration*/
					recog.base.set_state(2005);
					recog.variable_declaration()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule beginEndStmt_actionStmt*/
					recog.base.set_state(2006);
					recog.beginEndStmt_actionStmt()?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule if_actionStmt*/
					recog.base.set_state(2007);
					recog.if_actionStmt()?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule case_actionStmt*/
					recog.base.set_state(2008);
					recog.case_actionStmt()?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule for_actionStmt*/
					recog.base.set_state(2009);
					recog.for_actionStmt()?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule while_actionStmt*/
					recog.base.set_state(2010);
					recog.while_actionStmt()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- actionValueBlock ----------------
pub type ActionValueBlockContextAll<'input> = ActionValueBlockContext<'input>;


pub type ActionValueBlockContext<'input> = BaseParserRuleContext<'input,ActionValueBlockContextExt<'input>>;

#[derive(Clone)]
pub struct ActionValueBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ActionValueBlockContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ActionValueBlockContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_actionValueBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for ActionValueBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_actionValueBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_actionValueBlock }
}
antlr_rust::type_id!{ActionValueBlockContextExt<'a>}

impl<'input> ActionValueBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ActionValueBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ActionValueBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ActionValueBlockContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ActionValueBlockContextExt<'input>>{

fn actionValueStmt_all(&self) ->  Vec<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn actionValueStmt(&self, i: usize) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ActionValueBlockContextAttrs<'input> for ActionValueBlockContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn actionValueBlock(&mut self,)
	-> Result<Rc<ActionValueBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ActionValueBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_actionValueBlock);
        let mut _localctx: Rc<ActionValueBlockContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2013);
			recog.base.match_token(T__96,&mut recog.err_handler)?;

			recog.base.set_state(2017);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__1) | (1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__23) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59) | (1usize << T__60) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)) | (1usize << (T__96 - 64)) | (1usize << (T__101 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
				{
				{
				/*InvokeRule actionValueStmt*/
				recog.base.set_state(2014);
				recog.actionValueStmt()?;

				}
				}
				recog.base.set_state(2019);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2020);
			recog.base.match_token(T__97,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- actionValueStmt ----------------
pub type ActionValueStmtContextAll<'input> = ActionValueStmtContext<'input>;


pub type ActionValueStmtContext<'input> = BaseParserRuleContext<'input,ActionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ActionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ActionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ActionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ActionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_actionValueStmt }
}
antlr_rust::type_id!{ActionValueStmtContextExt<'a>}

impl<'input> ActionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ActionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ActionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ActionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ActionValueStmtContextExt<'input>>{

fn regWrite(&self) -> Option<Rc<RegWriteContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn varDo(&self) -> Option<Rc<VarDoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn varDeclDo(&self) -> Option<Rc<VarDeclDoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionValueBlock(&self) -> Option<Rc<ActionValueBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnStmt(&self) -> Option<Rc<ReturnStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_declaration(&self) -> Option<Rc<Variable_declarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_assignment(&self) -> Option<Rc<Variable_assignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_def(&self) -> Option<Rc<Function_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn module_def(&self) -> Option<Rc<Module_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn beginEndStmt_actionValueStmt(&self) -> Option<Rc<BeginEndStmt_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn if_actionValueStmt(&self) -> Option<Rc<If_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn case_actionValueStmt(&self) -> Option<Rc<Case_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn for_actionValueStmt(&self) -> Option<Rc<For_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn while_actionValueStmt(&self) -> Option<Rc<While_actionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ActionValueStmtContextAttrs<'input> for ActionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn actionValueStmt(&mut self,)
	-> Result<Rc<ActionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ActionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 252, RULE_actionValueStmt);
        let mut _localctx: Rc<ActionValueStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2040);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(217,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule regWrite*/
					recog.base.set_state(2022);
					recog.regWrite()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule varDo*/
					recog.base.set_state(2023);
					recog.varDo()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule varDeclDo*/
					recog.base.set_state(2024);
					recog.varDeclDo()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule actionValueBlock*/
					recog.base.set_state(2025);
					recog.actionValueBlock()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(2027);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (SYSTEM_TASK - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0) {
						{
						/*InvokeRule expression*/
						recog.base.set_state(2026);
						recog.expression_rec(0)?;

						}
					}

					recog.base.set_state(2029);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule returnStmt*/
					recog.base.set_state(2030);
					recog.returnStmt()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule variable_declaration*/
					recog.base.set_state(2031);
					recog.variable_declaration()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule variable_assignment*/
					recog.base.set_state(2032);
					recog.variable_assignment()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule function_def*/
					recog.base.set_state(2033);
					recog.function_def()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule module_def*/
					recog.base.set_state(2034);
					recog.module_def()?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule beginEndStmt_actionValueStmt*/
					recog.base.set_state(2035);
					recog.beginEndStmt_actionValueStmt()?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule if_actionValueStmt*/
					recog.base.set_state(2036);
					recog.if_actionValueStmt()?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule case_actionValueStmt*/
					recog.base.set_state(2037);
					recog.case_actionValueStmt()?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule for_actionValueStmt*/
					recog.base.set_state(2038);
					recog.for_actionValueStmt()?;

					}
				}
			,
				15 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule while_actionValueStmt*/
					recog.base.set_state(2039);
					recog.while_actionValueStmt()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- varDeclDo ----------------
pub type VarDeclDoContextAll<'input> = VarDeclDoContext<'input>;


pub type VarDeclDoContext<'input> = BaseParserRuleContext<'input,VarDeclDoContextExt<'input>>;

#[derive(Clone)]
pub struct VarDeclDoContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for VarDeclDoContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for VarDeclDoContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_varDeclDo(self);
	}
}

impl<'input> CustomRuleContext<'input> for VarDeclDoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_varDeclDo }
	//fn type_rule_index() -> usize where Self: Sized { RULE_varDeclDo }
}
antlr_rust::type_id!{VarDeclDoContextExt<'a>}

impl<'input> VarDeclDoContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VarDeclDoContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VarDeclDoContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VarDeclDoContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<VarDeclDoContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VarDeclDoContextAttrs<'input> for VarDeclDoContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn varDeclDo(&mut self,)
	-> Result<Rc<VarDeclDoContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VarDeclDoContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_varDeclDo);
        let mut _localctx: Rc<VarDeclDoContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(2042);
			recog.attribute_instances()?;

			/*InvokeRule data_type*/
			recog.base.set_state(2043);
			recog.data_type()?;

			/*InvokeRule identifier*/
			recog.base.set_state(2044);
			recog.identifier()?;

			recog.base.set_state(2045);
			recog.base.match_token(T__44,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2046);
			recog.expression_rec(0)?;

			recog.base.set_state(2047);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- varDo ----------------
pub type VarDoContextAll<'input> = VarDoContext<'input>;


pub type VarDoContext<'input> = BaseParserRuleContext<'input,VarDoContextExt<'input>>;

#[derive(Clone)]
pub struct VarDoContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for VarDoContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for VarDoContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_varDo(self);
	}
}

impl<'input> CustomRuleContext<'input> for VarDoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_varDo }
	//fn type_rule_index() -> usize where Self: Sized { RULE_varDo }
}
antlr_rust::type_id!{VarDoContextExt<'a>}

impl<'input> VarDoContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VarDoContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VarDoContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VarDoContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<VarDoContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VarDoContextAttrs<'input> for VarDoContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn varDo(&mut self,)
	-> Result<Rc<VarDoContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VarDoContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 256, RULE_varDo);
        let mut _localctx: Rc<VarDoContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(2049);
			recog.attribute_instances()?;

			/*InvokeRule identifier*/
			recog.base.set_state(2050);
			recog.identifier()?;

			recog.base.set_state(2051);
			recog.base.match_token(T__44,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2052);
			recog.expression_rec(0)?;

			recog.base.set_state(2053);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeAssertion ----------------
pub type TypeAssertionContextAll<'input> = TypeAssertionContext<'input>;


pub type TypeAssertionContext<'input> = BaseParserRuleContext<'input,TypeAssertionContextExt<'input>>;

#[derive(Clone)]
pub struct TypeAssertionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypeAssertionContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeAssertionContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeAssertion(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeAssertionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeAssertion }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeAssertion }
}
antlr_rust::type_id!{TypeAssertionContextExt<'a>}

impl<'input> TypeAssertionContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeAssertionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeAssertionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeAssertionContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypeAssertionContextExt<'input>>{

fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn bit_concatination(&self) -> Option<Rc<Bit_concatinationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeAssertionContextAttrs<'input> for TypeAssertionContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeAssertion(&mut self,)
	-> Result<Rc<TypeAssertionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeAssertionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 258, RULE_typeAssertion);
        let mut _localctx: Rc<TypeAssertionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2065);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(218,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule data_type*/
					recog.base.set_state(2055);
					recog.data_type()?;

					recog.base.set_state(2056);
					recog.base.match_token(T__89,&mut recog.err_handler)?;

					/*InvokeRule bit_concatination*/
					recog.base.set_state(2057);
					recog.bit_concatination()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule data_type*/
					recog.base.set_state(2059);
					recog.data_type()?;

					recog.base.set_state(2060);
					recog.base.match_token(T__89,&mut recog.err_handler)?;

					recog.base.set_state(2061);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2062);
					recog.expression_rec(0)?;

					recog.base.set_state(2063);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- structExpr ----------------
pub type StructExprContextAll<'input> = StructExprContext<'input>;


pub type StructExprContext<'input> = BaseParserRuleContext<'input,StructExprContextExt<'input>>;

#[derive(Clone)]
pub struct StructExprContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for StructExprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for StructExprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_structExpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for StructExprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_structExpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_structExpr }
}
antlr_rust::type_id!{StructExprContextExt<'a>}

impl<'input> StructExprContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StructExprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StructExprContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StructExprContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<StructExprContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
fn memberBind_all(&self) ->  Vec<Rc<MemberBindContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn memberBind(&self, i: usize) -> Option<Rc<MemberBindContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> StructExprContextAttrs<'input> for StructExprContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn structExpr(&mut self,)
	-> Result<Rc<StructExprContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StructExprContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_structExpr);
        let mut _localctx: Rc<StructExprContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2067);
			recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

			recog.base.set_state(2068);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			recog.base.set_state(2077);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule memberBind*/
				recog.base.set_state(2069);
				recog.memberBind()?;

				recog.base.set_state(2074);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==T__5 {
					{
					{
					recog.base.set_state(2070);
					recog.base.match_token(T__5,&mut recog.err_handler)?;

					/*InvokeRule memberBind*/
					recog.base.set_state(2071);
					recog.memberBind()?;

					}
					}
					recog.base.set_state(2076);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			recog.base.set_state(2079);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberBind ----------------
pub type MemberBindContextAll<'input> = MemberBindContext<'input>;


pub type MemberBindContext<'input> = BaseParserRuleContext<'input,MemberBindContextExt<'input>>;

#[derive(Clone)]
pub struct MemberBindContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MemberBindContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MemberBindContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_memberBind(self);
	}
}

impl<'input> CustomRuleContext<'input> for MemberBindContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberBind }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberBind }
}
antlr_rust::type_id!{MemberBindContextExt<'a>}

impl<'input> MemberBindContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberBindContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberBindContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberBindContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MemberBindContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MemberBindContextAttrs<'input> for MemberBindContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberBind(&mut self,)
	-> Result<Rc<MemberBindContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberBindContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_memberBind);
        let mut _localctx: Rc<MemberBindContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2081);
			recog.identifier()?;

			recog.base.set_state(2082);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2083);
			recog.expression_rec(0)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- taggedUnionExpr ----------------
pub type TaggedUnionExprContextAll<'input> = TaggedUnionExprContext<'input>;


pub type TaggedUnionExprContext<'input> = BaseParserRuleContext<'input,TaggedUnionExprContextExt<'input>>;

#[derive(Clone)]
pub struct TaggedUnionExprContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TaggedUnionExprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TaggedUnionExprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_taggedUnionExpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for TaggedUnionExprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_taggedUnionExpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_taggedUnionExpr }
}
antlr_rust::type_id!{TaggedUnionExprContextExt<'a>}

impl<'input> TaggedUnionExprContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TaggedUnionExprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TaggedUnionExprContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TaggedUnionExprContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TaggedUnionExprContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
fn memberBind_all(&self) ->  Vec<Rc<MemberBindContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn memberBind(&self, i: usize) -> Option<Rc<MemberBindContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn primary_expression(&self) -> Option<Rc<Primary_expressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TaggedUnionExprContextAttrs<'input> for TaggedUnionExprContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn taggedUnionExpr(&mut self,)
	-> Result<Rc<TaggedUnionExprContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TaggedUnionExprContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_taggedUnionExpr);
        let mut _localctx: Rc<TaggedUnionExprContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2097);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(221,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2085);
					recog.base.match_token(T__39,&mut recog.err_handler)?;

					recog.base.set_state(2086);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					recog.base.set_state(2087);
					recog.base.match_token(T__35,&mut recog.err_handler)?;

					/*InvokeRule memberBind*/
					recog.base.set_state(2088);
					recog.memberBind()?;

					{
					recog.base.set_state(2089);
					recog.base.match_token(T__5,&mut recog.err_handler)?;

					/*InvokeRule memberBind*/
					recog.base.set_state(2090);
					recog.memberBind()?;

					}
					recog.base.set_state(2092);
					recog.base.match_token(T__36,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2094);
					recog.base.match_token(T__39,&mut recog.err_handler)?;

					recog.base.set_state(2095);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					/*InvokeRule primary_expression*/
					recog.base.set_state(2096);
					recog.primary_expression_rec(0)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceExpr ----------------
pub type InterfaceExprContextAll<'input> = InterfaceExprContext<'input>;


pub type InterfaceExprContext<'input> = BaseParserRuleContext<'input,InterfaceExprContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceExprContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InterfaceExprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InterfaceExprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_interfaceExpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceExprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceExpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceExpr }
}
antlr_rust::type_id!{InterfaceExprContextExt<'a>}

impl<'input> InterfaceExprContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceExprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceExprContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceExprContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InterfaceExprContextExt<'input>>{

fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceStmt_all(&self) ->  Vec<Rc<InterfaceStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceStmt(&self, i: usize) -> Option<Rc<InterfaceStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}

}

impl<'input> InterfaceExprContextAttrs<'input> for InterfaceExprContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceExpr(&mut self,)
	-> Result<Rc<InterfaceExprContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceExprContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_interfaceExpr);
        let mut _localctx: Rc<InterfaceExprContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2099);
			recog.base.match_token(T__17,&mut recog.err_handler)?;

			/*InvokeRule data_type*/
			recog.base.set_state(2100);
			recog.data_type()?;

			recog.base.set_state(2102);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__1 {
				{
				recog.base.set_state(2101);
				recog.base.match_token(T__1,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2107);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__21) | (1usize << T__30) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
				{
				{
				/*InvokeRule interfaceStmt*/
				recog.base.set_state(2104);
				recog.interfaceStmt()?;

				}
				}
				recog.base.set_state(2109);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2110);
			recog.base.match_token(T__18,&mut recog.err_handler)?;

			recog.base.set_state(2113);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(2111);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				recog.base.set_state(2112);
				recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rulesExpr ----------------
pub type RulesExprContextAll<'input> = RulesExprContext<'input>;


pub type RulesExprContext<'input> = BaseParserRuleContext<'input,RulesExprContextExt<'input>>;

#[derive(Clone)]
pub struct RulesExprContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for RulesExprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for RulesExprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rulesExpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for RulesExprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rulesExpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rulesExpr }
}
antlr_rust::type_id!{RulesExprContextExt<'a>}

impl<'input> RulesExprContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RulesExprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RulesExprContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RulesExprContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<RulesExprContextExt<'input>>{

fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn rulesStmt_all(&self) ->  Vec<Rc<RulesStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rulesStmt(&self, i: usize) -> Option<Rc<RulesStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> RulesExprContextAttrs<'input> for RulesExprContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rulesExpr(&mut self,)
	-> Result<Rc<RulesExprContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RulesExprContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_rulesExpr);
        let mut _localctx: Rc<RulesExprContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute_instances*/
			recog.base.set_state(2115);
			recog.attribute_instances()?;

			recog.base.set_state(2116);
			recog.base.match_token(T__98,&mut recog.err_handler)?;

			recog.base.set_state(2119);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(2117);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(2118);
				recog.identifier()?;

				}
			}

			recog.base.set_state(2124);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__30) | (1usize << T__31) | (1usize << T__41) | (1usize << T__42) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
				{
				{
				/*InvokeRule rulesStmt*/
				recog.base.set_state(2121);
				recog.rulesStmt()?;

				}
				}
				recog.base.set_state(2126);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2127);
			recog.base.match_token(T__99,&mut recog.err_handler)?;

			recog.base.set_state(2130);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(2128);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(2129);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rulesStmt ----------------
pub type RulesStmtContextAll<'input> = RulesStmtContext<'input>;


pub type RulesStmtContext<'input> = BaseParserRuleContext<'input,RulesStmtContextExt<'input>>;

#[derive(Clone)]
pub struct RulesStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for RulesStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for RulesStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rulesStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for RulesStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rulesStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rulesStmt }
}
antlr_rust::type_id!{RulesStmtContextExt<'a>}

impl<'input> RulesStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RulesStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RulesStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RulesStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<RulesStmtContextExt<'input>>{

fn ruleDef(&self) -> Option<Rc<RuleDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RulesStmtContextAttrs<'input> for RulesStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rulesStmt(&mut self,)
	-> Result<Rc<RulesStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RulesStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_rulesStmt);
        let mut _localctx: Rc<RulesStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2134);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(228,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule ruleDef*/
					recog.base.set_state(2132);
					recog.ruleDef()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expressionStmt*/
					recog.base.set_state(2133);
					recog.expressionStmt()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pattern ----------------
pub type PatternContextAll<'input> = PatternContext<'input>;


pub type PatternContext<'input> = BaseParserRuleContext<'input,PatternContextExt<'input>>;

#[derive(Clone)]
pub struct PatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for PatternContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for PatternContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_pattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pattern }
}
antlr_rust::type_id!{PatternContextExt<'a>}

impl<'input> PatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PatternContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PatternContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PatternContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<PatternContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constantPattern(&self) -> Option<Rc<ConstantPatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn taggedUnionPattern(&self) -> Option<Rc<TaggedUnionPatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn structPattern(&self) -> Option<Rc<StructPatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tuplePattern(&self) -> Option<Rc<TuplePatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PatternContextAttrs<'input> for PatternContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pattern(&mut self,)
	-> Result<Rc<PatternContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_pattern);
        let mut _localctx: Rc<PatternContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2147);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(229,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2136);
					recog.base.match_token(T__45,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2137);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2138);
					recog.base.match_token(T__100,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule constantPattern*/
					recog.base.set_state(2139);
					recog.constantPattern()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule taggedUnionPattern*/
					recog.base.set_state(2140);
					recog.taggedUnionPattern()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule structPattern*/
					recog.base.set_state(2141);
					recog.structPattern()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule tuplePattern*/
					recog.base.set_state(2142);
					recog.tuplePattern()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(2143);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule pattern*/
					recog.base.set_state(2144);
					recog.pattern()?;

					recog.base.set_state(2145);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constantPattern ----------------
pub type ConstantPatternContextAll<'input> = ConstantPatternContext<'input>;


pub type ConstantPatternContext<'input> = BaseParserRuleContext<'input,ConstantPatternContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantPatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ConstantPatternContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ConstantPatternContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_constantPattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstantPatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constantPattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constantPattern }
}
antlr_rust::type_id!{ConstantPatternContextExt<'a>}

impl<'input> ConstantPatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantPatternContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantPatternContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantPatternContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ConstantPatternContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INT_LITERAL
/// Returns `None` if there is no child corresponding to token INT_LITERAL
fn INT_LITERAL(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(INT_LITERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token REAL_LITERAL
/// Returns `None` if there is no child corresponding to token REAL_LITERAL
fn REAL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(REAL_LITERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token STRING_LITERAL
/// Returns `None` if there is no child corresponding to token STRING_LITERAL
fn STRING_LITERAL(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(STRING_LITERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}

}

impl<'input> ConstantPatternContextAttrs<'input> for ConstantPatternContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constantPattern(&mut self,)
	-> Result<Rc<ConstantPatternContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantPatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_constantPattern);
        let mut _localctx: Rc<ConstantPatternContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2149);
			_la = recog.base.input.la(1);
			if { !(((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (STRING_LITERAL - 145)) | (1usize << (INT_LITERAL - 145)) | (1usize << (REAL_LITERAL - 145)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- taggedUnionPattern ----------------
pub type TaggedUnionPatternContextAll<'input> = TaggedUnionPatternContext<'input>;


pub type TaggedUnionPatternContext<'input> = BaseParserRuleContext<'input,TaggedUnionPatternContextExt<'input>>;

#[derive(Clone)]
pub struct TaggedUnionPatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TaggedUnionPatternContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TaggedUnionPatternContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_taggedUnionPattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for TaggedUnionPatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_taggedUnionPattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_taggedUnionPattern }
}
antlr_rust::type_id!{TaggedUnionPatternContextExt<'a>}

impl<'input> TaggedUnionPatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TaggedUnionPatternContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TaggedUnionPatternContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TaggedUnionPatternContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TaggedUnionPatternContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TaggedUnionPatternContextAttrs<'input> for TaggedUnionPatternContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn taggedUnionPattern(&mut self,)
	-> Result<Rc<TaggedUnionPatternContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TaggedUnionPatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_taggedUnionPattern);
        let mut _localctx: Rc<TaggedUnionPatternContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2151);
			recog.base.match_token(T__39,&mut recog.err_handler)?;

			recog.base.set_state(2152);
			recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

			recog.base.set_state(2154);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(230,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule pattern*/
					recog.base.set_state(2153);
					recog.pattern()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- structPattern ----------------
pub type StructPatternContextAll<'input> = StructPatternContext<'input>;


pub type StructPatternContext<'input> = BaseParserRuleContext<'input,StructPatternContextExt<'input>>;

#[derive(Clone)]
pub struct StructPatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for StructPatternContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for StructPatternContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_structPattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for StructPatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_structPattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_structPattern }
}
antlr_rust::type_id!{StructPatternContextExt<'a>}

impl<'input> StructPatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StructPatternContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StructPatternContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StructPatternContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<StructPatternContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn pattern_all(&self) ->  Vec<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn pattern(&self, i: usize) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> StructPatternContextAttrs<'input> for StructPatternContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn structPattern(&mut self,)
	-> Result<Rc<StructPatternContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StructPatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_structPattern);
        let mut _localctx: Rc<StructPatternContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2156);
			recog.base.match_token(T__39,&mut recog.err_handler)?;

			recog.base.set_state(2157);
			recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

			recog.base.set_state(2158);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(2159);
			recog.identifier()?;

			recog.base.set_state(2160);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule pattern*/
			recog.base.set_state(2161);
			recog.pattern()?;

			recog.base.set_state(2169);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2162);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(2163);
				recog.identifier()?;

				recog.base.set_state(2164);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule pattern*/
				recog.base.set_state(2165);
				recog.pattern()?;

				}
				}
				recog.base.set_state(2171);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2172);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tuplePattern ----------------
pub type TuplePatternContextAll<'input> = TuplePatternContext<'input>;


pub type TuplePatternContext<'input> = BaseParserRuleContext<'input,TuplePatternContextExt<'input>>;

#[derive(Clone)]
pub struct TuplePatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TuplePatternContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TuplePatternContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tuplePattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for TuplePatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tuplePattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tuplePattern }
}
antlr_rust::type_id!{TuplePatternContextExt<'a>}

impl<'input> TuplePatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TuplePatternContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TuplePatternContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TuplePatternContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TuplePatternContextExt<'input>>{

fn pattern_all(&self) ->  Vec<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn pattern(&self, i: usize) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TuplePatternContextAttrs<'input> for TuplePatternContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tuplePattern(&mut self,)
	-> Result<Rc<TuplePatternContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TuplePatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_tuplePattern);
        let mut _localctx: Rc<TuplePatternContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2174);
			recog.base.match_token(T__35,&mut recog.err_handler)?;

			/*InvokeRule pattern*/
			recog.base.set_state(2175);
			recog.pattern()?;

			recog.base.set_state(2180);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2176);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule pattern*/
				recog.base.set_state(2177);
				recog.pattern()?;

				}
				}
				recog.base.set_state(2182);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2183);
			recog.base.match_token(T__36,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- casePatItem_functionBodyStmt ----------------
pub type CasePatItem_functionBodyStmtContextAll<'input> = CasePatItem_functionBodyStmtContext<'input>;


pub type CasePatItem_functionBodyStmtContext<'input> = BaseParserRuleContext<'input,CasePatItem_functionBodyStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CasePatItem_functionBodyStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CasePatItem_functionBodyStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CasePatItem_functionBodyStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_casePatItem_functionBodyStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CasePatItem_functionBodyStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_casePatItem_functionBodyStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_casePatItem_functionBodyStmt }
}
antlr_rust::type_id!{CasePatItem_functionBodyStmtContextExt<'a>}

impl<'input> CasePatItem_functionBodyStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CasePatItem_functionBodyStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CasePatItem_functionBodyStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CasePatItem_functionBodyStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CasePatItem_functionBodyStmtContextExt<'input>>{

fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBodyStmt(&self) -> Option<Rc<FunctionBodyStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CasePatItem_functionBodyStmtContextAttrs<'input> for CasePatItem_functionBodyStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn casePatItem_functionBodyStmt(&mut self,)
	-> Result<Rc<CasePatItem_functionBodyStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CasePatItem_functionBodyStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_casePatItem_functionBodyStmt);
        let mut _localctx: Rc<CasePatItem_functionBodyStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pattern*/
			recog.base.set_state(2185);
			recog.pattern()?;

			recog.base.set_state(2188);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__62 {
				{
				recog.base.set_state(2186);
				recog.base.match_token(T__62,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2187);
				recog.expression_rec(0)?;

				}
			}

			recog.base.set_state(2190);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule functionBodyStmt*/
			recog.base.set_state(2191);
			recog.functionBodyStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- casePatItem_actionStmt ----------------
pub type CasePatItem_actionStmtContextAll<'input> = CasePatItem_actionStmtContext<'input>;


pub type CasePatItem_actionStmtContext<'input> = BaseParserRuleContext<'input,CasePatItem_actionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CasePatItem_actionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CasePatItem_actionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CasePatItem_actionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_casePatItem_actionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CasePatItem_actionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_casePatItem_actionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_casePatItem_actionStmt }
}
antlr_rust::type_id!{CasePatItem_actionStmtContextExt<'a>}

impl<'input> CasePatItem_actionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CasePatItem_actionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CasePatItem_actionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CasePatItem_actionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CasePatItem_actionStmtContextExt<'input>>{

fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionStmt(&self) -> Option<Rc<ActionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CasePatItem_actionStmtContextAttrs<'input> for CasePatItem_actionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn casePatItem_actionStmt(&mut self,)
	-> Result<Rc<CasePatItem_actionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CasePatItem_actionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_casePatItem_actionStmt);
        let mut _localctx: Rc<CasePatItem_actionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pattern*/
			recog.base.set_state(2193);
			recog.pattern()?;

			recog.base.set_state(2196);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__62 {
				{
				recog.base.set_state(2194);
				recog.base.match_token(T__62,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2195);
				recog.expression_rec(0)?;

				}
			}

			recog.base.set_state(2198);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule actionStmt*/
			recog.base.set_state(2199);
			recog.actionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- casePatItem_actionValueStmt ----------------
pub type CasePatItem_actionValueStmtContextAll<'input> = CasePatItem_actionValueStmtContext<'input>;


pub type CasePatItem_actionValueStmtContext<'input> = BaseParserRuleContext<'input,CasePatItem_actionValueStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CasePatItem_actionValueStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CasePatItem_actionValueStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CasePatItem_actionValueStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_casePatItem_actionValueStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CasePatItem_actionValueStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_casePatItem_actionValueStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_casePatItem_actionValueStmt }
}
antlr_rust::type_id!{CasePatItem_actionValueStmtContextExt<'a>}

impl<'input> CasePatItem_actionValueStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CasePatItem_actionValueStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CasePatItem_actionValueStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CasePatItem_actionValueStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CasePatItem_actionValueStmtContextExt<'input>>{

fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn actionValueStmt(&self) -> Option<Rc<ActionValueStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CasePatItem_actionValueStmtContextAttrs<'input> for CasePatItem_actionValueStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn casePatItem_actionValueStmt(&mut self,)
	-> Result<Rc<CasePatItem_actionValueStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CasePatItem_actionValueStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_casePatItem_actionValueStmt);
        let mut _localctx: Rc<CasePatItem_actionValueStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pattern*/
			recog.base.set_state(2201);
			recog.pattern()?;

			recog.base.set_state(2204);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__62 {
				{
				recog.base.set_state(2202);
				recog.base.match_token(T__62,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2203);
				recog.expression_rec(0)?;

				}
			}

			recog.base.set_state(2206);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule actionValueStmt*/
			recog.base.set_state(2207);
			recog.actionValueStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- casePatItem_moduleStmt ----------------
pub type CasePatItem_moduleStmtContextAll<'input> = CasePatItem_moduleStmtContext<'input>;


pub type CasePatItem_moduleStmtContext<'input> = BaseParserRuleContext<'input,CasePatItem_moduleStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CasePatItem_moduleStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CasePatItem_moduleStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CasePatItem_moduleStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_casePatItem_moduleStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CasePatItem_moduleStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_casePatItem_moduleStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_casePatItem_moduleStmt }
}
antlr_rust::type_id!{CasePatItem_moduleStmtContextExt<'a>}

impl<'input> CasePatItem_moduleStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CasePatItem_moduleStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CasePatItem_moduleStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CasePatItem_moduleStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CasePatItem_moduleStmtContextExt<'input>>{

fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moduleStmt(&self) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CasePatItem_moduleStmtContextAttrs<'input> for CasePatItem_moduleStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn casePatItem_moduleStmt(&mut self,)
	-> Result<Rc<CasePatItem_moduleStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CasePatItem_moduleStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_casePatItem_moduleStmt);
        let mut _localctx: Rc<CasePatItem_moduleStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pattern*/
			recog.base.set_state(2209);
			recog.pattern()?;

			recog.base.set_state(2212);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__62 {
				{
				recog.base.set_state(2210);
				recog.base.match_token(T__62,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2211);
				recog.expression_rec(0)?;

				}
			}

			recog.base.set_state(2214);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule moduleStmt*/
			recog.base.set_state(2215);
			recog.moduleStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- casePatItem_expressionStmt ----------------
pub type CasePatItem_expressionStmtContextAll<'input> = CasePatItem_expressionStmtContext<'input>;


pub type CasePatItem_expressionStmtContext<'input> = BaseParserRuleContext<'input,CasePatItem_expressionStmtContextExt<'input>>;

#[derive(Clone)]
pub struct CasePatItem_expressionStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CasePatItem_expressionStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CasePatItem_expressionStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_casePatItem_expressionStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for CasePatItem_expressionStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_casePatItem_expressionStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_casePatItem_expressionStmt }
}
antlr_rust::type_id!{CasePatItem_expressionStmtContextExt<'a>}

impl<'input> CasePatItem_expressionStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CasePatItem_expressionStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CasePatItem_expressionStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CasePatItem_expressionStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CasePatItem_expressionStmtContextExt<'input>>{

fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStmt(&self) -> Option<Rc<ExpressionStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CasePatItem_expressionStmtContextAttrs<'input> for CasePatItem_expressionStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn casePatItem_expressionStmt(&mut self,)
	-> Result<Rc<CasePatItem_expressionStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CasePatItem_expressionStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_casePatItem_expressionStmt);
        let mut _localctx: Rc<CasePatItem_expressionStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pattern*/
			recog.base.set_state(2217);
			recog.pattern()?;

			recog.base.set_state(2220);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__62 {
				{
				recog.base.set_state(2218);
				recog.base.match_token(T__62,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2219);
				recog.expression_rec(0)?;

				}
			}

			recog.base.set_state(2222);
			recog.base.match_token(T__3,&mut recog.err_handler)?;

			/*InvokeRule expressionStmt*/
			recog.base.set_state(2223);
			recog.expressionStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseExpr ----------------
pub type CaseExprContextAll<'input> = CaseExprContext<'input>;


pub type CaseExprContext<'input> = BaseParserRuleContext<'input,CaseExprContextExt<'input>>;

#[derive(Clone)]
pub struct CaseExprContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseExprContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseExprContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseExpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseExprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseExpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseExpr }
}
antlr_rust::type_id!{CaseExprContextExt<'a>}

impl<'input> CaseExprContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseExprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseExprContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseExprContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseExprContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn caseExprItem_all(&self) ->  Vec<Rc<CaseExprItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn caseExprItem(&self, i: usize) -> Option<Rc<CaseExprItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CaseExprContextAttrs<'input> for CaseExprContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseExpr(&mut self,)
	-> Result<Rc<CaseExprContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseExprContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_caseExpr);
        let mut _localctx: Rc<CaseExprContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2225);
			recog.base.match_token(T__52,&mut recog.err_handler)?;

			recog.base.set_state(2226);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2227);
			recog.expression_rec(0)?;

			recog.base.set_state(2228);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(2229);
			recog.base.match_token(T__54,&mut recog.err_handler)?;

			recog.base.set_state(2233);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__35) | (1usize << T__39) | (1usize << T__45) | (1usize << T__55))) != 0) || ((((_la - 101)) & !0x3f) == 0 && ((1usize << (_la - 101)) & ((1usize << (T__100 - 101)) | (1usize << (UPPER_IDENTIFIER - 101)) | (1usize << (STRING_LITERAL - 101)) | (1usize << (INT_LITERAL - 101)) | (1usize << (REAL_LITERAL - 101)))) != 0) {
				{
				{
				/*InvokeRule caseExprItem*/
				recog.base.set_state(2230);
				recog.caseExprItem()?;

				}
				}
				recog.base.set_state(2235);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2236);
			recog.base.match_token(T__53,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseExprItem ----------------
pub type CaseExprItemContextAll<'input> = CaseExprItemContext<'input>;


pub type CaseExprItemContext<'input> = BaseParserRuleContext<'input,CaseExprItemContextExt<'input>>;

#[derive(Clone)]
pub struct CaseExprItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CaseExprItemContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CaseExprItemContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_caseExprItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseExprItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseExprItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseExprItem }
}
antlr_rust::type_id!{CaseExprItemContextExt<'a>}

impl<'input> CaseExprItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseExprItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseExprItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseExprItemContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CaseExprItemContextExt<'input>>{

fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CaseExprItemContextAttrs<'input> for CaseExprItemContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseExprItem(&mut self,)
	-> Result<Rc<CaseExprItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseExprItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_caseExprItem);
        let mut _localctx: Rc<CaseExprItemContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2251);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__8 | T__35 | T__39 | T__45 | T__100 | UPPER_IDENTIFIER | STRING_LITERAL |
			 INT_LITERAL | REAL_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule pattern*/
					recog.base.set_state(2238);
					recog.pattern()?;

					recog.base.set_state(2241);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__62 {
						{
						recog.base.set_state(2239);
						recog.base.match_token(T__62,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(2240);
						recog.expression_rec(0)?;

						}
					}

					recog.base.set_state(2243);
					recog.base.match_token(T__3,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2244);
					recog.expression_rec(0)?;

					}
				}

			 T__55 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2246);
					recog.base.match_token(T__55,&mut recog.err_handler)?;

					recog.base.set_state(2248);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__3 {
						{
						recog.base.set_state(2247);
						recog.base.match_token(T__3,&mut recog.err_handler)?;

						}
					}

					/*InvokeRule expression*/
					recog.base.set_state(2250);
					recog.expression_rec(0)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attribute_instance ----------------
pub type Attribute_instanceContextAll<'input> = Attribute_instanceContext<'input>;


pub type Attribute_instanceContext<'input> = BaseParserRuleContext<'input,Attribute_instanceContextExt<'input>>;

#[derive(Clone)]
pub struct Attribute_instanceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Attribute_instanceContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Attribute_instanceContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_attribute_instance(self);
	}
}

impl<'input> CustomRuleContext<'input> for Attribute_instanceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attribute_instance }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attribute_instance }
}
antlr_rust::type_id!{Attribute_instanceContextExt<'a>}

impl<'input> Attribute_instanceContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Attribute_instanceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Attribute_instanceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Attribute_instanceContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Attribute_instanceContextExt<'input>>{

fn attribute_spec_all(&self) ->  Vec<Rc<Attribute_specContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn attribute_spec(&self, i: usize) -> Option<Rc<Attribute_specContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Attribute_instanceContextAttrs<'input> for Attribute_instanceContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attribute_instance(&mut self,)
	-> Result<Rc<Attribute_instanceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Attribute_instanceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_attribute_instance);
        let mut _localctx: Rc<Attribute_instanceContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2253);
			recog.base.match_token(T__101,&mut recog.err_handler)?;

			/*InvokeRule attribute_spec*/
			recog.base.set_state(2254);
			recog.attribute_spec()?;

			recog.base.set_state(2259);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2255);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule attribute_spec*/
				recog.base.set_state(2256);
				recog.attribute_spec()?;

				}
				}
				recog.base.set_state(2261);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2262);
			recog.base.match_token(T__102,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attribute_instances ----------------
pub type Attribute_instancesContextAll<'input> = Attribute_instancesContext<'input>;


pub type Attribute_instancesContext<'input> = BaseParserRuleContext<'input,Attribute_instancesContextExt<'input>>;

#[derive(Clone)]
pub struct Attribute_instancesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Attribute_instancesContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Attribute_instancesContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_attribute_instances(self);
	}
}

impl<'input> CustomRuleContext<'input> for Attribute_instancesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attribute_instances }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attribute_instances }
}
antlr_rust::type_id!{Attribute_instancesContextExt<'a>}

impl<'input> Attribute_instancesContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Attribute_instancesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Attribute_instancesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Attribute_instancesContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Attribute_instancesContextExt<'input>>{

fn attribute_instance_all(&self) ->  Vec<Rc<Attribute_instanceContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn attribute_instance(&self, i: usize) -> Option<Rc<Attribute_instanceContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> Attribute_instancesContextAttrs<'input> for Attribute_instancesContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attribute_instances(&mut self,)
	-> Result<Rc<Attribute_instancesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Attribute_instancesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_attribute_instances);
        let mut _localctx: Rc<Attribute_instancesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2267);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(243,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule attribute_instance*/
					recog.base.set_state(2264);
					recog.attribute_instance()?;

					}
					} 
				}
				recog.base.set_state(2269);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(243,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attribute_spec ----------------
pub type Attribute_specContextAll<'input> = Attribute_specContext<'input>;


pub type Attribute_specContext<'input> = BaseParserRuleContext<'input,Attribute_specContextExt<'input>>;

#[derive(Clone)]
pub struct Attribute_specContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Attribute_specContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Attribute_specContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_attribute_spec(self);
	}
}

impl<'input> CustomRuleContext<'input> for Attribute_specContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attribute_spec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attribute_spec }
}
antlr_rust::type_id!{Attribute_specContextExt<'a>}

impl<'input> Attribute_specContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Attribute_specContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Attribute_specContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Attribute_specContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Attribute_specContextExt<'input>>{

fn attrName(&self) -> Option<Rc<AttrNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Attribute_specContextAttrs<'input> for Attribute_specContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attribute_spec(&mut self,)
	-> Result<Rc<Attribute_specContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Attribute_specContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_attribute_spec);
        let mut _localctx: Rc<Attribute_specContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attrName*/
			recog.base.set_state(2270);
			recog.attrName()?;

			recog.base.set_state(2273);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__29 {
				{
				recog.base.set_state(2271);
				recog.base.match_token(T__29,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2272);
				recog.expression_rec(0)?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attrName ----------------
pub type AttrNameContextAll<'input> = AttrNameContext<'input>;


pub type AttrNameContext<'input> = BaseParserRuleContext<'input,AttrNameContextExt<'input>>;

#[derive(Clone)]
pub struct AttrNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for AttrNameContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for AttrNameContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_attrName(self);
	}
}

impl<'input> CustomRuleContext<'input> for AttrNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attrName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attrName }
}
antlr_rust::type_id!{AttrNameContextExt<'a>}

impl<'input> AttrNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AttrNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AttrNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AttrNameContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<AttrNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}

}

impl<'input> AttrNameContextAttrs<'input> for AttrNameContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attrName(&mut self,)
	-> Result<Rc<AttrNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AttrNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_attrName);
        let mut _localctx: Rc<AttrNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2277);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LOWER_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(2275);
					recog.identifier()?;

					}
				}

			 UPPER_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2276);
					recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- provisos ----------------
pub type ProvisosContextAll<'input> = ProvisosContext<'input>;


pub type ProvisosContext<'input> = BaseParserRuleContext<'input,ProvisosContextExt<'input>>;

#[derive(Clone)]
pub struct ProvisosContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ProvisosContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ProvisosContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_provisos(self);
	}
}

impl<'input> CustomRuleContext<'input> for ProvisosContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_provisos }
	//fn type_rule_index() -> usize where Self: Sized { RULE_provisos }
}
antlr_rust::type_id!{ProvisosContextExt<'a>}

impl<'input> ProvisosContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ProvisosContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ProvisosContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ProvisosContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ProvisosContextExt<'input>>{

fn proviso_all(&self) ->  Vec<Rc<ProvisoContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn proviso(&self, i: usize) -> Option<Rc<ProvisoContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ProvisosContextAttrs<'input> for ProvisosContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn provisos(&mut self,)
	-> Result<Rc<ProvisosContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ProvisosContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_provisos);
        let mut _localctx: Rc<ProvisosContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2279);
			recog.base.match_token(T__103,&mut recog.err_handler)?;

			recog.base.set_state(2280);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule proviso*/
			recog.base.set_state(2281);
			recog.proviso()?;

			recog.base.set_state(2286);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2282);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule proviso*/
				recog.base.set_state(2283);
				recog.proviso()?;

				}
				}
				recog.base.set_state(2288);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2289);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- proviso ----------------
pub type ProvisoContextAll<'input> = ProvisoContext<'input>;


pub type ProvisoContext<'input> = BaseParserRuleContext<'input,ProvisoContextExt<'input>>;

#[derive(Clone)]
pub struct ProvisoContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ProvisoContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ProvisoContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_proviso(self);
	}
}

impl<'input> CustomRuleContext<'input> for ProvisoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_proviso }
	//fn type_rule_index() -> usize where Self: Sized { RULE_proviso }
}
antlr_rust::type_id!{ProvisoContextExt<'a>}

impl<'input> ProvisoContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ProvisoContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ProvisoContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ProvisoContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ProvisoContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}
fn data_type_all(&self) ->  Vec<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn data_type(&self, i: usize) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ProvisoContextAttrs<'input> for ProvisoContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn proviso(&mut self,)
	-> Result<Rc<ProvisoContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ProvisoContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_proviso);
        let mut _localctx: Rc<ProvisoContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2291);
			recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

			recog.base.set_state(2292);
			recog.base.match_token(T__12,&mut recog.err_handler)?;

			recog.base.set_state(2293);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule data_type*/
			recog.base.set_state(2294);
			recog.data_type()?;

			recog.base.set_state(2299);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2295);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule data_type*/
				recog.base.set_state(2296);
				recog.data_type()?;

				}
				}
				recog.base.set_state(2301);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2302);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeclassDef ----------------
pub type TypeclassDefContextAll<'input> = TypeclassDefContext<'input>;


pub type TypeclassDefContext<'input> = BaseParserRuleContext<'input,TypeclassDefContextExt<'input>>;

#[derive(Clone)]
pub struct TypeclassDefContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypeclassDefContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeclassDefContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeclassDef(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeclassDefContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeclassDef }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeclassDef }
}
antlr_rust::type_id!{TypeclassDefContextExt<'a>}

impl<'input> TypeclassDefContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeclassDefContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeclassDefContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeclassDefContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypeclassDefContextExt<'input>>{

fn typeclassIde(&self) -> Option<Rc<TypeclassIdeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeFormals(&self) -> Option<Rc<TypeFormalsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn provisos(&self) -> Option<Rc<ProvisosContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typedepends(&self) -> Option<Rc<TypedependsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn overloadedDef_all(&self) ->  Vec<Rc<OverloadedDefContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn overloadedDef(&self, i: usize) -> Option<Rc<OverloadedDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}

}

impl<'input> TypeclassDefContextAttrs<'input> for TypeclassDefContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeclassDef(&mut self,)
	-> Result<Rc<TypeclassDefContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeclassDefContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_typeclassDef);
        let mut _localctx: Rc<TypeclassDefContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2304);
			recog.base.match_token(T__104,&mut recog.err_handler)?;

			/*InvokeRule typeclassIde*/
			recog.base.set_state(2305);
			recog.typeclassIde()?;

			/*InvokeRule typeFormals*/
			recog.base.set_state(2306);
			recog.typeFormals()?;

			recog.base.set_state(2308);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__103 {
				{
				/*InvokeRule provisos*/
				recog.base.set_state(2307);
				recog.provisos()?;

				}
			}

			recog.base.set_state(2311);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__106 {
				{
				/*InvokeRule typedepends*/
				recog.base.set_state(2310);
				recog.typedepends()?;

				}
			}

			recog.base.set_state(2313);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			recog.base.set_state(2317);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__13) | (1usize << T__16) | (1usize << T__23) | (1usize << T__41) | (1usize << T__42) | (1usize << T__59))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (T__101 - 102)) | (1usize << (UPPER_IDENTIFIER - 102)) | (1usize << (LOWER_IDENTIFIER - 102)) | (1usize << (INT_LITERAL - 102)))) != 0) {
				{
				{
				/*InvokeRule overloadedDef*/
				recog.base.set_state(2314);
				recog.overloadedDef()?;

				}
				}
				recog.base.set_state(2319);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2320);
			recog.base.match_token(T__105,&mut recog.err_handler)?;

			recog.base.set_state(2323);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(2321);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				recog.base.set_state(2322);
				recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeclassIde ----------------
pub type TypeclassIdeContextAll<'input> = TypeclassIdeContext<'input>;


pub type TypeclassIdeContext<'input> = BaseParserRuleContext<'input,TypeclassIdeContextExt<'input>>;

#[derive(Clone)]
pub struct TypeclassIdeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypeclassIdeContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeclassIdeContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeclassIde(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeclassIdeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeclassIde }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeclassIde }
}
antlr_rust::type_id!{TypeclassIdeContextExt<'a>}

impl<'input> TypeclassIdeContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeclassIdeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeclassIdeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeclassIdeContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypeclassIdeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UPPER_IDENTIFIER
/// Returns `None` if there is no child corresponding to token UPPER_IDENTIFIER
fn UPPER_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,BSVParserContextType>>> where Self:Sized{
	self.get_token(UPPER_IDENTIFIER, 0)
}

}

impl<'input> TypeclassIdeContextAttrs<'input> for TypeclassIdeContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeclassIde(&mut self,)
	-> Result<Rc<TypeclassIdeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeclassIdeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_typeclassIde);
        let mut _localctx: Rc<TypeclassIdeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2325);
			recog.base.match_token(UPPER_IDENTIFIER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typelist ----------------
pub type TypelistContextAll<'input> = TypelistContext<'input>;


pub type TypelistContext<'input> = BaseParserRuleContext<'input,TypelistContextExt<'input>>;

#[derive(Clone)]
pub struct TypelistContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypelistContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypelistContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typelist(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypelistContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typelist }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typelist }
}
antlr_rust::type_id!{TypelistContextExt<'a>}

impl<'input> TypelistContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypelistContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypelistContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypelistContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypelistContextExt<'input>>{

fn type_identifier_all(&self) ->  Vec<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn type_identifier(&self, i: usize) -> Option<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypelistContextAttrs<'input> for TypelistContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typelist(&mut self,)
	-> Result<Rc<TypelistContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypelistContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_typelist);
        let mut _localctx: Rc<TypelistContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2339);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__16 | UPPER_IDENTIFIER | LOWER_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule type_identifier*/
					recog.base.set_state(2327);
					recog.type_identifier()?;

					}
				}

			 T__8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2328);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule type_identifier*/
					recog.base.set_state(2329);
					recog.type_identifier()?;

					recog.base.set_state(2334);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__5 {
						{
						{
						recog.base.set_state(2330);
						recog.base.match_token(T__5,&mut recog.err_handler)?;

						/*InvokeRule type_identifier*/
						recog.base.set_state(2331);
						recog.type_identifier()?;

						}
						}
						recog.base.set_state(2336);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2337);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedepends ----------------
pub type TypedependsContextAll<'input> = TypedependsContext<'input>;


pub type TypedependsContext<'input> = BaseParserRuleContext<'input,TypedependsContextExt<'input>>;

#[derive(Clone)]
pub struct TypedependsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypedependsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypedependsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typedepends(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypedependsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedepends }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedepends }
}
antlr_rust::type_id!{TypedependsContextExt<'a>}

impl<'input> TypedependsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedependsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedependsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedependsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypedependsContextExt<'input>>{

fn typedepend_all(&self) ->  Vec<Rc<TypedependContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typedepend(&self, i: usize) -> Option<Rc<TypedependContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypedependsContextAttrs<'input> for TypedependsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedepends(&mut self,)
	-> Result<Rc<TypedependsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedependsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_typedepends);
        let mut _localctx: Rc<TypedependsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2341);
			recog.base.match_token(T__106,&mut recog.err_handler)?;

			recog.base.set_state(2342);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule typedepend*/
			recog.base.set_state(2343);
			recog.typedepend()?;

			recog.base.set_state(2348);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2344);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule typedepend*/
				recog.base.set_state(2345);
				recog.typedepend()?;

				}
				}
				recog.base.set_state(2350);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2351);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedepend ----------------
pub type TypedependContextAll<'input> = TypedependContext<'input>;


pub type TypedependContext<'input> = BaseParserRuleContext<'input,TypedependContextExt<'input>>;

#[derive(Clone)]
pub struct TypedependContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypedependContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypedependContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typedepend(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypedependContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedepend }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedepend }
}
antlr_rust::type_id!{TypedependContextExt<'a>}

impl<'input> TypedependContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedependContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedependContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedependContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypedependContextExt<'input>>{

fn typelist_all(&self) ->  Vec<Rc<TypelistContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typelist(&self, i: usize) -> Option<Rc<TypelistContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypedependContextAttrs<'input> for TypedependContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedepend(&mut self,)
	-> Result<Rc<TypedependContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedependContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_typedepend);
        let mut _localctx: Rc<TypedependContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typelist*/
			recog.base.set_state(2353);
			recog.typelist()?;

			recog.base.set_state(2354);
			recog.base.match_token(T__107,&mut recog.err_handler)?;

			/*InvokeRule typelist*/
			recog.base.set_state(2355);
			recog.typelist()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- overloadedDef ----------------
pub type OverloadedDefContextAll<'input> = OverloadedDefContext<'input>;


pub type OverloadedDefContext<'input> = BaseParserRuleContext<'input,OverloadedDefContextExt<'input>>;

#[derive(Clone)]
pub struct OverloadedDefContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for OverloadedDefContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for OverloadedDefContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_overloadedDef(self);
	}
}

impl<'input> CustomRuleContext<'input> for OverloadedDefContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_overloadedDef }
	//fn type_rule_index() -> usize where Self: Sized { RULE_overloadedDef }
}
antlr_rust::type_id!{OverloadedDefContextExt<'a>}

impl<'input> OverloadedDefContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OverloadedDefContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OverloadedDefContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OverloadedDefContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<OverloadedDefContextExt<'input>>{

fn function_proto(&self) -> Option<Rc<Function_protoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_declaration(&self) -> Option<Rc<Variable_declarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn module_proto(&self) -> Option<Rc<Module_protoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn module_def(&self) -> Option<Rc<Module_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_def(&self) -> Option<Rc<Function_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OverloadedDefContextAttrs<'input> for OverloadedDefContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn overloadedDef(&mut self,)
	-> Result<Rc<OverloadedDefContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OverloadedDefContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_overloadedDef);
        let mut _localctx: Rc<OverloadedDefContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2362);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(255,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule function_proto*/
					recog.base.set_state(2357);
					recog.function_proto()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule variable_declaration*/
					recog.base.set_state(2358);
					recog.variable_declaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule module_proto*/
					recog.base.set_state(2359);
					recog.module_proto()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule module_def*/
					recog.base.set_state(2360);
					recog.module_def()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule function_def*/
					recog.base.set_state(2361);
					recog.function_def()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeclassInstanceDef ----------------
pub type TypeclassInstanceDefContextAll<'input> = TypeclassInstanceDefContext<'input>;


pub type TypeclassInstanceDefContext<'input> = BaseParserRuleContext<'input,TypeclassInstanceDefContextExt<'input>>;

#[derive(Clone)]
pub struct TypeclassInstanceDefContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for TypeclassInstanceDefContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for TypeclassInstanceDefContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeclassInstanceDef(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeclassInstanceDefContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeclassInstanceDef }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeclassInstanceDef }
}
antlr_rust::type_id!{TypeclassInstanceDefContextExt<'a>}

impl<'input> TypeclassInstanceDefContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeclassInstanceDefContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeclassInstanceDefContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeclassInstanceDefContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<TypeclassInstanceDefContextExt<'input>>{

fn typeclassIde_all(&self) ->  Vec<Rc<TypeclassIdeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeclassIde(&self, i: usize) -> Option<Rc<TypeclassIdeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn data_type_all(&self) ->  Vec<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn data_type(&self, i: usize) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn provisos(&self) -> Option<Rc<ProvisosContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variable_assignment_all(&self) ->  Vec<Rc<Variable_assignmentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variable_assignment(&self, i: usize) -> Option<Rc<Variable_assignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn function_def_all(&self) ->  Vec<Rc<Function_defContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn function_def(&self, i: usize) -> Option<Rc<Function_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn module_def_all(&self) ->  Vec<Rc<Module_defContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn module_def(&self, i: usize) -> Option<Rc<Module_defContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeclassInstanceDefContextAttrs<'input> for TypeclassInstanceDefContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeclassInstanceDef(&mut self,)
	-> Result<Rc<TypeclassInstanceDefContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeclassInstanceDefContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_typeclassInstanceDef);
        let mut _localctx: Rc<TypeclassInstanceDefContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2364);
			recog.base.match_token(T__108,&mut recog.err_handler)?;

			/*InvokeRule typeclassIde*/
			recog.base.set_state(2365);
			recog.typeclassIde()?;

			recog.base.set_state(2366);
			recog.base.match_token(T__12,&mut recog.err_handler)?;

			recog.base.set_state(2367);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule data_type*/
			recog.base.set_state(2368);
			recog.data_type()?;

			recog.base.set_state(2373);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2369);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule data_type*/
				recog.base.set_state(2370);
				recog.data_type()?;

				}
				}
				recog.base.set_state(2375);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2376);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(2378);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__103 {
				{
				/*InvokeRule provisos*/
				recog.base.set_state(2377);
				recog.provisos()?;

				}
			}

			recog.base.set_state(2380);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			recog.base.set_state(2386);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__23 || _la==T__59 || _la==T__101 || _la==LOWER_IDENTIFIER {
				{
				recog.base.set_state(2384);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(258,&mut recog.base)? {
					1 =>{
						{
						/*InvokeRule variable_assignment*/
						recog.base.set_state(2381);
						recog.variable_assignment()?;

						}
					}
				,
					2 =>{
						{
						/*InvokeRule function_def*/
						recog.base.set_state(2382);
						recog.function_def()?;

						}
					}
				,
					3 =>{
						{
						/*InvokeRule module_def*/
						recog.base.set_state(2383);
						recog.module_def()?;

						}
					}

					_ => {}
				}
				}
				recog.base.set_state(2388);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2389);
			recog.base.match_token(T__109,&mut recog.err_handler)?;

			recog.base.set_state(2392);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(2390);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule typeclassIde*/
				recog.base.set_state(2391);
				recog.typeclassIde()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- derives ----------------
pub type DerivesContextAll<'input> = DerivesContext<'input>;


pub type DerivesContext<'input> = BaseParserRuleContext<'input,DerivesContextExt<'input>>;

#[derive(Clone)]
pub struct DerivesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for DerivesContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for DerivesContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_derives(self);
	}
}

impl<'input> CustomRuleContext<'input> for DerivesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_derives }
	//fn type_rule_index() -> usize where Self: Sized { RULE_derives }
}
antlr_rust::type_id!{DerivesContextExt<'a>}

impl<'input> DerivesContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DerivesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DerivesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DerivesContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<DerivesContextExt<'input>>{

fn typeclassIde_all(&self) ->  Vec<Rc<TypeclassIdeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeclassIde(&self, i: usize) -> Option<Rc<TypeclassIdeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DerivesContextAttrs<'input> for DerivesContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn derives(&mut self,)
	-> Result<Rc<DerivesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DerivesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_derives);
        let mut _localctx: Rc<DerivesContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2394);
			recog.base.match_token(T__110,&mut recog.err_handler)?;

			recog.base.set_state(2395);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule typeclassIde*/
			recog.base.set_state(2396);
			recog.typeclassIde()?;

			recog.base.set_state(2401);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2397);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule typeclassIde*/
				recog.base.set_state(2398);
				recog.typeclassIde()?;

				}
				}
				recog.base.set_state(2403);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2404);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- externModuleImport ----------------
pub type ExternModuleImportContextAll<'input> = ExternModuleImportContext<'input>;


pub type ExternModuleImportContext<'input> = BaseParserRuleContext<'input,ExternModuleImportContextExt<'input>>;

#[derive(Clone)]
pub struct ExternModuleImportContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ExternModuleImportContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExternModuleImportContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_externModuleImport(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExternModuleImportContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_externModuleImport }
	//fn type_rule_index() -> usize where Self: Sized { RULE_externModuleImport }
}
antlr_rust::type_id!{ExternModuleImportContextExt<'a>}

impl<'input> ExternModuleImportContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExternModuleImportContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExternModuleImportContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExternModuleImportContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ExternModuleImportContextExt<'input>>{

fn module_proto(&self) -> Option<Rc<Module_protoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn moduleStmt_all(&self) ->  Vec<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleStmt(&self, i: usize) -> Option<Rc<ModuleStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn importBVIStmt_all(&self) ->  Vec<Rc<ImportBVIStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importBVIStmt(&self, i: usize) -> Option<Rc<ImportBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ExternModuleImportContextAttrs<'input> for ExternModuleImportContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn externModuleImport(&mut self,)
	-> Result<Rc<ExternModuleImportContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExternModuleImportContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_externModuleImport);
        let mut _localctx: Rc<ExternModuleImportContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2406);
			recog.base.match_token(T__11,&mut recog.err_handler)?;

			recog.base.set_state(2407);
			recog.base.match_token(T__111,&mut recog.err_handler)?;

			recog.base.set_state(2411);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(2408);
				recog.identifier()?;

				recog.base.set_state(2409);
				recog.base.match_token(T__29,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule module_proto*/
			recog.base.set_state(2413);
			recog.module_proto()?;

			recog.base.set_state(2417);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(263,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule moduleStmt*/
					recog.base.set_state(2414);
					recog.moduleStmt()?;

					}
					} 
				}
				recog.base.set_state(2419);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(263,&mut recog.base)?;
			}
			recog.base.set_state(2423);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__17) | (1usize << T__21) | (1usize << T__24))) != 0) || ((((_la - 115)) & !0x3f) == 0 && ((1usize << (_la - 115)) & ((1usize << (T__114 - 115)) | (1usize << (T__115 - 115)) | (1usize << (T__116 - 115)) | (1usize << (T__117 - 115)) | (1usize << (T__118 - 115)) | (1usize << (T__119 - 115)) | (1usize << (T__120 - 115)) | (1usize << (T__121 - 115)) | (1usize << (T__122 - 115)) | (1usize << (T__123 - 115)) | (1usize << (T__128 - 115)) | (1usize << (T__129 - 115)) | (1usize << (T__130 - 115)) | (1usize << (T__131 - 115)))) != 0) {
				{
				{
				/*InvokeRule importBVIStmt*/
				recog.base.set_state(2420);
				recog.importBVIStmt()?;

				}
				}
				recog.base.set_state(2425);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2426);
			recog.base.match_token(T__22,&mut recog.err_handler)?;

			recog.base.set_state(2429);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(2427);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(2428);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importBVIStmt ----------------
pub type ImportBVIStmtContextAll<'input> = ImportBVIStmtContext<'input>;


pub type ImportBVIStmtContext<'input> = BaseParserRuleContext<'input,ImportBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ImportBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ImportBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ImportBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_importBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importBVIStmt }
}
antlr_rust::type_id!{ImportBVIStmtContextExt<'a>}

impl<'input> ImportBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ImportBVIStmtContextExt<'input>>{

fn parameterBVIStmt(&self) -> Option<Rc<ParameterBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodBVIStmt(&self) -> Option<Rc<MethodBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn portBVIStmt(&self) -> Option<Rc<PortBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inputClockBVIStmt(&self) -> Option<Rc<InputClockBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn defaultClockBVIStmt(&self) -> Option<Rc<DefaultClockBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn outputClockBVIStmt(&self) -> Option<Rc<OutputClockBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inputResetBVIStmt(&self) -> Option<Rc<InputResetBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn defaultResetBVIStmt(&self) -> Option<Rc<DefaultResetBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn noResetBVIStmt(&self) -> Option<Rc<NoResetBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn outputResetBVIStmt(&self) -> Option<Rc<OutputResetBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ancestorBVIStmt(&self) -> Option<Rc<AncestorBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sameFamilyBVIStmt(&self) -> Option<Rc<SameFamilyBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn scheduleBVIStmt(&self) -> Option<Rc<ScheduleBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pathBVIStmt(&self) -> Option<Rc<PathBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceBVIStmt(&self) -> Option<Rc<InterfaceBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inoutBVIStmt(&self) -> Option<Rc<InoutBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImportBVIStmtContextAttrs<'input> for ImportBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importBVIStmt(&mut self,)
	-> Result<Rc<ImportBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 326, RULE_importBVIStmt);
        let mut _localctx: Rc<ImportBVIStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2447);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__24 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule parameterBVIStmt*/
					recog.base.set_state(2431);
					recog.parameterBVIStmt()?;

					}
				}

			 T__21 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule methodBVIStmt*/
					recog.base.set_state(2432);
					recog.methodBVIStmt()?;

					}
				}

			 T__114 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule portBVIStmt*/
					recog.base.set_state(2433);
					recog.portBVIStmt()?;

					}
				}

			 T__115 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule inputClockBVIStmt*/
					recog.base.set_state(2434);
					recog.inputClockBVIStmt()?;

					}
				}

			 T__116 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule defaultClockBVIStmt*/
					recog.base.set_state(2435);
					recog.defaultClockBVIStmt()?;

					}
				}

			 T__117 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule outputClockBVIStmt*/
					recog.base.set_state(2436);
					recog.outputClockBVIStmt()?;

					}
				}

			 T__118 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule inputResetBVIStmt*/
					recog.base.set_state(2437);
					recog.inputResetBVIStmt()?;

					}
				}

			 T__119 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule defaultResetBVIStmt*/
					recog.base.set_state(2438);
					recog.defaultResetBVIStmt()?;

					}
				}

			 T__131 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule noResetBVIStmt*/
					recog.base.set_state(2439);
					recog.noResetBVIStmt()?;

					}
				}

			 T__120 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule outputResetBVIStmt*/
					recog.base.set_state(2440);
					recog.outputResetBVIStmt()?;

					}
				}

			 T__121 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule ancestorBVIStmt*/
					recog.base.set_state(2441);
					recog.ancestorBVIStmt()?;

					}
				}

			 T__122 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule sameFamilyBVIStmt*/
					recog.base.set_state(2442);
					recog.sameFamilyBVIStmt()?;

					}
				}

			 T__123 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule scheduleBVIStmt*/
					recog.base.set_state(2443);
					recog.scheduleBVIStmt()?;

					}
				}

			 T__128 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule pathBVIStmt*/
					recog.base.set_state(2444);
					recog.pathBVIStmt()?;

					}
				}

			 T__17 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule interfaceBVIStmt*/
					recog.base.set_state(2445);
					recog.interfaceBVIStmt()?;

					}
				}

			 T__129 | T__130 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					/*InvokeRule inoutBVIStmt*/
					recog.base.set_state(2446);
					recog.inoutBVIStmt()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enabled_sel ----------------
pub type Enabled_selContextAll<'input> = Enabled_selContext<'input>;


pub type Enabled_selContext<'input> = BaseParserRuleContext<'input,Enabled_selContextExt<'input>>;

#[derive(Clone)]
pub struct Enabled_selContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Enabled_selContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Enabled_selContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_enabled_sel(self);
	}
}

impl<'input> CustomRuleContext<'input> for Enabled_selContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enabled_sel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enabled_sel }
}
antlr_rust::type_id!{Enabled_selContextExt<'a>}

impl<'input> Enabled_selContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Enabled_selContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Enabled_selContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Enabled_selContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Enabled_selContextExt<'input>>{

fn portId(&self) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Enabled_selContextAttrs<'input> for Enabled_selContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enabled_sel(&mut self,)
	-> Result<Rc<Enabled_selContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Enabled_selContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_enabled_sel);
        let mut _localctx: Rc<Enabled_selContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(2449);
			recog.base.match_token(T__112,&mut recog.err_handler)?;

			recog.base.set_state(2450);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule portId*/
			recog.base.set_state(2451);
			recog.portId()?;

			recog.base.set_state(2452);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ready_sel ----------------
pub type Ready_selContextAll<'input> = Ready_selContext<'input>;


pub type Ready_selContext<'input> = BaseParserRuleContext<'input,Ready_selContextExt<'input>>;

#[derive(Clone)]
pub struct Ready_selContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Ready_selContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Ready_selContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ready_sel(self);
	}
}

impl<'input> CustomRuleContext<'input> for Ready_selContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ready_sel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ready_sel }
}
antlr_rust::type_id!{Ready_selContextExt<'a>}

impl<'input> Ready_selContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Ready_selContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Ready_selContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Ready_selContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Ready_selContextExt<'input>>{

fn portId(&self) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Ready_selContextAttrs<'input> for Ready_selContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ready_sel(&mut self,)
	-> Result<Rc<Ready_selContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Ready_selContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_ready_sel);
        let mut _localctx: Rc<Ready_selContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(2454);
			recog.base.match_token(T__113,&mut recog.err_handler)?;

			recog.base.set_state(2455);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule portId*/
			recog.base.set_state(2456);
			recog.portId()?;

			recog.base.set_state(2457);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- clocked_by_sel ----------------
pub type Clocked_by_selContextAll<'input> = Clocked_by_selContext<'input>;


pub type Clocked_by_selContext<'input> = BaseParserRuleContext<'input,Clocked_by_selContextExt<'input>>;

#[derive(Clone)]
pub struct Clocked_by_selContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Clocked_by_selContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Clocked_by_selContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_clocked_by_sel(self);
	}
}

impl<'input> CustomRuleContext<'input> for Clocked_by_selContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_clocked_by_sel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_clocked_by_sel }
}
antlr_rust::type_id!{Clocked_by_selContextExt<'a>}

impl<'input> Clocked_by_selContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Clocked_by_selContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Clocked_by_selContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Clocked_by_selContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Clocked_by_selContextExt<'input>>{

fn clockId(&self) -> Option<Rc<ClockIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Clocked_by_selContextAttrs<'input> for Clocked_by_selContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn clocked_by_sel(&mut self,)
	-> Result<Rc<Clocked_by_selContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Clocked_by_selContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_clocked_by_sel);
        let mut _localctx: Rc<Clocked_by_selContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(2459);
			recog.base.match_token(T__91,&mut recog.err_handler)?;

			recog.base.set_state(2460);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule clockId*/
			recog.base.set_state(2461);
			recog.clockId()?;

			recog.base.set_state(2462);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- reset_by_sel ----------------
pub type Reset_by_selContextAll<'input> = Reset_by_selContext<'input>;


pub type Reset_by_selContext<'input> = BaseParserRuleContext<'input,Reset_by_selContextExt<'input>>;

#[derive(Clone)]
pub struct Reset_by_selContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for Reset_by_selContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for Reset_by_selContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_reset_by_sel(self);
	}
}

impl<'input> CustomRuleContext<'input> for Reset_by_selContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_reset_by_sel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_reset_by_sel }
}
antlr_rust::type_id!{Reset_by_selContextExt<'a>}

impl<'input> Reset_by_selContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Reset_by_selContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Reset_by_selContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Reset_by_selContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<Reset_by_selContextExt<'input>>{

fn resetId(&self) -> Option<Rc<ResetIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Reset_by_selContextAttrs<'input> for Reset_by_selContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn reset_by_sel(&mut self,)
	-> Result<Rc<Reset_by_selContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Reset_by_selContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_reset_by_sel);
        let mut _localctx: Rc<Reset_by_selContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(2464);
			recog.base.match_token(T__92,&mut recog.err_handler)?;

			recog.base.set_state(2465);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule resetId*/
			recog.base.set_state(2466);
			recog.resetId()?;

			recog.base.set_state(2467);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterBVIStmt ----------------
pub type ParameterBVIStmtContextAll<'input> = ParameterBVIStmtContext<'input>;


pub type ParameterBVIStmtContext<'input> = BaseParserRuleContext<'input,ParameterBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ParameterBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ParameterBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parameterBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterBVIStmt }
}
antlr_rust::type_id!{ParameterBVIStmtContextExt<'a>}

impl<'input> ParameterBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ParameterBVIStmtContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ParameterBVIStmtContextAttrs<'input> for ParameterBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterBVIStmt(&mut self,)
	-> Result<Rc<ParameterBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_parameterBVIStmt);
        let mut _localctx: Rc<ParameterBVIStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2469);
			recog.base.match_token(T__24,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(2470);
			recog.identifier()?;

			recog.base.set_state(2471);
			recog.base.match_token(T__29,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2472);
			recog.expression_rec(0)?;

			recog.base.set_state(2473);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodBVIStmt ----------------
pub type MethodBVIStmtContextAll<'input> = MethodBVIStmtContext<'input>;


pub type MethodBVIStmtContext<'input> = BaseParserRuleContext<'input,MethodBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct MethodBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for MethodBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for MethodBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_methodBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodBVIStmt }
}
antlr_rust::type_id!{MethodBVIStmtContextExt<'a>}

impl<'input> MethodBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<MethodBVIStmtContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn portId_all(&self) ->  Vec<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn portId(&self, i: usize) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn enabled_sel_all(&self) ->  Vec<Rc<Enabled_selContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn enabled_sel(&self, i: usize) -> Option<Rc<Enabled_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn ready_sel_all(&self) ->  Vec<Rc<Ready_selContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn ready_sel(&self, i: usize) -> Option<Rc<Ready_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn clocked_by_sel_all(&self) ->  Vec<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn clocked_by_sel(&self, i: usize) -> Option<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn reset_by_sel_all(&self) ->  Vec<Rc<Reset_by_selContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn reset_by_sel(&self, i: usize) -> Option<Rc<Reset_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodBVIStmtContextAttrs<'input> for MethodBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodBVIStmt(&mut self,)
	-> Result<Rc<MethodBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_methodBVIStmt);
        let mut _localctx: Rc<MethodBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2475);
			recog.base.match_token(T__21,&mut recog.err_handler)?;

			recog.base.set_state(2477);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(267,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule portId*/
					recog.base.set_state(2476);
					recog.portId()?;

					}
				}

				_ => {}
			}
			/*InvokeRule identifier*/
			recog.base.set_state(2479);
			recog.identifier()?;

			recog.base.set_state(2492);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__8 {
				{
				recog.base.set_state(2480);
				recog.base.match_token(T__8,&mut recog.err_handler)?;

				recog.base.set_state(2489);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==T__101 || _la==LOWER_IDENTIFIER {
					{
					/*InvokeRule portId*/
					recog.base.set_state(2481);
					recog.portId()?;

					recog.base.set_state(2486);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__5 {
						{
						{
						recog.base.set_state(2482);
						recog.base.match_token(T__5,&mut recog.err_handler)?;

						/*InvokeRule portId*/
						recog.base.set_state(2483);
						recog.portId()?;

						}
						}
						recog.base.set_state(2488);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				recog.base.set_state(2491);
				recog.base.match_token(T__10,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2500);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 92)) & !0x3f) == 0 && ((1usize << (_la - 92)) & ((1usize << (T__91 - 92)) | (1usize << (T__92 - 92)) | (1usize << (T__112 - 92)) | (1usize << (T__113 - 92)))) != 0) {
				{
				recog.base.set_state(2498);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 T__112 
					=> {
						{
						/*InvokeRule enabled_sel*/
						recog.base.set_state(2494);
						recog.enabled_sel()?;

						}
					}

				 T__113 
					=> {
						{
						/*InvokeRule ready_sel*/
						recog.base.set_state(2495);
						recog.ready_sel()?;

						}
					}

				 T__91 
					=> {
						{
						/*InvokeRule clocked_by_sel*/
						recog.base.set_state(2496);
						recog.clocked_by_sel()?;

						}
					}

				 T__92 
					=> {
						{
						/*InvokeRule reset_by_sel*/
						recog.base.set_state(2497);
						recog.reset_by_sel()?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
				recog.base.set_state(2502);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2503);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- portBVIStmt ----------------
pub type PortBVIStmtContextAll<'input> = PortBVIStmtContext<'input>;


pub type PortBVIStmtContext<'input> = BaseParserRuleContext<'input,PortBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct PortBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for PortBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for PortBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_portBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for PortBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_portBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_portBVIStmt }
}
antlr_rust::type_id!{PortBVIStmtContextExt<'a>}

impl<'input> PortBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PortBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PortBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PortBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<PortBVIStmtContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clocked_by_sel_all(&self) ->  Vec<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn clocked_by_sel(&self, i: usize) -> Option<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn reset_by_sel_all(&self) ->  Vec<Rc<Reset_by_selContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn reset_by_sel(&self, i: usize) -> Option<Rc<Reset_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PortBVIStmtContextAttrs<'input> for PortBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn portBVIStmt(&mut self,)
	-> Result<Rc<PortBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PortBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_portBVIStmt);
        let mut _localctx: Rc<PortBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2505);
			recog.base.match_token(T__114,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(2506);
			recog.identifier()?;

			recog.base.set_state(2511);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__91 || _la==T__92 {
				{
				recog.base.set_state(2509);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 T__91 
					=> {
						{
						/*InvokeRule clocked_by_sel*/
						recog.base.set_state(2507);
						recog.clocked_by_sel()?;

						}
					}

				 T__92 
					=> {
						{
						/*InvokeRule reset_by_sel*/
						recog.base.set_state(2508);
						recog.reset_by_sel()?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
				recog.base.set_state(2513);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2514);
			recog.base.match_token(T__29,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2515);
			recog.expression_rec(0)?;

			recog.base.set_state(2516);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inputClockBVIStmt ----------------
pub type InputClockBVIStmtContextAll<'input> = InputClockBVIStmtContext<'input>;


pub type InputClockBVIStmtContext<'input> = BaseParserRuleContext<'input,InputClockBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct InputClockBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InputClockBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InputClockBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_inputClockBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for InputClockBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inputClockBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inputClockBVIStmt }
}
antlr_rust::type_id!{InputClockBVIStmtContextExt<'a>}

impl<'input> InputClockBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InputClockBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InputClockBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InputClockBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InputClockBVIStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn portsDef(&self) -> Option<Rc<PortsDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InputClockBVIStmtContextAttrs<'input> for InputClockBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inputClockBVIStmt(&mut self,)
	-> Result<Rc<InputClockBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InputClockBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_inputClockBVIStmt);
        let mut _localctx: Rc<InputClockBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2518);
			recog.base.match_token(T__115,&mut recog.err_handler)?;

			recog.base.set_state(2520);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(2519);
				recog.identifier()?;

				}
			}

			recog.base.set_state(2522);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			recog.base.set_state(2524);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__101 || _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule portsDef*/
				recog.base.set_state(2523);
				recog.portsDef()?;

				}
			}

			recog.base.set_state(2526);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(2527);
			recog.base.match_token(T__29,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2528);
			recog.expression_rec(0)?;

			recog.base.set_state(2529);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- portsDef ----------------
pub type PortsDefContextAll<'input> = PortsDefContext<'input>;


pub type PortsDefContext<'input> = BaseParserRuleContext<'input,PortsDefContextExt<'input>>;

#[derive(Clone)]
pub struct PortsDefContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for PortsDefContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for PortsDefContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_portsDef(self);
	}
}

impl<'input> CustomRuleContext<'input> for PortsDefContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_portsDef }
	//fn type_rule_index() -> usize where Self: Sized { RULE_portsDef }
}
antlr_rust::type_id!{PortsDefContextExt<'a>}

impl<'input> PortsDefContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PortsDefContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PortsDefContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PortsDefContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<PortsDefContextExt<'input>>{

fn portId_all(&self) ->  Vec<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn portId(&self, i: usize) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn attribute_instances(&self) -> Option<Rc<Attribute_instancesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PortsDefContextAttrs<'input> for PortsDefContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn portsDef(&mut self,)
	-> Result<Rc<PortsDefContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PortsDefContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 344, RULE_portsDef);
        let mut _localctx: Rc<PortsDefContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule portId*/
			recog.base.set_state(2531);
			recog.portId()?;

			recog.base.set_state(2536);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__5 {
				{
				recog.base.set_state(2532);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule attribute_instances*/
				recog.base.set_state(2533);
				recog.attribute_instances()?;

				/*InvokeRule portId*/
				recog.base.set_state(2534);
				recog.portId()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- portId ----------------
pub type PortIdContextAll<'input> = PortIdContext<'input>;


pub type PortIdContext<'input> = BaseParserRuleContext<'input,PortIdContextExt<'input>>;

#[derive(Clone)]
pub struct PortIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for PortIdContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for PortIdContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_portId(self);
	}
}

impl<'input> CustomRuleContext<'input> for PortIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_portId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_portId }
}
antlr_rust::type_id!{PortIdContextExt<'a>}

impl<'input> PortIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PortIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PortIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PortIdContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<PortIdContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attribute_instance(&self) -> Option<Rc<Attribute_instanceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PortIdContextAttrs<'input> for PortIdContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn portId(&mut self,)
	-> Result<Rc<PortIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PortIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 346, RULE_portId);
        let mut _localctx: Rc<PortIdContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2539);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__101 {
				{
				/*InvokeRule attribute_instance*/
				recog.base.set_state(2538);
				recog.attribute_instance()?;

				}
			}

			/*InvokeRule identifier*/
			recog.base.set_state(2541);
			recog.identifier()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultClockBVIStmt ----------------
pub type DefaultClockBVIStmtContextAll<'input> = DefaultClockBVIStmtContext<'input>;


pub type DefaultClockBVIStmtContext<'input> = BaseParserRuleContext<'input,DefaultClockBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultClockBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for DefaultClockBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for DefaultClockBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultClockBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultClockBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultClockBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultClockBVIStmt }
}
antlr_rust::type_id!{DefaultClockBVIStmtContextExt<'a>}

impl<'input> DefaultClockBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultClockBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultClockBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultClockBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<DefaultClockBVIStmtContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn portsDef(&self) -> Option<Rc<PortsDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultClockBVIStmtContextAttrs<'input> for DefaultClockBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultClockBVIStmt(&mut self,)
	-> Result<Rc<DefaultClockBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultClockBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 348, RULE_defaultClockBVIStmt);
        let mut _localctx: Rc<DefaultClockBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2543);
			recog.base.match_token(T__116,&mut recog.err_handler)?;

			recog.base.set_state(2545);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(2544);
				recog.identifier()?;

				}
			}

			recog.base.set_state(2552);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__8 {
				{
				recog.base.set_state(2547);
				recog.base.match_token(T__8,&mut recog.err_handler)?;

				recog.base.set_state(2549);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==T__101 || _la==LOWER_IDENTIFIER {
					{
					/*InvokeRule portsDef*/
					recog.base.set_state(2548);
					recog.portsDef()?;

					}
				}

				recog.base.set_state(2551);
				recog.base.match_token(T__10,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2556);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__29 {
				{
				recog.base.set_state(2554);
				recog.base.match_token(T__29,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2555);
				recog.expression_rec(0)?;

				}
			}

			recog.base.set_state(2558);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- outputClockBVIStmt ----------------
pub type OutputClockBVIStmtContextAll<'input> = OutputClockBVIStmtContext<'input>;


pub type OutputClockBVIStmtContext<'input> = BaseParserRuleContext<'input,OutputClockBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct OutputClockBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for OutputClockBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for OutputClockBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_outputClockBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for OutputClockBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_outputClockBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_outputClockBVIStmt }
}
antlr_rust::type_id!{OutputClockBVIStmtContextExt<'a>}

impl<'input> OutputClockBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OutputClockBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OutputClockBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OutputClockBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<OutputClockBVIStmtContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn portsDef(&self) -> Option<Rc<PortsDefContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OutputClockBVIStmtContextAttrs<'input> for OutputClockBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn outputClockBVIStmt(&mut self,)
	-> Result<Rc<OutputClockBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OutputClockBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 350, RULE_outputClockBVIStmt);
        let mut _localctx: Rc<OutputClockBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2560);
			recog.base.match_token(T__117,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(2561);
			recog.identifier()?;

			recog.base.set_state(2562);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			recog.base.set_state(2564);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__101 || _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule portsDef*/
				recog.base.set_state(2563);
				recog.portsDef()?;

				}
			}

			recog.base.set_state(2566);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(2567);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inputResetBVIStmt ----------------
pub type InputResetBVIStmtContextAll<'input> = InputResetBVIStmtContext<'input>;


pub type InputResetBVIStmtContext<'input> = BaseParserRuleContext<'input,InputResetBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct InputResetBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InputResetBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InputResetBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_inputResetBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for InputResetBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inputResetBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inputResetBVIStmt }
}
antlr_rust::type_id!{InputResetBVIStmtContextExt<'a>}

impl<'input> InputResetBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InputResetBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InputResetBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InputResetBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InputResetBVIStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clocked_by_sel(&self) -> Option<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn portId(&self) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InputResetBVIStmtContextAttrs<'input> for InputResetBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inputResetBVIStmt(&mut self,)
	-> Result<Rc<InputResetBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InputResetBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 352, RULE_inputResetBVIStmt);
        let mut _localctx: Rc<InputResetBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2569);
			recog.base.match_token(T__118,&mut recog.err_handler)?;

			recog.base.set_state(2571);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(2570);
				recog.identifier()?;

				}
			}

			recog.base.set_state(2578);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__8 {
				{
				recog.base.set_state(2573);
				recog.base.match_token(T__8,&mut recog.err_handler)?;

				recog.base.set_state(2575);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==T__101 || _la==LOWER_IDENTIFIER {
					{
					/*InvokeRule portId*/
					recog.base.set_state(2574);
					recog.portId()?;

					}
				}

				recog.base.set_state(2577);
				recog.base.match_token(T__10,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2581);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__91 {
				{
				/*InvokeRule clocked_by_sel*/
				recog.base.set_state(2580);
				recog.clocked_by_sel()?;

				}
			}

			recog.base.set_state(2583);
			recog.base.match_token(T__29,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2584);
			recog.expression_rec(0)?;

			recog.base.set_state(2585);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- clockId ----------------
pub type ClockIdContextAll<'input> = ClockIdContext<'input>;


pub type ClockIdContext<'input> = BaseParserRuleContext<'input,ClockIdContextExt<'input>>;

#[derive(Clone)]
pub struct ClockIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ClockIdContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ClockIdContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_clockId(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClockIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_clockId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_clockId }
}
antlr_rust::type_id!{ClockIdContextExt<'a>}

impl<'input> ClockIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClockIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClockIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClockIdContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ClockIdContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClockIdContextAttrs<'input> for ClockIdContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn clockId(&mut self,)
	-> Result<Rc<ClockIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClockIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 354, RULE_clockId);
        let mut _localctx: Rc<ClockIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2587);
			recog.identifier()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultResetBVIStmt ----------------
pub type DefaultResetBVIStmtContextAll<'input> = DefaultResetBVIStmtContext<'input>;


pub type DefaultResetBVIStmtContext<'input> = BaseParserRuleContext<'input,DefaultResetBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultResetBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for DefaultResetBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for DefaultResetBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultResetBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultResetBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultResetBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultResetBVIStmt }
}
antlr_rust::type_id!{DefaultResetBVIStmtContextExt<'a>}

impl<'input> DefaultResetBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultResetBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultResetBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultResetBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<DefaultResetBVIStmtContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clocked_by_sel(&self) -> Option<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn portId(&self) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultResetBVIStmtContextAttrs<'input> for DefaultResetBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultResetBVIStmt(&mut self,)
	-> Result<Rc<DefaultResetBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultResetBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 356, RULE_defaultResetBVIStmt);
        let mut _localctx: Rc<DefaultResetBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2612);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(293,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2589);
					recog.base.match_token(T__119,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2590);
					recog.identifier()?;

					recog.base.set_state(2591);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2593);
					recog.base.match_token(T__119,&mut recog.err_handler)?;

					recog.base.set_state(2595);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LOWER_IDENTIFIER {
						{
						/*InvokeRule identifier*/
						recog.base.set_state(2594);
						recog.identifier()?;

						}
					}

					recog.base.set_state(2602);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__8 {
						{
						recog.base.set_state(2597);
						recog.base.match_token(T__8,&mut recog.err_handler)?;

						recog.base.set_state(2599);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==T__101 || _la==LOWER_IDENTIFIER {
							{
							/*InvokeRule portId*/
							recog.base.set_state(2598);
							recog.portId()?;

							}
						}

						recog.base.set_state(2601);
						recog.base.match_token(T__10,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2605);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__91 {
						{
						/*InvokeRule clocked_by_sel*/
						recog.base.set_state(2604);
						recog.clocked_by_sel()?;

						}
					}

					recog.base.set_state(2609);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==T__29 {
						{
						recog.base.set_state(2607);
						recog.base.match_token(T__29,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(2608);
						recog.expression_rec(0)?;

						}
					}

					recog.base.set_state(2611);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- outputResetBVIStmt ----------------
pub type OutputResetBVIStmtContextAll<'input> = OutputResetBVIStmtContext<'input>;


pub type OutputResetBVIStmtContext<'input> = BaseParserRuleContext<'input,OutputResetBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct OutputResetBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for OutputResetBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for OutputResetBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_outputResetBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for OutputResetBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_outputResetBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_outputResetBVIStmt }
}
antlr_rust::type_id!{OutputResetBVIStmtContextExt<'a>}

impl<'input> OutputResetBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OutputResetBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OutputResetBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OutputResetBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<OutputResetBVIStmtContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clocked_by_sel(&self) -> Option<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn portId(&self) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OutputResetBVIStmtContextAttrs<'input> for OutputResetBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn outputResetBVIStmt(&mut self,)
	-> Result<Rc<OutputResetBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OutputResetBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 358, RULE_outputResetBVIStmt);
        let mut _localctx: Rc<OutputResetBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2614);
			recog.base.match_token(T__120,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(2615);
			recog.identifier()?;

			recog.base.set_state(2621);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__8 {
				{
				recog.base.set_state(2616);
				recog.base.match_token(T__8,&mut recog.err_handler)?;

				recog.base.set_state(2618);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==T__101 || _la==LOWER_IDENTIFIER {
					{
					/*InvokeRule portId*/
					recog.base.set_state(2617);
					recog.portId()?;

					}
				}

				recog.base.set_state(2620);
				recog.base.match_token(T__10,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2624);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__91 {
				{
				/*InvokeRule clocked_by_sel*/
				recog.base.set_state(2623);
				recog.clocked_by_sel()?;

				}
			}

			recog.base.set_state(2626);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ancestorBVIStmt ----------------
pub type AncestorBVIStmtContextAll<'input> = AncestorBVIStmtContext<'input>;


pub type AncestorBVIStmtContext<'input> = BaseParserRuleContext<'input,AncestorBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct AncestorBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for AncestorBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for AncestorBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ancestorBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for AncestorBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ancestorBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ancestorBVIStmt }
}
antlr_rust::type_id!{AncestorBVIStmtContextExt<'a>}

impl<'input> AncestorBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AncestorBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AncestorBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AncestorBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<AncestorBVIStmtContextExt<'input>>{

fn clockId_all(&self) ->  Vec<Rc<ClockIdContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn clockId(&self, i: usize) -> Option<Rc<ClockIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AncestorBVIStmtContextAttrs<'input> for AncestorBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ancestorBVIStmt(&mut self,)
	-> Result<Rc<AncestorBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AncestorBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 360, RULE_ancestorBVIStmt);
        let mut _localctx: Rc<AncestorBVIStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2628);
			recog.base.match_token(T__121,&mut recog.err_handler)?;

			recog.base.set_state(2629);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule clockId*/
			recog.base.set_state(2630);
			recog.clockId()?;

			recog.base.set_state(2631);
			recog.base.match_token(T__5,&mut recog.err_handler)?;

			/*InvokeRule clockId*/
			recog.base.set_state(2632);
			recog.clockId()?;

			recog.base.set_state(2633);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(2634);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sameFamilyBVIStmt ----------------
pub type SameFamilyBVIStmtContextAll<'input> = SameFamilyBVIStmtContext<'input>;


pub type SameFamilyBVIStmtContext<'input> = BaseParserRuleContext<'input,SameFamilyBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct SameFamilyBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for SameFamilyBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for SameFamilyBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_sameFamilyBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for SameFamilyBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sameFamilyBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sameFamilyBVIStmt }
}
antlr_rust::type_id!{SameFamilyBVIStmtContextExt<'a>}

impl<'input> SameFamilyBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SameFamilyBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SameFamilyBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SameFamilyBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<SameFamilyBVIStmtContextExt<'input>>{

fn clockId_all(&self) ->  Vec<Rc<ClockIdContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn clockId(&self, i: usize) -> Option<Rc<ClockIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SameFamilyBVIStmtContextAttrs<'input> for SameFamilyBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sameFamilyBVIStmt(&mut self,)
	-> Result<Rc<SameFamilyBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SameFamilyBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 362, RULE_sameFamilyBVIStmt);
        let mut _localctx: Rc<SameFamilyBVIStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2636);
			recog.base.match_token(T__122,&mut recog.err_handler)?;

			recog.base.set_state(2637);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule clockId*/
			recog.base.set_state(2638);
			recog.clockId()?;

			recog.base.set_state(2639);
			recog.base.match_token(T__5,&mut recog.err_handler)?;

			/*InvokeRule clockId*/
			recog.base.set_state(2640);
			recog.clockId()?;

			recog.base.set_state(2641);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(2642);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- scheduleBVIStmt ----------------
pub type ScheduleBVIStmtContextAll<'input> = ScheduleBVIStmtContext<'input>;


pub type ScheduleBVIStmtContext<'input> = BaseParserRuleContext<'input,ScheduleBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ScheduleBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ScheduleBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ScheduleBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_scheduleBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ScheduleBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_scheduleBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_scheduleBVIStmt }
}
antlr_rust::type_id!{ScheduleBVIStmtContextExt<'a>}

impl<'input> ScheduleBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ScheduleBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ScheduleBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ScheduleBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ScheduleBVIStmtContextExt<'input>>{

fn operatorId(&self) -> Option<Rc<OperatorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ScheduleBVIStmtContextAttrs<'input> for ScheduleBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn scheduleBVIStmt(&mut self,)
	-> Result<Rc<ScheduleBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ScheduleBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 364, RULE_scheduleBVIStmt);
        let mut _localctx: Rc<ScheduleBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2644);
			recog.base.match_token(T__123,&mut recog.err_handler)?;

			recog.base.set_state(2657);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__8 
				=> {
					{
					recog.base.set_state(2645);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2646);
					recog.identifier()?;

					recog.base.set_state(2651);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__5 {
						{
						{
						recog.base.set_state(2647);
						recog.base.match_token(T__5,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(2648);
						recog.identifier()?;

						}
						}
						recog.base.set_state(2653);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2654);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}

			 LOWER_IDENTIFIER 
				=> {
					{
					/*InvokeRule identifier*/
					recog.base.set_state(2656);
					recog.identifier()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			/*InvokeRule operatorId*/
			recog.base.set_state(2659);
			recog.operatorId()?;

			recog.base.set_state(2672);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__8 
				=> {
					{
					recog.base.set_state(2660);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2661);
					recog.identifier()?;

					recog.base.set_state(2666);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__5 {
						{
						{
						recog.base.set_state(2662);
						recog.base.match_token(T__5,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(2663);
						recog.identifier()?;

						}
						}
						recog.base.set_state(2668);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2669);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					}
				}

			 LOWER_IDENTIFIER 
				=> {
					{
					/*InvokeRule identifier*/
					recog.base.set_state(2671);
					recog.identifier()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(2674);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- operatorId ----------------
pub type OperatorIdContextAll<'input> = OperatorIdContext<'input>;


pub type OperatorIdContext<'input> = BaseParserRuleContext<'input,OperatorIdContextExt<'input>>;

#[derive(Clone)]
pub struct OperatorIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for OperatorIdContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for OperatorIdContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_operatorId(self);
	}
}

impl<'input> CustomRuleContext<'input> for OperatorIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_operatorId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_operatorId }
}
antlr_rust::type_id!{OperatorIdContextExt<'a>}

impl<'input> OperatorIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OperatorIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OperatorIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OperatorIdContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<OperatorIdContextExt<'input>>{


}

impl<'input> OperatorIdContextAttrs<'input> for OperatorIdContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn operatorId(&mut self,)
	-> Result<Rc<OperatorIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OperatorIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 366, RULE_operatorId);
        let mut _localctx: Rc<OperatorIdContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2676);
			_la = recog.base.input.la(1);
			if { !(((((_la - 125)) & !0x3f) == 0 && ((1usize << (_la - 125)) & ((1usize << (T__124 - 125)) | (1usize << (T__125 - 125)) | (1usize << (T__126 - 125)) | (1usize << (T__127 - 125)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pathBVIStmt ----------------
pub type PathBVIStmtContextAll<'input> = PathBVIStmtContext<'input>;


pub type PathBVIStmtContext<'input> = BaseParserRuleContext<'input,PathBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct PathBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for PathBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for PathBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_pathBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for PathBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pathBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pathBVIStmt }
}
antlr_rust::type_id!{PathBVIStmtContextExt<'a>}

impl<'input> PathBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PathBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PathBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PathBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<PathBVIStmtContextExt<'input>>{

fn portId_all(&self) ->  Vec<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn portId(&self, i: usize) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PathBVIStmtContextAttrs<'input> for PathBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pathBVIStmt(&mut self,)
	-> Result<Rc<PathBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PathBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 368, RULE_pathBVIStmt);
        let mut _localctx: Rc<PathBVIStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2678);
			recog.base.match_token(T__128,&mut recog.err_handler)?;

			recog.base.set_state(2679);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule portId*/
			recog.base.set_state(2680);
			recog.portId()?;

			recog.base.set_state(2681);
			recog.base.match_token(T__5,&mut recog.err_handler)?;

			/*InvokeRule portId*/
			recog.base.set_state(2682);
			recog.portId()?;

			recog.base.set_state(2683);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(2684);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceBVIStmt ----------------
pub type InterfaceBVIStmtContextAll<'input> = InterfaceBVIStmtContext<'input>;


pub type InterfaceBVIStmtContext<'input> = BaseParserRuleContext<'input,InterfaceBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InterfaceBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InterfaceBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_interfaceBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceBVIStmt }
}
antlr_rust::type_id!{InterfaceBVIStmtContextExt<'a>}

impl<'input> InterfaceBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InterfaceBVIStmtContextExt<'input>>{

fn typeDefType(&self) -> Option<Rc<TypeDefTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn type_identifier_all(&self) ->  Vec<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn type_identifier(&self, i: usize) -> Option<Rc<Type_identifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn interfaceBVIMembDecl_all(&self) ->  Vec<Rc<InterfaceBVIMembDeclContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceBVIMembDecl(&self, i: usize) -> Option<Rc<InterfaceBVIMembDeclContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> InterfaceBVIStmtContextAttrs<'input> for InterfaceBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceBVIStmt(&mut self,)
	-> Result<Rc<InterfaceBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 370, RULE_interfaceBVIStmt);
        let mut _localctx: Rc<InterfaceBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2686);
			recog.base.match_token(T__17,&mut recog.err_handler)?;

			/*InvokeRule typeDefType*/
			recog.base.set_state(2687);
			recog.typeDefType()?;

			recog.base.set_state(2689);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__16 || _la==UPPER_IDENTIFIER || _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule type_identifier*/
				recog.base.set_state(2688);
				recog.type_identifier()?;

				}
			}

			recog.base.set_state(2691);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			recog.base.set_state(2695);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__17 || _la==T__21 {
				{
				{
				/*InvokeRule interfaceBVIMembDecl*/
				recog.base.set_state(2692);
				recog.interfaceBVIMembDecl()?;

				}
				}
				recog.base.set_state(2697);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2698);
			recog.base.match_token(T__18,&mut recog.err_handler)?;

			recog.base.set_state(2701);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__3 {
				{
				recog.base.set_state(2699);
				recog.base.match_token(T__3,&mut recog.err_handler)?;

				/*InvokeRule type_identifier*/
				recog.base.set_state(2700);
				recog.type_identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceBVIMembDecl ----------------
pub type InterfaceBVIMembDeclContextAll<'input> = InterfaceBVIMembDeclContext<'input>;


pub type InterfaceBVIMembDeclContext<'input> = BaseParserRuleContext<'input,InterfaceBVIMembDeclContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceBVIMembDeclContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InterfaceBVIMembDeclContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InterfaceBVIMembDeclContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_interfaceBVIMembDecl(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceBVIMembDeclContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceBVIMembDecl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceBVIMembDecl }
}
antlr_rust::type_id!{InterfaceBVIMembDeclContextExt<'a>}

impl<'input> InterfaceBVIMembDeclContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceBVIMembDeclContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceBVIMembDeclContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceBVIMembDeclContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InterfaceBVIMembDeclContextExt<'input>>{

fn methodBVIStmt(&self) -> Option<Rc<MethodBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceBVIStmt(&self) -> Option<Rc<InterfaceBVIStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceBVIMembDeclContextAttrs<'input> for InterfaceBVIMembDeclContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceBVIMembDecl(&mut self,)
	-> Result<Rc<InterfaceBVIMembDeclContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceBVIMembDeclContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 372, RULE_interfaceBVIMembDecl);
        let mut _localctx: Rc<InterfaceBVIMembDeclContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2705);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__21 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule methodBVIStmt*/
					recog.base.set_state(2703);
					recog.methodBVIStmt()?;

					}
				}

			 T__17 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule interfaceBVIStmt*/
					recog.base.set_state(2704);
					recog.interfaceBVIStmt()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inoutBVIStmt ----------------
pub type InoutBVIStmtContextAll<'input> = InoutBVIStmtContext<'input>;


pub type InoutBVIStmtContext<'input> = BaseParserRuleContext<'input,InoutBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct InoutBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for InoutBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for InoutBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_inoutBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for InoutBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inoutBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inoutBVIStmt }
}
antlr_rust::type_id!{InoutBVIStmtContextExt<'a>}

impl<'input> InoutBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InoutBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InoutBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InoutBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<InoutBVIStmtContextExt<'input>>{

fn portId(&self) -> Option<Rc<PortIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clocked_by_sel_all(&self) ->  Vec<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn clocked_by_sel(&self, i: usize) -> Option<Rc<Clocked_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn reset_by_sel_all(&self) ->  Vec<Rc<Reset_by_selContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn reset_by_sel(&self, i: usize) -> Option<Rc<Reset_by_selContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InoutBVIStmtContextAttrs<'input> for InoutBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inoutBVIStmt(&mut self,)
	-> Result<Rc<InoutBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InoutBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 374, RULE_inoutBVIStmt);
        let mut _localctx: Rc<InoutBVIStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2734);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__129 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2707);
					recog.base.match_token(T__129,&mut recog.err_handler)?;

					/*InvokeRule portId*/
					recog.base.set_state(2708);
					recog.portId()?;

					recog.base.set_state(2713);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__91 || _la==T__92 {
						{
						recog.base.set_state(2711);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 T__91 
							=> {
								{
								/*InvokeRule clocked_by_sel*/
								recog.base.set_state(2709);
								recog.clocked_by_sel()?;

								}
							}

						 T__92 
							=> {
								{
								/*InvokeRule reset_by_sel*/
								recog.base.set_state(2710);
								recog.reset_by_sel()?;

								}
							}

							_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						}
						recog.base.set_state(2715);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2716);
					recog.base.match_token(T__29,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2717);
					recog.expression_rec(0)?;

					recog.base.set_state(2718);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

			 T__130 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2720);
					recog.base.match_token(T__130,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2721);
					recog.identifier()?;

					recog.base.set_state(2722);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule portId*/
					recog.base.set_state(2723);
					recog.portId()?;

					recog.base.set_state(2724);
					recog.base.match_token(T__10,&mut recog.err_handler)?;

					recog.base.set_state(2729);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==T__91 || _la==T__92 {
						{
						recog.base.set_state(2727);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 T__91 
							=> {
								{
								/*InvokeRule clocked_by_sel*/
								recog.base.set_state(2725);
								recog.clocked_by_sel()?;

								}
							}

						 T__92 
							=> {
								{
								/*InvokeRule reset_by_sel*/
								recog.base.set_state(2726);
								recog.reset_by_sel()?;

								}
							}

							_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						}
						recog.base.set_state(2731);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2732);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- resetId ----------------
pub type ResetIdContextAll<'input> = ResetIdContext<'input>;


pub type ResetIdContext<'input> = BaseParserRuleContext<'input,ResetIdContextExt<'input>>;

#[derive(Clone)]
pub struct ResetIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ResetIdContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ResetIdContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_resetId(self);
	}
}

impl<'input> CustomRuleContext<'input> for ResetIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_resetId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_resetId }
}
antlr_rust::type_id!{ResetIdContextExt<'a>}

impl<'input> ResetIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResetIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResetIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResetIdContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ResetIdContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ResetIdContextAttrs<'input> for ResetIdContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn resetId(&mut self,)
	-> Result<Rc<ResetIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResetIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 376, RULE_resetId);
        let mut _localctx: Rc<ResetIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2736);
			recog.identifier()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- noResetBVIStmt ----------------
pub type NoResetBVIStmtContextAll<'input> = NoResetBVIStmtContext<'input>;


pub type NoResetBVIStmtContext<'input> = BaseParserRuleContext<'input,NoResetBVIStmtContextExt<'input>>;

#[derive(Clone)]
pub struct NoResetBVIStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for NoResetBVIStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for NoResetBVIStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_noResetBVIStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for NoResetBVIStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_noResetBVIStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_noResetBVIStmt }
}
antlr_rust::type_id!{NoResetBVIStmtContextExt<'a>}

impl<'input> NoResetBVIStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NoResetBVIStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NoResetBVIStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NoResetBVIStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<NoResetBVIStmtContextExt<'input>>{


}

impl<'input> NoResetBVIStmtContextAttrs<'input> for NoResetBVIStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn noResetBVIStmt(&mut self,)
	-> Result<Rc<NoResetBVIStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NoResetBVIStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 378, RULE_noResetBVIStmt);
        let mut _localctx: Rc<NoResetBVIStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2738);
			recog.base.match_token(T__131,&mut recog.err_handler)?;

			recog.base.set_state(2739);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- externCImport ----------------
pub type ExternCImportContextAll<'input> = ExternCImportContext<'input>;


pub type ExternCImportContext<'input> = BaseParserRuleContext<'input,ExternCImportContextExt<'input>>;

#[derive(Clone)]
pub struct ExternCImportContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ExternCImportContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExternCImportContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_externCImport(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExternCImportContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_externCImport }
	//fn type_rule_index() -> usize where Self: Sized { RULE_externCImport }
}
antlr_rust::type_id!{ExternCImportContextExt<'a>}

impl<'input> ExternCImportContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExternCImportContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExternCImportContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExternCImportContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ExternCImportContextExt<'input>>{

fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn cFuncArgs(&self) -> Option<Rc<CFuncArgsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn provisos(&self) -> Option<Rc<ProvisosContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExternCImportContextAttrs<'input> for ExternCImportContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn externCImport(&mut self,)
	-> Result<Rc<ExternCImportContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExternCImportContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 380, RULE_externCImport);
        let mut _localctx: Rc<ExternCImportContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2741);
			recog.base.match_token(T__11,&mut recog.err_handler)?;

			recog.base.set_state(2742);
			recog.base.match_token(T__132,&mut recog.err_handler)?;

			recog.base.set_state(2746);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(2743);
				recog.identifier()?;

				recog.base.set_state(2744);
				recog.base.match_token(T__29,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2748);
			recog.base.match_token(T__59,&mut recog.err_handler)?;

			/*InvokeRule data_type*/
			recog.base.set_state(2749);
			recog.data_type()?;

			/*InvokeRule identifier*/
			recog.base.set_state(2750);
			recog.identifier()?;

			recog.base.set_state(2751);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			recog.base.set_state(2753);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__13 || _la==T__16 || ((((_la - 145)) & !0x3f) == 0 && ((1usize << (_la - 145)) & ((1usize << (UPPER_IDENTIFIER - 145)) | (1usize << (LOWER_IDENTIFIER - 145)) | (1usize << (INT_LITERAL - 145)))) != 0) {
				{
				/*InvokeRule cFuncArgs*/
				recog.base.set_state(2752);
				recog.cFuncArgs()?;

				}
			}

			recog.base.set_state(2755);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			recog.base.set_state(2757);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==T__103 {
				{
				/*InvokeRule provisos*/
				recog.base.set_state(2756);
				recog.provisos()?;

				}
			}

			recog.base.set_state(2759);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cFuncArgs ----------------
pub type CFuncArgsContextAll<'input> = CFuncArgsContext<'input>;


pub type CFuncArgsContext<'input> = BaseParserRuleContext<'input,CFuncArgsContextExt<'input>>;

#[derive(Clone)]
pub struct CFuncArgsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CFuncArgsContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CFuncArgsContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_cFuncArgs(self);
	}
}

impl<'input> CustomRuleContext<'input> for CFuncArgsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cFuncArgs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cFuncArgs }
}
antlr_rust::type_id!{CFuncArgsContextExt<'a>}

impl<'input> CFuncArgsContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CFuncArgsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CFuncArgsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CFuncArgsContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CFuncArgsContextExt<'input>>{

fn cFuncArg_all(&self) ->  Vec<Rc<CFuncArgContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn cFuncArg(&self, i: usize) -> Option<Rc<CFuncArgContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CFuncArgsContextAttrs<'input> for CFuncArgsContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cFuncArgs(&mut self,)
	-> Result<Rc<CFuncArgsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CFuncArgsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 382, RULE_cFuncArgs);
        let mut _localctx: Rc<CFuncArgsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule cFuncArg*/
			recog.base.set_state(2761);
			recog.cFuncArg()?;

			recog.base.set_state(2766);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__5 {
				{
				{
				recog.base.set_state(2762);
				recog.base.match_token(T__5,&mut recog.err_handler)?;

				/*InvokeRule cFuncArg*/
				recog.base.set_state(2763);
				recog.cFuncArg()?;

				}
				}
				recog.base.set_state(2768);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cFuncArg ----------------
pub type CFuncArgContextAll<'input> = CFuncArgContext<'input>;


pub type CFuncArgContext<'input> = BaseParserRuleContext<'input,CFuncArgContextExt<'input>>;

#[derive(Clone)]
pub struct CFuncArgContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for CFuncArgContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for CFuncArgContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_cFuncArg(self);
	}
}

impl<'input> CustomRuleContext<'input> for CFuncArgContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cFuncArg }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cFuncArg }
}
antlr_rust::type_id!{CFuncArgContextExt<'a>}

impl<'input> CFuncArgContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CFuncArgContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CFuncArgContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CFuncArgContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<CFuncArgContextExt<'input>>{

fn data_type(&self) -> Option<Rc<Data_typeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CFuncArgContextAttrs<'input> for CFuncArgContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cFuncArg(&mut self,)
	-> Result<Rc<CFuncArgContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CFuncArgContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 384, RULE_cFuncArg);
        let mut _localctx: Rc<CFuncArgContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule data_type*/
			recog.base.set_state(2769);
			recog.data_type()?;

			recog.base.set_state(2771);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LOWER_IDENTIFIER {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(2770);
				recog.identifier()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fsmStmt ----------------
pub type FsmStmtContextAll<'input> = FsmStmtContext<'input>;


pub type FsmStmtContext<'input> = BaseParserRuleContext<'input,FsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct FsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for FsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for FsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_fsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for FsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fsmStmt }
}
antlr_rust::type_id!{FsmStmtContextExt<'a>}

impl<'input> FsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<FsmStmtContextExt<'input>>{

fn exprFsmStmt(&self) -> Option<Rc<ExprFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn seqFsmStmt(&self) -> Option<Rc<SeqFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parFsmStmt(&self) -> Option<Rc<ParFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifFsmStmt(&self) -> Option<Rc<IfFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whileFsmStmt(&self) -> Option<Rc<WhileFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn repeatFsmStmt(&self) -> Option<Rc<RepeatFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forFsmStmt(&self) -> Option<Rc<ForFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnFsmStmt(&self) -> Option<Rc<ReturnFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FsmStmtContextAttrs<'input> for FsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fsmStmt(&mut self,)
	-> Result<Rc<FsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 386, RULE_fsmStmt);
        let mut _localctx: Rc<FsmStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2781);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__8 | T__13 | T__16 | T__17 | T__35 | T__39 | T__49 | T__52 | T__61 |
			 T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 |
			 T__72 | T__73 | T__87 | T__88 | T__90 | T__91 | T__92 | UPPER_IDENTIFIER |
			 LOWER_IDENTIFIER | SYSTEM_TASK | STRING_LITERAL | INT_LITERAL | REAL_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule exprFsmStmt*/
					recog.base.set_state(2773);
					recog.exprFsmStmt()?;

					}
				}

			 T__133 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule seqFsmStmt*/
					recog.base.set_state(2774);
					recog.seqFsmStmt()?;

					}
				}

			 T__135 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule parFsmStmt*/
					recog.base.set_state(2775);
					recog.parFsmStmt()?;

					}
				}

			 T__30 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule ifFsmStmt*/
					recog.base.set_state(2776);
					recog.ifFsmStmt()?;

					}
				}

			 T__56 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule whileFsmStmt*/
					recog.base.set_state(2777);
					recog.whileFsmStmt()?;

					}
				}

			 T__137 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule repeatFsmStmt*/
					recog.base.set_state(2778);
					recog.repeatFsmStmt()?;

					}
				}

			 T__57 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule forFsmStmt*/
					recog.base.set_state(2779);
					recog.forFsmStmt()?;

					}
				}

			 T__60 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule returnFsmStmt*/
					recog.base.set_state(2780);
					recog.returnFsmStmt()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exprFsmStmt ----------------
pub type ExprFsmStmtContextAll<'input> = ExprFsmStmtContext<'input>;


pub type ExprFsmStmtContext<'input> = BaseParserRuleContext<'input,ExprFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ExprFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ExprFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ExprFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_exprFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExprFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exprFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exprFsmStmt }
}
antlr_rust::type_id!{ExprFsmStmtContextExt<'a>}

impl<'input> ExprFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExprFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExprFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExprFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ExprFsmStmtContextExt<'input>>{

fn regWrite(&self) -> Option<Rc<RegWriteContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExprFsmStmtContextAttrs<'input> for ExprFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exprFsmStmt(&mut self,)
	-> Result<Rc<ExprFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExprFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 388, RULE_exprFsmStmt);
        let mut _localctx: Rc<ExprFsmStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2789);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(316,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule regWrite*/
					recog.base.set_state(2783);
					recog.regWrite()?;

					recog.base.set_state(2784);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expression*/
					recog.base.set_state(2786);
					recog.expression_rec(0)?;

					recog.base.set_state(2787);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- seqFsmStmt ----------------
pub type SeqFsmStmtContextAll<'input> = SeqFsmStmtContext<'input>;


pub type SeqFsmStmtContext<'input> = BaseParserRuleContext<'input,SeqFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct SeqFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for SeqFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for SeqFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_seqFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for SeqFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_seqFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_seqFsmStmt }
}
antlr_rust::type_id!{SeqFsmStmtContextExt<'a>}

impl<'input> SeqFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SeqFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SeqFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SeqFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<SeqFsmStmtContextExt<'input>>{

fn fsmStmt_all(&self) ->  Vec<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fsmStmt(&self, i: usize) -> Option<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SeqFsmStmtContextAttrs<'input> for SeqFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn seqFsmStmt(&mut self,)
	-> Result<Rc<SeqFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SeqFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 390, RULE_seqFsmStmt);
        let mut _localctx: Rc<SeqFsmStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2791);
			recog.base.match_token(T__133,&mut recog.err_handler)?;

			/*InvokeRule fsmStmt*/
			recog.base.set_state(2792);
			recog.fsmStmt()?;

			recog.base.set_state(2796);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__60) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 134)) & !0x3f) == 0 && ((1usize << (_la - 134)) & ((1usize << (T__133 - 134)) | (1usize << (T__135 - 134)) | (1usize << (T__137 - 134)) | (1usize << (UPPER_IDENTIFIER - 134)) | (1usize << (LOWER_IDENTIFIER - 134)) | (1usize << (SYSTEM_TASK - 134)) | (1usize << (STRING_LITERAL - 134)) | (1usize << (INT_LITERAL - 134)) | (1usize << (REAL_LITERAL - 134)))) != 0) {
				{
				{
				/*InvokeRule fsmStmt*/
				recog.base.set_state(2793);
				recog.fsmStmt()?;

				}
				}
				recog.base.set_state(2798);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2799);
			recog.base.match_token(T__134,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parFsmStmt ----------------
pub type ParFsmStmtContextAll<'input> = ParFsmStmtContext<'input>;


pub type ParFsmStmtContext<'input> = BaseParserRuleContext<'input,ParFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ParFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ParFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ParFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parFsmStmt }
}
antlr_rust::type_id!{ParFsmStmtContextExt<'a>}

impl<'input> ParFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ParFsmStmtContextExt<'input>>{

fn fsmStmt_all(&self) ->  Vec<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fsmStmt(&self, i: usize) -> Option<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ParFsmStmtContextAttrs<'input> for ParFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parFsmStmt(&mut self,)
	-> Result<Rc<ParFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 392, RULE_parFsmStmt);
        let mut _localctx: Rc<ParFsmStmtContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2801);
			recog.base.match_token(T__135,&mut recog.err_handler)?;

			/*InvokeRule fsmStmt*/
			recog.base.set_state(2802);
			recog.fsmStmt()?;

			recog.base.set_state(2806);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__8) | (1usize << T__13) | (1usize << T__16) | (1usize << T__17) | (1usize << T__30) | (1usize << T__35) | (1usize << T__39) | (1usize << T__49) | (1usize << T__52) | (1usize << T__56) | (1usize << T__57) | (1usize << T__60) | (1usize << T__61))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (T__63 - 64)) | (1usize << (T__64 - 64)) | (1usize << (T__65 - 64)) | (1usize << (T__66 - 64)) | (1usize << (T__67 - 64)) | (1usize << (T__68 - 64)) | (1usize << (T__69 - 64)) | (1usize << (T__70 - 64)) | (1usize << (T__71 - 64)) | (1usize << (T__72 - 64)) | (1usize << (T__73 - 64)) | (1usize << (T__87 - 64)) | (1usize << (T__88 - 64)) | (1usize << (T__90 - 64)) | (1usize << (T__91 - 64)) | (1usize << (T__92 - 64)))) != 0) || ((((_la - 134)) & !0x3f) == 0 && ((1usize << (_la - 134)) & ((1usize << (T__133 - 134)) | (1usize << (T__135 - 134)) | (1usize << (T__137 - 134)) | (1usize << (UPPER_IDENTIFIER - 134)) | (1usize << (LOWER_IDENTIFIER - 134)) | (1usize << (SYSTEM_TASK - 134)) | (1usize << (STRING_LITERAL - 134)) | (1usize << (INT_LITERAL - 134)) | (1usize << (REAL_LITERAL - 134)))) != 0) {
				{
				{
				/*InvokeRule fsmStmt*/
				recog.base.set_state(2803);
				recog.fsmStmt()?;

				}
				}
				recog.base.set_state(2808);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2809);
			recog.base.match_token(T__136,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifFsmStmt ----------------
pub type IfFsmStmtContextAll<'input> = IfFsmStmtContext<'input>;


pub type IfFsmStmtContext<'input> = BaseParserRuleContext<'input,IfFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct IfFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for IfFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for IfFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ifFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifFsmStmt }
}
antlr_rust::type_id!{IfFsmStmtContextExt<'a>}

impl<'input> IfFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<IfFsmStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fsmStmt_all(&self) ->  Vec<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fsmStmt(&self, i: usize) -> Option<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> IfFsmStmtContextAttrs<'input> for IfFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifFsmStmt(&mut self,)
	-> Result<Rc<IfFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 394, RULE_ifFsmStmt);
        let mut _localctx: Rc<IfFsmStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2811);
			recog.base.match_token(T__30,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2812);
			recog.expression_rec(0)?;

			/*InvokeRule fsmStmt*/
			recog.base.set_state(2813);
			recog.fsmStmt()?;

			recog.base.set_state(2816);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(319,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2814);
					recog.base.match_token(T__51,&mut recog.err_handler)?;

					/*InvokeRule fsmStmt*/
					recog.base.set_state(2815);
					recog.fsmStmt()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whileFsmStmt ----------------
pub type WhileFsmStmtContextAll<'input> = WhileFsmStmtContext<'input>;


pub type WhileFsmStmtContext<'input> = BaseParserRuleContext<'input,WhileFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct WhileFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for WhileFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for WhileFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_whileFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhileFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whileFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whileFsmStmt }
}
antlr_rust::type_id!{WhileFsmStmtContextExt<'a>}

impl<'input> WhileFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhileFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhileFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhileFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<WhileFsmStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn loopBodyFsmStmt(&self) -> Option<Rc<LoopBodyFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WhileFsmStmtContextAttrs<'input> for WhileFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whileFsmStmt(&mut self,)
	-> Result<Rc<WhileFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhileFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 396, RULE_whileFsmStmt);
        let mut _localctx: Rc<WhileFsmStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2818);
			recog.base.match_token(T__56,&mut recog.err_handler)?;

			recog.base.set_state(2819);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2820);
			recog.expression_rec(0)?;

			recog.base.set_state(2821);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule loopBodyFsmStmt*/
			recog.base.set_state(2822);
			recog.loopBodyFsmStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forFsmStmt ----------------
pub type ForFsmStmtContextAll<'input> = ForFsmStmtContext<'input>;


pub type ForFsmStmtContext<'input> = BaseParserRuleContext<'input,ForFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ForFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ForFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ForFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_forFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forFsmStmt }
}
antlr_rust::type_id!{ForFsmStmtContextExt<'a>}

impl<'input> ForFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ForFsmStmtContextExt<'input>>{

fn fsmStmt_all(&self) ->  Vec<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fsmStmt(&self, i: usize) -> Option<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn loopBodyFsmStmt(&self) -> Option<Rc<LoopBodyFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForFsmStmtContextAttrs<'input> for ForFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forFsmStmt(&mut self,)
	-> Result<Rc<ForFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 398, RULE_forFsmStmt);
        let mut _localctx: Rc<ForFsmStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2824);
			recog.base.match_token(T__57,&mut recog.err_handler)?;

			recog.base.set_state(2825);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule fsmStmt*/
			recog.base.set_state(2826);
			recog.fsmStmt()?;

			recog.base.set_state(2827);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2828);
			recog.expression_rec(0)?;

			recog.base.set_state(2829);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			/*InvokeRule fsmStmt*/
			recog.base.set_state(2830);
			recog.fsmStmt()?;

			recog.base.set_state(2831);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule loopBodyFsmStmt*/
			recog.base.set_state(2832);
			recog.loopBodyFsmStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnFsmStmt ----------------
pub type ReturnFsmStmtContextAll<'input> = ReturnFsmStmtContext<'input>;


pub type ReturnFsmStmtContext<'input> = BaseParserRuleContext<'input,ReturnFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for ReturnFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for ReturnFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_returnFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReturnFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnFsmStmt }
}
antlr_rust::type_id!{ReturnFsmStmtContextExt<'a>}

impl<'input> ReturnFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<ReturnFsmStmtContextExt<'input>>{


}

impl<'input> ReturnFsmStmtContextAttrs<'input> for ReturnFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnFsmStmt(&mut self,)
	-> Result<Rc<ReturnFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 400, RULE_returnFsmStmt);
        let mut _localctx: Rc<ReturnFsmStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2834);
			recog.base.match_token(T__60,&mut recog.err_handler)?;

			recog.base.set_state(2835);
			recog.base.match_token(T__1,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- repeatFsmStmt ----------------
pub type RepeatFsmStmtContextAll<'input> = RepeatFsmStmtContext<'input>;


pub type RepeatFsmStmtContext<'input> = BaseParserRuleContext<'input,RepeatFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct RepeatFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for RepeatFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for RepeatFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_repeatFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for RepeatFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_repeatFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_repeatFsmStmt }
}
antlr_rust::type_id!{RepeatFsmStmtContextExt<'a>}

impl<'input> RepeatFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RepeatFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RepeatFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RepeatFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<RepeatFsmStmtContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn loopBodyFsmStmt(&self) -> Option<Rc<LoopBodyFsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RepeatFsmStmtContextAttrs<'input> for RepeatFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn repeatFsmStmt(&mut self,)
	-> Result<Rc<RepeatFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RepeatFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 402, RULE_repeatFsmStmt);
        let mut _localctx: Rc<RepeatFsmStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2837);
			recog.base.match_token(T__137,&mut recog.err_handler)?;

			recog.base.set_state(2838);
			recog.base.match_token(T__8,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2839);
			recog.expression_rec(0)?;

			recog.base.set_state(2840);
			recog.base.match_token(T__10,&mut recog.err_handler)?;

			/*InvokeRule loopBodyFsmStmt*/
			recog.base.set_state(2841);
			recog.loopBodyFsmStmt()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- loopBodyFsmStmt ----------------
pub type LoopBodyFsmStmtContextAll<'input> = LoopBodyFsmStmtContext<'input>;


pub type LoopBodyFsmStmtContext<'input> = BaseParserRuleContext<'input,LoopBodyFsmStmtContextExt<'input>>;

#[derive(Clone)]
pub struct LoopBodyFsmStmtContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> BSVParserContext<'input> for LoopBodyFsmStmtContext<'input>{}

impl<'input,'a> Listenable<dyn BSVListener<'input> + 'a> for LoopBodyFsmStmtContext<'input>{
	fn enter(&self,listener: &mut (dyn BSVListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_loopBodyFsmStmt(self);
	}
}

impl<'input> CustomRuleContext<'input> for LoopBodyFsmStmtContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = BSVParserContextType;
	fn get_rule_index(&self) -> usize { RULE_loopBodyFsmStmt }
	//fn type_rule_index() -> usize where Self: Sized { RULE_loopBodyFsmStmt }
}
antlr_rust::type_id!{LoopBodyFsmStmtContextExt<'a>}

impl<'input> LoopBodyFsmStmtContextExt<'input>{
	fn new(parent: Option<Rc<dyn BSVParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LoopBodyFsmStmtContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LoopBodyFsmStmtContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LoopBodyFsmStmtContextAttrs<'input>: BSVParserContext<'input> + BorrowMut<LoopBodyFsmStmtContextExt<'input>>{

fn fsmStmt(&self) -> Option<Rc<FsmStmtContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LoopBodyFsmStmtContextAttrs<'input> for LoopBodyFsmStmtContext<'input>{}

impl<'input, I, H> BSVParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn loopBodyFsmStmt(&mut self,)
	-> Result<Rc<LoopBodyFsmStmtContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LoopBodyFsmStmtContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 404, RULE_loopBodyFsmStmt);
        let mut _localctx: Rc<LoopBodyFsmStmtContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2848);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__8 | T__13 | T__16 | T__17 | T__30 | T__35 | T__39 | T__49 | T__52 |
			 T__56 | T__57 | T__60 | T__61 | T__63 | T__64 | T__65 | T__66 | T__67 |
			 T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__87 | T__88 | T__90 |
			 T__91 | T__92 | T__133 | T__135 | T__137 | UPPER_IDENTIFIER | LOWER_IDENTIFIER |
			 SYSTEM_TASK | STRING_LITERAL | INT_LITERAL | REAL_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule fsmStmt*/
					recog.base.set_state(2843);
					recog.fsmStmt()?;

					}
				}

			 T__138 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2844);
					recog.base.match_token(T__138,&mut recog.err_handler)?;

					recog.base.set_state(2845);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

			 T__139 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2846);
					recog.base.match_token(T__139,&mut recog.err_handler)?;

					recog.base.set_state(2847);
					recog.base.match_token(T__1,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ).into())
        }
        Arc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{9c}\u{b25}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\x04\
	\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x04\u{af}\x09\u{af}\
	\x04\u{b0}\x09\u{b0}\x04\u{b1}\x09\u{b1}\x04\u{b2}\x09\u{b2}\x04\u{b3}\x09\
	\u{b3}\x04\u{b4}\x09\u{b4}\x04\u{b5}\x09\u{b5}\x04\u{b6}\x09\u{b6}\x04\u{b7}\
	\x09\u{b7}\x04\u{b8}\x09\u{b8}\x04\u{b9}\x09\u{b9}\x04\u{ba}\x09\u{ba}\x04\
	\u{bb}\x09\u{bb}\x04\u{bc}\x09\u{bc}\x04\u{bd}\x09\u{bd}\x04\u{be}\x09\u{be}\
	\x04\u{bf}\x09\u{bf}\x04\u{c0}\x09\u{c0}\x04\u{c1}\x09\u{c1}\x04\u{c2}\x09\
	\u{c2}\x04\u{c3}\x09\u{c3}\x04\u{c4}\x09\u{c4}\x04\u{c5}\x09\u{c5}\x04\u{c6}\
	\x09\u{c6}\x04\u{c7}\x09\u{c7}\x04\u{c8}\x09\u{c8}\x04\u{c9}\x09\u{c9}\x04\
	\u{ca}\x09\u{ca}\x04\u{cb}\x09\u{cb}\x04\u{cc}\x09\u{cc}\x03\x02\x03\x02\
	\x03\x03\x03\x03\x05\x03\u{19d}\x0a\x03\x03\x04\x03\x04\x03\x04\x03\x04\
	\x07\x04\u{1a3}\x0a\x04\x0c\x04\x0e\x04\u{1a6}\x0b\x04\x03\x05\x03\x05\x03\
	\x05\x03\x05\x03\x05\x03\x05\x07\x05\u{1ae}\x0a\x05\x0c\x05\x0e\x05\u{1b1}\
	\x0b\x05\x03\x05\x03\x05\x03\x05\x05\x05\u{1b6}\x0a\x05\x03\x06\x07\x06\
	\u{1b9}\x0a\x06\x0c\x06\x0e\x06\u{1bc}\x0b\x06\x03\x06\x07\x06\u{1bf}\x0a\
	\x06\x0c\x06\x0e\x06\u{1c2}\x0b\x06\x03\x06\x07\x06\u{1c5}\x0a\x06\x0c\x06\
	\x0e\x06\u{1c8}\x0b\x06\x05\x06\u{1ca}\x0a\x06\x03\x07\x03\x07\x03\x07\x03\
	\x07\x07\x07\u{1d0}\x0a\x07\x0c\x07\x0e\x07\u{1d3}\x0b\x07\x03\x07\x03\x07\
	\x03\x08\x03\x08\x03\x08\x03\x08\x03\x08\x03\x08\x03\x08\x03\x08\x05\x08\
	\u{1df}\x0a\x08\x05\x08\u{1e1}\x0a\x08\x03\x09\x03\x09\x03\x09\x03\x09\x07\
	\x09\u{1e7}\x0a\x09\x0c\x09\x0e\x09\u{1ea}\x0b\x09\x03\x09\x03\x09\x03\x0a\
	\x03\x0a\x03\x0a\x03\x0a\x03\x0b\x03\x0b\x03\x0b\x03\x0b\x03\x0b\x03\x0b\
	\x03\x0b\x03\x0b\x03\x0b\x03\x0b\x05\x0b\u{1fc}\x0a\x0b\x03\x0c\x03\x0c\
	\x03\x0d\x03\x0d\x03\x0e\x03\x0e\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x0f\
	\x03\x0f\x07\x0f\u{20a}\x0a\x0f\x0c\x0f\x0e\x0f\u{20d}\x0b\x0f\x03\x0f\x03\
	\x0f\x05\x0f\u{211}\x0a\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x03\
	\x0f\x03\x0f\x03\x0f\x05\x0f\u{21b}\x0a\x0f\x03\x10\x03\x10\x07\x10\u{21f}\
	\x0a\x10\x0c\x10\x0e\x10\u{222}\x0b\x10\x03\x10\x03\x10\x03\x10\x05\x10\
	\u{227}\x0a\x10\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x07\x11\u{22e}\x0a\
	\x11\x0c\x11\x0e\x11\u{231}\x0b\x11\x03\x11\x03\x11\x03\x11\x05\x11\u{236}\
	\x0a\x11\x03\x12\x03\x12\x05\x12\u{23a}\x0a\x12\x03\x13\x03\x13\x03\x13\
	\x03\x13\x03\x13\x07\x13\u{241}\x0a\x13\x0c\x13\x0e\x13\u{244}\x0b\x13\x03\
	\x13\x03\x13\x03\x14\x05\x14\u{249}\x0a\x14\x03\x14\x05\x14\u{24c}\x0a\x14\
	\x03\x14\x03\x14\x03\x15\x03\x15\x05\x15\u{252}\x0a\x15\x03\x16\x03\x16\
	\x03\x16\x03\x16\x03\x16\x03\x16\x05\x16\u{25a}\x0a\x16\x03\x16\x05\x16\
	\u{25d}\x0a\x16\x03\x16\x03\x16\x03\x17\x03\x17\x03\x17\x07\x17\u{264}\x0a\
	\x17\x0c\x17\x0e\x17\u{267}\x0b\x17\x03\x18\x03\x18\x05\x18\u{26b}\x0a\x18\
	\x03\x18\x03\x18\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x1a\
	\x03\x1a\x03\x1a\x07\x1a\u{278}\x0a\x1a\x0c\x1a\x0e\x1a\u{27b}\x0b\x1a\x03\
	\x1a\x03\x1a\x03\x1a\x05\x1a\u{280}\x0a\x1a\x03\x1b\x03\x1b\x03\x1b\x03\
	\x1b\x03\x1b\x05\x1b\u{287}\x0a\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x05\
	\x1b\u{28d}\x0a\x1b\x03\x1b\x05\x1b\u{290}\x0a\x1b\x03\x1b\x03\x1b\x03\x1b\
	\x03\x1b\x05\x1b\u{296}\x0a\x1b\x03\x1b\x03\x1b\x03\x1c\x03\x1c\x03\x1c\
	\x07\x1c\u{29d}\x0a\x1c\x0c\x1c\x0e\x1c\u{2a0}\x0b\x1c\x03\x1d\x03\x1d\x05\
	\x1d\u{2a4}\x0a\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x05\x1d\u{2aa}\x0a\x1d\
	\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x05\x1e\u{2b3}\
	\x0a\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x05\x1e\u{2ba}\x0a\x1e\
	\x07\x1e\u{2bc}\x0a\x1e\x0c\x1e\x0e\x1e\u{2bf}\x0b\x1e\x05\x1e\u{2c1}\x0a\
	\x1e\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\
	\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\
	\x1f\x05\x1f\u{2d5}\x0a\x1f\x03\x20\x05\x20\u{2d8}\x0a\x20\x03\x20\x03\x20\
	\x03\x20\x03\x20\x03\x20\x03\x20\x03\x20\x07\x20\u{2e1}\x0a\x20\x0c\x20\
	\x0e\x20\u{2e4}\x0b\x20\x03\x20\x03\x20\x05\x20\u{2e8}\x0a\x20\x03\x21\x03\
	\x21\x03\x21\x03\x21\x03\x21\x05\x21\u{2ef}\x0a\x21\x03\x21\x05\x21\u{2f2}\
	\x0a\x21\x03\x21\x05\x21\u{2f5}\x0a\x21\x03\x21\x03\x21\x03\x21\x07\x21\
	\u{2fa}\x0a\x21\x0c\x21\x0e\x21\u{2fd}\x0b\x21\x03\x21\x07\x21\u{300}\x0a\
	\x21\x0c\x21\x0e\x21\u{303}\x0b\x21\x05\x21\u{305}\x0a\x21\x03\x21\x03\x21\
	\x03\x21\x05\x21\u{30a}\x0a\x21\x03\x21\x03\x21\x03\x21\x03\x21\x03\x21\
	\x05\x21\u{311}\x0a\x21\x03\x21\x05\x21\u{314}\x0a\x21\x03\x21\x05\x21\u{317}\
	\x0a\x21\x03\x21\x03\x21\x03\x21\x03\x21\x05\x21\u{31d}\x0a\x21\x03\x22\
	\x05\x22\u{320}\x0a\x22\x03\x22\x03\x22\x03\x22\x03\x22\x03\x23\x03\x23\
	\x03\x23\x07\x23\u{329}\x0a\x23\x0c\x23\x0e\x23\u{32c}\x0b\x23\x03\x24\x05\
	\x24\u{32f}\x0a\x24\x03\x24\x03\x24\x03\x25\x03\x25\x03\x25\x03\x25\x03\
	\x25\x07\x25\u{338}\x0a\x25\x0c\x25\x0e\x25\u{33b}\x0b\x25\x03\x25\x03\x25\
	\x03\x25\x05\x25\u{340}\x0a\x25\x03\x25\x03\x25\x05\x25\u{344}\x0a\x25\x03\
	\x25\x03\x25\x03\x25\x03\x25\x03\x25\x05\x25\u{34b}\x0a\x25\x03\x26\x03\
	\x26\x03\x26\x05\x26\u{350}\x0a\x26\x03\x27\x03\x27\x03\x27\x03\x27\x03\
	\x27\x03\x27\x03\x27\x03\x27\x05\x27\u{35a}\x0a\x27\x03\x28\x03\x28\x03\
	\x28\x03\x28\x05\x28\u{360}\x0a\x28\x03\x28\x03\x28\x03\x28\x03\x28\x03\
	\x28\x05\x28\u{367}\x0a\x28\x03\x29\x05\x29\u{36a}\x0a\x29\x03\x29\x03\x29\
	\x03\x29\x03\x29\x03\x2a\x07\x2a\u{371}\x0a\x2a\x0c\x2a\x0e\x2a\u{374}\x0b\
	\x2a\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x05\x2b\u{37a}\x0a\x2b\x03\x2c\x03\
	\x2c\x03\x2c\x03\x2c\x03\x2c\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\
	\x2d\x03\x2d\x05\x2d\u{388}\x0a\x2d\x03\x2d\x03\x2d\x03\x2e\x03\x2e\x03\
	\x2e\x07\x2e\u{38f}\x0a\x2e\x0c\x2e\x0e\x2e\u{392}\x0b\x2e\x03\x2f\x03\x2f\
	\x03\x2f\x05\x2f\u{397}\x0a\x2f\x03\x2f\x03\x2f\x03\x2f\x03\x2f\x03\x2f\
	\x03\x2f\x05\x2f\u{39f}\x0a\x2f\x03\x2f\x03\x2f\x03\x2f\x03\x2f\x03\x2f\
	\x03\x2f\x03\x2f\x03\x2f\x05\x2f\u{3a9}\x0a\x2f\x05\x2f\u{3ab}\x0a\x2f\x03\
	\x30\x03\x30\x03\x30\x03\x30\x07\x30\u{3b1}\x0a\x30\x0c\x30\x0e\x30\u{3b4}\
	\x0b\x30\x03\x30\x03\x30\x03\x30\x05\x30\u{3b9}\x0a\x30\x03\x30\x03\x30\
	\x03\x31\x03\x31\x03\x31\x03\x31\x03\x31\x07\x31\u{3c2}\x0a\x31\x0c\x31\
	\x0e\x31\u{3c5}\x0b\x31\x03\x31\x03\x31\x03\x31\x05\x31\u{3ca}\x0a\x31\x03\
	\x31\x03\x31\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\
	\x32\x05\x32\u{3d6}\x0a\x32\x03\x33\x03\x33\x03\x33\x03\x33\x03\x33\x03\
	\x33\x03\x33\x03\x33\x03\x33\x03\x33\x03\x33\x03\x33\x03\x33\x03\x33\x03\
	\x33\x05\x33\u{3e7}\x0a\x33\x03\x34\x03\x34\x03\x34\x07\x34\u{3ec}\x0a\x34\
	\x0c\x34\x0e\x34\u{3ef}\x0b\x34\x03\x34\x03\x34\x03\x35\x03\x35\x03\x35\
	\x03\x35\x07\x35\u{3f7}\x0a\x35\x0c\x35\x0e\x35\u{3fa}\x0b\x35\x03\x35\x03\
	\x35\x03\x36\x03\x36\x03\x36\x05\x36\u{401}\x0a\x36\x03\x36\x03\x36\x03\
	\x36\x07\x36\u{406}\x0a\x36\x0c\x36\x0e\x36\u{409}\x0b\x36\x03\x36\x03\x36\
	\x03\x36\x05\x36\u{40e}\x0a\x36\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\
	\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\
	\x05\x37\u{41e}\x0a\x37\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x05\x38\
	\u{425}\x0a\x38\x03\x39\x03\x39\x03\x39\x03\x39\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x05\x3a\u{43e}\
	\x0a\x3a\x03\x3a\x03\x3a\x05\x3a\u{442}\x0a\x3a\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{44b}\x0a\x3c\x03\x3c\x07\x3c\
	\u{44e}\x0a\x3c\x0c\x3c\x0e\x3c\u{451}\x0b\x3c\x03\x3c\x03\x3c\x03\x3c\x05\
	\x3c\u{456}\x0a\x3c\x03\x3d\x03\x3d\x03\x3d\x05\x3d\u{45b}\x0a\x3d\x03\x3d\
	\x07\x3d\u{45e}\x0a\x3d\x0c\x3d\x0e\x3d\u{461}\x0b\x3d\x03\x3d\x03\x3d\x03\
	\x3d\x05\x3d\u{466}\x0a\x3d\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{46b}\x0a\x3e\
	\x03\x3e\x07\x3e\u{46e}\x0a\x3e\x0c\x3e\x0e\x3e\u{471}\x0b\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x05\x3e\u{476}\x0a\x3e\x03\x3f\x03\x3f\x03\x3f\x05\x3f\u{47b}\
	\x0a\x3f\x03\x3f\x07\x3f\u{47e}\x0a\x3f\x0c\x3f\x0e\x3f\u{481}\x0b\x3f\x03\
	\x3f\x03\x3f\x03\x3f\x05\x3f\u{486}\x0a\x3f\x03\x40\x03\x40\x03\x40\x05\
	\x40\u{48b}\x0a\x40\x03\x40\x07\x40\u{48e}\x0a\x40\x0c\x40\x0e\x40\u{491}\
	\x0b\x40\x03\x40\x03\x40\x03\x40\x05\x40\u{496}\x0a\x40\x03\x41\x03\x41\
	\x03\x41\x03\x41\x03\x41\x03\x41\x03\x41\x05\x41\u{49f}\x0a\x41\x03\x42\
	\x03\x42\x03\x42\x03\x42\x03\x42\x03\x42\x03\x42\x05\x42\u{4a8}\x0a\x42\
	\x03\x43\x03\x43\x03\x43\x03\x43\x03\x43\x03\x43\x03\x43\x05\x43\u{4b1}\
	\x0a\x43\x03\x44\x03\x44\x03\x44\x03\x44\x03\x44\x03\x44\x03\x44\x05\x44\
	\u{4ba}\x0a\x44\x03\x45\x03\x45\x03\x45\x03\x45\x03\x45\x03\x45\x03\x45\
	\x05\x45\u{4c3}\x0a\x45\x03\x46\x03\x46\x03\x46\x03\x46\x03\x46\x07\x46\
	\u{4ca}\x0a\x46\x0c\x46\x0e\x46\u{4cd}\x0b\x46\x03\x46\x05\x46\u{4d0}\x0a\
	\x46\x03\x46\x03\x46\x03\x46\x03\x46\x03\x46\x03\x46\x03\x46\x03\x46\x07\
	\x46\u{4da}\x0a\x46\x0c\x46\x0e\x46\u{4dd}\x0b\x46\x03\x46\x05\x46\u{4e0}\
	\x0a\x46\x03\x46\x03\x46\x05\x46\u{4e4}\x0a\x46\x03\x47\x03\x47\x03\x47\
	\x03\x47\x03\x47\x07\x47\u{4eb}\x0a\x47\x0c\x47\x0e\x47\u{4ee}\x0b\x47\x03\
	\x47\x05\x47\u{4f1}\x0a\x47\x03\x47\x03\x47\x03\x47\x03\x47\x03\x47\x03\
	\x47\x03\x47\x03\x47\x07\x47\u{4fb}\x0a\x47\x0c\x47\x0e\x47\u{4fe}\x0b\x47\
	\x03\x47\x05\x47\u{501}\x0a\x47\x03\x47\x03\x47\x05\x47\u{505}\x0a\x47\x03\
	\x48\x03\x48\x03\x48\x03\x48\x03\x48\x07\x48\u{50c}\x0a\x48\x0c\x48\x0e\
	\x48\u{50f}\x0b\x48\x03\x48\x05\x48\u{512}\x0a\x48\x03\x48\x03\x48\x03\x48\
	\x03\x48\x03\x48\x03\x48\x03\x48\x03\x48\x07\x48\u{51c}\x0a\x48\x0c\x48\
	\x0e\x48\u{51f}\x0b\x48\x03\x48\x05\x48\u{522}\x0a\x48\x03\x48\x03\x48\x05\
	\x48\u{526}\x0a\x48\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\x07\x49\u{52d}\
	\x0a\x49\x0c\x49\x0e\x49\u{530}\x0b\x49\x03\x49\x05\x49\u{533}\x0a\x49\x03\
	\x49\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\x07\x49\u{53d}\
	\x0a\x49\x0c\x49\x0e\x49\u{540}\x0b\x49\x03\x49\x05\x49\u{543}\x0a\x49\x03\
	\x49\x03\x49\x05\x49\u{547}\x0a\x49\x03\x4a\x03\x4a\x03\x4a\x07\x4a\u{54c}\
	\x0a\x4a\x0c\x4a\x0e\x4a\u{54f}\x0b\x4a\x03\x4a\x03\x4a\x03\x4a\x03\x4b\
	\x03\x4b\x03\x4b\x07\x4b\u{557}\x0a\x4b\x0c\x4b\x0e\x4b\u{55a}\x0b\x4b\x03\
	\x4b\x03\x4b\x03\x4b\x03\x4c\x03\x4c\x03\x4c\x07\x4c\u{562}\x0a\x4c\x0c\
	\x4c\x0e\x4c\u{565}\x0b\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4d\x03\x4d\x03\
	\x4d\x07\x4d\u{56d}\x0a\x4d\x0c\x4d\x0e\x4d\u{570}\x0b\x4d\x03\x4d\x03\x4d\
	\x03\x4d\x03\x4e\x03\x4e\x03\x4e\x07\x4e\u{578}\x0a\x4e\x0c\x4e\x0e\x4e\
	\u{57b}\x0b\x4e\x03\x4e\x03\x4e\x03\x4e\x03\x4f\x03\x4f\x05\x4f\u{582}\x0a\
	\x4f\x03\x4f\x03\x4f\x03\x50\x03\x50\x05\x50\u{588}\x0a\x50\x03\x50\x03\
	\x50\x03\x51\x03\x51\x05\x51\u{58e}\x0a\x51\x03\x51\x03\x51\x03\x52\x03\
	\x52\x05\x52\u{594}\x0a\x52\x03\x52\x03\x52\x03\x53\x03\x53\x05\x53\u{59a}\
	\x0a\x53\x03\x53\x03\x53\x03\x54\x03\x54\x03\x54\x03\x54\x03\x54\x03\x54\
	\x03\x55\x03\x55\x03\x55\x03\x55\x03\x55\x03\x55\x03\x56\x03\x56\x03\x56\
	\x03\x56\x03\x56\x03\x56\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\
	\x03\x58\x03\x58\x03\x58\x03\x58\x03\x58\x03\x58\x03\x59\x03\x59\x03\x59\
	\x03\x59\x03\x59\x03\x59\x03\x59\x03\x59\x03\x59\x03\x59\x03\x5a\x03\x5a\
	\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5b\
	\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\
	\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\
	\x03\x5c\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\
	\x03\x5d\x03\x5d\x03\x5e\x05\x5e\u{5ef}\x0a\x5e\x03\x5e\x03\x5e\x03\x5e\
	\x03\x5e\x03\x5f\x05\x5f\u{5f6}\x0a\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\
	\x03\x5f\x07\x5f\u{5fd}\x0a\x5f\x0c\x5f\x0e\x5f\u{600}\x0b\x5f\x03\x60\x03\
	\x60\x03\x61\x03\x61\x03\x61\x07\x61\u{607}\x0a\x61\x0c\x61\x0e\x61\u{60a}\
	\x0b\x61\x03\x62\x03\x62\x03\x62\x03\x62\x03\x63\x03\x63\x03\x63\x03\x63\
	\x03\x63\x03\x63\x05\x63\u{616}\x0a\x63\x03\x63\x03\x63\x05\x63\u{61a}\x0a\
	\x63\x03\x63\x03\x63\x05\x63\u{61e}\x0a\x63\x03\x63\x03\x63\x05\x63\u{622}\
	\x0a\x63\x03\x63\x03\x63\x05\x63\u{626}\x0a\x63\x03\x63\x03\x63\x03\x63\
	\x03\x63\x05\x63\u{62c}\x0a\x63\x03\x64\x03\x64\x05\x64\u{630}\x0a\x64\x03\
	\x64\x03\x64\x05\x64\u{634}\x0a\x64\x03\x64\x03\x64\x05\x64\u{638}\x0a\x64\
	\x03\x64\x05\x64\u{63b}\x0a\x64\x03\x64\x05\x64\u{63e}\x0a\x64\x03\x64\x03\
	\x64\x03\x65\x03\x65\x03\x65\x07\x65\u{645}\x0a\x65\x0c\x65\x0e\x65\u{648}\
	\x0b\x65\x03\x66\x05\x66\u{64b}\x0a\x66\x03\x66\x03\x66\x03\x66\x05\x66\
	\u{650}\x0a\x66\x03\x66\x05\x66\u{653}\x0a\x66\x03\x67\x03\x67\x03\x67\x07\
	\x67\u{658}\x0a\x67\x0c\x67\x0e\x67\u{65b}\x0b\x67\x05\x67\u{65d}\x0a\x67\
	\x03\x68\x03\x68\x05\x68\u{661}\x0a\x68\x03\x69\x03\x69\x03\x69\x03\x69\
	\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x06\x6a\u{66e}\
	\x0a\x6a\x0d\x6a\x0e\x6a\u{66f}\x03\x6a\x07\x6a\u{673}\x0a\x6a\x0c\x6a\x0e\
	\x6a\u{676}\x0b\x6a\x05\x6a\u{678}\x0a\x6a\x03\x6a\x05\x6a\u{67b}\x0a\x6a\
	\x03\x6a\x03\x6a\x03\x6a\x05\x6a\u{680}\x0a\x6a\x03\x6a\x03\x6a\x03\x6a\
	\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x07\x6a\u{68c}\
	\x0a\x6a\x0c\x6a\x0e\x6a\u{68f}\x0b\x6a\x07\x6a\u{691}\x0a\x6a\x0c\x6a\x0e\
	\x6a\u{694}\x0b\x6a\x03\x6b\x03\x6b\x07\x6b\u{698}\x0a\x6b\x0c\x6b\x0e\x6b\
	\u{69b}\x0b\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6c\x03\x6c\x03\x6c\
	\x07\x6c\u{6a4}\x0a\x6c\x0c\x6c\x0e\x6c\u{6a7}\x0b\x6c\x03\x6c\x03\x6c\x03\
	\x6c\x03\x6c\x03\x6d\x03\x6d\x03\x6d\x03\x6d\x03\x6d\x03\x6e\x03\x6e\x03\
	\x6e\x03\x6f\x03\x6f\x03\x70\x03\x70\x03\x71\x03\x71\x03\x71\x03\x71\x03\
	\x71\x03\x71\x03\x71\x07\x71\u{6c0}\x0a\x71\x0c\x71\x0e\x71\u{6c3}\x0b\x71\
	\x03\x72\x03\x72\x03\x72\x03\x72\x03\x72\x05\x72\u{6ca}\x0a\x72\x03\x73\
	\x03\x73\x05\x73\u{6ce}\x0a\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\
	\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x07\x73\u{6dc}\
	\x0a\x73\x0c\x73\x0e\x73\u{6df}\x0b\x73\x03\x74\x03\x74\x03\x74\x03\x74\
	\x03\x74\x03\x74\x03\x74\x03\x74\x03\x74\x05\x74\u{6ea}\x0a\x74\x03\x75\
	\x03\x75\x03\x75\x03\x75\x07\x75\u{6f0}\x0a\x75\x0c\x75\x0e\x75\u{6f3}\x0b\
	\x75\x03\x75\x03\x75\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\
	\x76\x03\x76\x03\x76\x03\x76\x05\x76\u{701}\x0a\x76\x03\x76\x03\x76\x03\
	\x76\x03\x76\x03\x76\x07\x76\u{708}\x0a\x76\x0c\x76\x0e\x76\u{70b}\x0b\x76\
	\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x07\x76\
	\u{715}\x0a\x76\x0c\x76\x0e\x76\u{718}\x0b\x76\x05\x76\u{71a}\x0a\x76\x03\
	\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x07\x76\u{722}\x0a\x76\x0c\
	\x76\x0e\x76\u{725}\x0b\x76\x05\x76\u{727}\x0a\x76\x03\x76\x05\x76\u{72a}\
	\x0a\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\
	\x03\x76\x03\x76\x07\x76\u{736}\x0a\x76\x0c\x76\x0e\x76\u{739}\x0b\x76\x03\
	\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x05\x76\u{741}\x0a\x76\x03\
	\x76\x05\x76\u{744}\x0a\x76\x03\x76\x03\x76\x07\x76\u{748}\x0a\x76\x0c\x76\
	\x0e\x76\u{74b}\x0b\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\
	\x03\x76\x05\x76\u{754}\x0a\x76\x03\x76\x03\x76\x03\x76\x05\x76\u{759}\x0a\
	\x76\x03\x76\x07\x76\u{75c}\x0a\x76\x0c\x76\x0e\x76\u{75f}\x0b\x76\x03\x76\
	\x03\x76\x03\x76\x05\x76\u{764}\x0a\x76\x03\x76\x05\x76\u{767}\x0a\x76\x03\
	\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x05\x76\u{771}\
	\x0a\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x07\x76\
	\u{77a}\x0a\x76\x0c\x76\x0e\x76\u{77d}\x0b\x76\x05\x76\u{77f}\x0a\x76\x03\
	\x76\x07\x76\u{782}\x0a\x76\x0c\x76\x0e\x76\u{785}\x0b\x76\x03\x77\x03\x77\
	\x03\x77\x07\x77\u{78a}\x0a\x77\x0c\x77\x0e\x77\u{78d}\x0b\x77\x03\x78\x03\
	\x78\x03\x78\x03\x78\x03\x79\x03\x79\x03\x79\x03\x79\x05\x79\u{797}\x0a\
	\x79\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x05\x7a\u{79e}\x0a\x7a\x03\
	\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x05\x7a\u{7a6}\x0a\x7a\x07\
	\x7a\u{7a8}\x0a\x7a\x0c\x7a\x0e\x7a\u{7ab}\x0b\x7a\x03\x7b\x03\x7b\x03\x7b\
	\x03\x7b\x03\x7b\x05\x7b\u{7b2}\x0a\x7b\x03\x7c\x03\x7c\x03\x7c\x05\x7c\
	\u{7b7}\x0a\x7c\x03\x7c\x07\x7c\u{7ba}\x0a\x7c\x0c\x7c\x0e\x7c\u{7bd}\x0b\
	\x7c\x03\x7c\x03\x7c\x03\x7c\x03\x7c\x05\x7c\u{7c3}\x0a\x7c\x03\x7d\x03\
	\x7d\x07\x7d\u{7c7}\x0a\x7d\x0c\x7d\x0e\x7d\u{7ca}\x0b\x7d\x03\x7d\x03\x7d\
	\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\
	\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x05\x7e\u{7de}\
	\x0a\x7e\x03\x7f\x03\x7f\x07\x7f\u{7e2}\x0a\x7f\x0c\x7f\x0e\x7f\u{7e5}\x0b\
	\x7f\x03\x7f\x03\x7f\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x05\
	\u{80}\u{7ee}\x0a\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\
	\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x05\u{80}\u{7fb}\
	\x0a\u{80}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\
	\u{81}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x05\u{83}\u{814}\x0a\u{83}\x03\u{84}\x03\u{84}\x03\u{84}\
	\x03\u{84}\x03\u{84}\x07\u{84}\u{81b}\x0a\u{84}\x0c\u{84}\x0e\u{84}\u{81e}\
	\x0b\u{84}\x05\u{84}\u{820}\x0a\u{84}\x03\u{84}\x03\u{84}\x03\u{85}\x03\
	\u{85}\x03\u{85}\x03\u{85}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\
	\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x05\
	\u{86}\u{834}\x0a\u{86}\x03\u{87}\x03\u{87}\x03\u{87}\x05\u{87}\u{839}\x0a\
	\u{87}\x03\u{87}\x07\u{87}\u{83c}\x0a\u{87}\x0c\u{87}\x0e\u{87}\u{83f}\x0b\
	\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\x05\u{87}\u{844}\x0a\u{87}\x03\u{88}\
	\x03\u{88}\x03\u{88}\x03\u{88}\x05\u{88}\u{84a}\x0a\u{88}\x03\u{88}\x07\
	\u{88}\u{84d}\x0a\u{88}\x0c\u{88}\x0e\u{88}\u{850}\x0b\u{88}\x03\u{88}\x03\
	\u{88}\x03\u{88}\x05\u{88}\u{855}\x0a\u{88}\x03\u{89}\x03\u{89}\x05\u{89}\
	\u{859}\x0a\u{89}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\
	\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x05\u{8a}\u{866}\
	\x0a\u{8a}\x03\u{8b}\x03\u{8b}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x05\u{8c}\u{86d}\
	\x0a\u{8c}\x03\u{8d}\x03\u{8d}\x03\u{8d}\x03\u{8d}\x03\u{8d}\x03\u{8d}\x03\
	\u{8d}\x03\u{8d}\x03\u{8d}\x03\u{8d}\x03\u{8d}\x07\u{8d}\u{87a}\x0a\u{8d}\
	\x0c\u{8d}\x0e\u{8d}\u{87d}\x0b\u{8d}\x03\u{8d}\x03\u{8d}\x03\u{8e}\x03\
	\u{8e}\x03\u{8e}\x03\u{8e}\x07\u{8e}\u{885}\x0a\u{8e}\x0c\u{8e}\x0e\u{8e}\
	\u{888}\x0b\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8f}\x03\u{8f}\x03\u{8f}\x05\
	\u{8f}\u{88f}\x0a\u{8f}\x03\u{8f}\x03\u{8f}\x03\u{8f}\x03\u{90}\x03\u{90}\
	\x03\u{90}\x05\u{90}\u{897}\x0a\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\
	\u{91}\x03\u{91}\x03\u{91}\x05\u{91}\u{89f}\x0a\u{91}\x03\u{91}\x03\u{91}\
	\x03\u{91}\x03\u{92}\x03\u{92}\x03\u{92}\x05\u{92}\u{8a7}\x0a\u{92}\x03\
	\u{92}\x03\u{92}\x03\u{92}\x03\u{93}\x03\u{93}\x03\u{93}\x05\u{93}\u{8af}\
	\x0a\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{94}\x03\u{94}\x03\u{94}\x03\
	\u{94}\x03\u{94}\x03\u{94}\x07\u{94}\u{8ba}\x0a\u{94}\x0c\u{94}\x0e\u{94}\
	\u{8bd}\x0b\u{94}\x03\u{94}\x03\u{94}\x03\u{95}\x03\u{95}\x03\u{95}\x05\
	\u{95}\u{8c4}\x0a\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\
	\x05\u{95}\u{8cb}\x0a\u{95}\x03\u{95}\x05\u{95}\u{8ce}\x0a\u{95}\x03\u{96}\
	\x03\u{96}\x03\u{96}\x03\u{96}\x07\u{96}\u{8d4}\x0a\u{96}\x0c\u{96}\x0e\
	\u{96}\u{8d7}\x0b\u{96}\x03\u{96}\x03\u{96}\x03\u{97}\x07\u{97}\u{8dc}\x0a\
	\u{97}\x0c\u{97}\x0e\u{97}\u{8df}\x0b\u{97}\x03\u{98}\x03\u{98}\x03\u{98}\
	\x05\u{98}\u{8e4}\x0a\u{98}\x03\u{99}\x03\u{99}\x05\u{99}\u{8e8}\x0a\u{99}\
	\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x07\u{9a}\u{8ef}\x0a\
	\u{9a}\x0c\u{9a}\x0e\u{9a}\u{8f2}\x0b\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9b}\
	\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x07\u{9b}\u{8fc}\x0a\
	\u{9b}\x0c\u{9b}\x0e\u{9b}\u{8ff}\x0b\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9c}\
	\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\u{907}\x0a\u{9c}\x03\u{9c}\x05\
	\u{9c}\u{90a}\x0a\u{9c}\x03\u{9c}\x03\u{9c}\x07\u{9c}\u{90e}\x0a\u{9c}\x0c\
	\u{9c}\x0e\u{9c}\u{911}\x0b\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\
	\u{916}\x0a\u{9c}\x03\u{9d}\x03\u{9d}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\
	\u{9e}\x03\u{9e}\x07\u{9e}\u{91f}\x0a\u{9e}\x0c\u{9e}\x0e\u{9e}\u{922}\x0b\
	\u{9e}\x03\u{9e}\x03\u{9e}\x05\u{9e}\u{926}\x0a\u{9e}\x03\u{9f}\x03\u{9f}\
	\x03\u{9f}\x03\u{9f}\x03\u{9f}\x07\u{9f}\u{92d}\x0a\u{9f}\x0c\u{9f}\x0e\
	\u{9f}\u{930}\x0b\u{9f}\x03\u{9f}\x03\u{9f}\x03\u{a0}\x03\u{a0}\x03\u{a0}\
	\x03\u{a0}\x03\u{a1}\x03\u{a1}\x03\u{a1}\x03\u{a1}\x03\u{a1}\x05\u{a1}\u{93d}\
	\x0a\u{a1}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x03\
	\u{a2}\x07\u{a2}\u{946}\x0a\u{a2}\x0c\u{a2}\x0e\u{a2}\u{949}\x0b\u{a2}\x03\
	\u{a2}\x03\u{a2}\x05\u{a2}\u{94d}\x0a\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\
	\x03\u{a2}\x07\u{a2}\u{953}\x0a\u{a2}\x0c\u{a2}\x0e\u{a2}\u{956}\x0b\u{a2}\
	\x03\u{a2}\x03\u{a2}\x03\u{a2}\x05\u{a2}\u{95b}\x0a\u{a2}\x03\u{a3}\x03\
	\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x07\u{a3}\u{962}\x0a\u{a3}\x0c\u{a3}\
	\x0e\u{a3}\u{965}\x0b\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a4}\x03\u{a4}\x03\
	\u{a4}\x03\u{a4}\x03\u{a4}\x05\u{a4}\u{96e}\x0a\u{a4}\x03\u{a4}\x03\u{a4}\
	\x07\u{a4}\u{972}\x0a\u{a4}\x0c\u{a4}\x0e\u{a4}\u{975}\x0b\u{a4}\x03\u{a4}\
	\x07\u{a4}\u{978}\x0a\u{a4}\x0c\u{a4}\x0e\u{a4}\u{97b}\x0b\u{a4}\x03\u{a4}\
	\x03\u{a4}\x03\u{a4}\x05\u{a4}\u{980}\x0a\u{a4}\x03\u{a5}\x03\u{a5}\x03\
	\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\
	\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x05\u{a5}\u{992}\
	\x0a\u{a5}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a7}\x03\
	\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a8}\x03\u{a8}\x03\u{a8}\x03\u{a8}\
	\x03\u{a8}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{aa}\x03\
	\u{aa}\x03\u{aa}\x03\u{aa}\x03\u{aa}\x03\u{aa}\x03\u{ab}\x03\u{ab}\x05\u{ab}\
	\u{9b0}\x0a\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x07\
	\u{ab}\u{9b7}\x0a\u{ab}\x0c\u{ab}\x0e\u{ab}\u{9ba}\x0b\u{ab}\x05\u{ab}\u{9bc}\
	\x0a\u{ab}\x03\u{ab}\x05\u{ab}\u{9bf}\x0a\u{ab}\x03\u{ab}\x03\u{ab}\x03\
	\u{ab}\x03\u{ab}\x07\u{ab}\u{9c5}\x0a\u{ab}\x0c\u{ab}\x0e\u{ab}\u{9c8}\x0b\
	\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x07\u{ac}\
	\u{9d0}\x0a\u{ac}\x0c\u{ac}\x0e\u{ac}\u{9d3}\x0b\u{ac}\x03\u{ac}\x03\u{ac}\
	\x03\u{ac}\x03\u{ac}\x03\u{ad}\x03\u{ad}\x05\u{ad}\u{9db}\x0a\u{ad}\x03\
	\u{ad}\x03\u{ad}\x05\u{ad}\u{9df}\x0a\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\
	\x03\u{ad}\x03\u{ad}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x05\
	\u{ae}\u{9eb}\x0a\u{ae}\x03\u{af}\x05\u{af}\u{9ee}\x0a\u{af}\x03\u{af}\x03\
	\u{af}\x03\u{b0}\x03\u{b0}\x05\u{b0}\u{9f4}\x0a\u{b0}\x03\u{b0}\x03\u{b0}\
	\x05\u{b0}\u{9f8}\x0a\u{b0}\x03\u{b0}\x05\u{b0}\u{9fb}\x0a\u{b0}\x03\u{b0}\
	\x03\u{b0}\x05\u{b0}\u{9ff}\x0a\u{b0}\x03\u{b0}\x03\u{b0}\x03\u{b1}\x03\
	\u{b1}\x03\u{b1}\x03\u{b1}\x05\u{b1}\u{a07}\x0a\u{b1}\x03\u{b1}\x03\u{b1}\
	\x03\u{b1}\x03\u{b2}\x03\u{b2}\x05\u{b2}\u{a0e}\x0a\u{b2}\x03\u{b2}\x03\
	\u{b2}\x05\u{b2}\u{a12}\x0a\u{b2}\x03\u{b2}\x05\u{b2}\u{a15}\x0a\u{b2}\x03\
	\u{b2}\x05\u{b2}\u{a18}\x0a\u{b2}\x03\u{b2}\x03\u{b2}\x03\u{b2}\x03\u{b2}\
	\x03\u{b3}\x03\u{b3}\x03\u{b4}\x03\u{b4}\x03\u{b4}\x03\u{b4}\x03\u{b4}\x03\
	\u{b4}\x05\u{b4}\u{a26}\x0a\u{b4}\x03\u{b4}\x03\u{b4}\x05\u{b4}\u{a2a}\x0a\
	\u{b4}\x03\u{b4}\x05\u{b4}\u{a2d}\x0a\u{b4}\x03\u{b4}\x05\u{b4}\u{a30}\x0a\
	\u{b4}\x03\u{b4}\x03\u{b4}\x05\u{b4}\u{a34}\x0a\u{b4}\x03\u{b4}\x05\u{b4}\
	\u{a37}\x0a\u{b4}\x03\u{b5}\x03\u{b5}\x03\u{b5}\x03\u{b5}\x05\u{b5}\u{a3d}\
	\x0a\u{b5}\x03\u{b5}\x05\u{b5}\u{a40}\x0a\u{b5}\x03\u{b5}\x05\u{b5}\u{a43}\
	\x0a\u{b5}\x03\u{b5}\x03\u{b5}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\
	\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b7}\x03\u{b7}\x03\u{b7}\x03\u{b7}\
	\x03\u{b7}\x03\u{b7}\x03\u{b7}\x03\u{b7}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\
	\u{b8}\x03\u{b8}\x07\u{b8}\u{a5c}\x0a\u{b8}\x0c\u{b8}\x0e\u{b8}\u{a5f}\x0b\
	\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x05\u{b8}\u{a64}\x0a\u{b8}\x03\u{b8}\
	\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x07\u{b8}\u{a6b}\x0a\u{b8}\x0c\
	\u{b8}\x0e\u{b8}\u{a6e}\x0b\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x05\u{b8}\
	\u{a73}\x0a\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b9}\x03\u{b9}\x03\u{ba}\x03\
	\u{ba}\x03\u{ba}\x03\u{ba}\x03\u{ba}\x03\u{ba}\x03\u{ba}\x03\u{ba}\x03\u{bb}\
	\x03\u{bb}\x03\u{bb}\x05\u{bb}\u{a84}\x0a\u{bb}\x03\u{bb}\x03\u{bb}\x07\
	\u{bb}\u{a88}\x0a\u{bb}\x0c\u{bb}\x0e\u{bb}\u{a8b}\x0b\u{bb}\x03\u{bb}\x03\
	\u{bb}\x03\u{bb}\x05\u{bb}\u{a90}\x0a\u{bb}\x03\u{bc}\x03\u{bc}\x05\u{bc}\
	\u{a94}\x0a\u{bc}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x07\u{bd}\u{a9a}\
	\x0a\u{bd}\x0c\u{bd}\x0e\u{bd}\u{a9d}\x0b\u{bd}\x03\u{bd}\x03\u{bd}\x03\
	\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{bd}\
	\x03\u{bd}\x07\u{bd}\u{aaa}\x0a\u{bd}\x0c\u{bd}\x0e\u{bd}\u{aad}\x0b\u{bd}\
	\x03\u{bd}\x03\u{bd}\x05\u{bd}\u{ab1}\x0a\u{bd}\x03\u{be}\x03\u{be}\x03\
	\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{c0}\
	\x05\u{c0}\u{abd}\x0a\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\
	\u{c0}\x05\u{c0}\u{ac4}\x0a\u{c0}\x03\u{c0}\x03\u{c0}\x05\u{c0}\u{ac8}\x0a\
	\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x07\u{c1}\u{acf}\
	\x0a\u{c1}\x0c\u{c1}\x0e\u{c1}\u{ad2}\x0b\u{c1}\x03\u{c2}\x03\u{c2}\x05\
	\u{c2}\u{ad6}\x0a\u{c2}\x03\u{c3}\x03\u{c3}\x03\u{c3}\x03\u{c3}\x03\u{c3}\
	\x03\u{c3}\x03\u{c3}\x03\u{c3}\x05\u{c3}\u{ae0}\x0a\u{c3}\x03\u{c4}\x03\
	\u{c4}\x03\u{c4}\x03\u{c4}\x03\u{c4}\x03\u{c4}\x05\u{c4}\u{ae8}\x0a\u{c4}\
	\x03\u{c5}\x03\u{c5}\x03\u{c5}\x07\u{c5}\u{aed}\x0a\u{c5}\x0c\u{c5}\x0e\
	\u{c5}\u{af0}\x0b\u{c5}\x03\u{c5}\x03\u{c5}\x03\u{c6}\x03\u{c6}\x03\u{c6}\
	\x07\u{c6}\u{af7}\x0a\u{c6}\x0c\u{c6}\x0e\u{c6}\u{afa}\x0b\u{c6}\x03\u{c6}\
	\x03\u{c6}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x05\u{c7}\u{b03}\
	\x0a\u{c7}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\
	\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\
	\x03\u{c9}\x03\u{c9}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{cb}\x03\u{cb}\x03\
	\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cc}\x03\u{cc}\x03\u{cc}\x03\u{cc}\
	\x03\u{cc}\x05\u{cc}\u{b23}\x0a\u{cc}\x03\u{cc}\x02\x06\u{d2}\u{e0}\u{e4}\
	\u{ea}\u{cd}\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\
	\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\
	\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\
	\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\
	\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\
	\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\
	\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\
	\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\
	\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\u{f8}\u{fa}\u{fc}\u{fe}\
	\u{100}\u{102}\u{104}\u{106}\u{108}\u{10a}\u{10c}\u{10e}\u{110}\u{112}\u{114}\
	\u{116}\u{118}\u{11a}\u{11c}\u{11e}\u{120}\u{122}\u{124}\u{126}\u{128}\u{12a}\
	\u{12c}\u{12e}\u{130}\u{132}\u{134}\u{136}\u{138}\u{13a}\u{13c}\u{13e}\u{140}\
	\u{142}\u{144}\u{146}\u{148}\u{14a}\u{14c}\u{14e}\u{150}\u{152}\u{154}\u{156}\
	\u{158}\u{15a}\u{15c}\u{15e}\u{160}\u{162}\u{164}\u{166}\u{168}\u{16a}\u{16c}\
	\u{16e}\u{170}\u{172}\u{174}\u{176}\u{178}\u{17a}\u{17c}\u{17e}\u{180}\u{182}\
	\u{184}\u{186}\u{188}\u{18a}\u{18c}\u{18e}\u{190}\u{192}\u{194}\u{196}\x02\
	\x09\x03\x02\x42\x4c\x08\x02\x0a\x0a\x33\x33\x41\x43\x46\x46\x48\x48\x4a\
	\x59\x03\x02\x44\x4c\x03\x02\x42\x43\x03\x02\x5a\x5b\x05\x02\u{93}\u{93}\
	\u{97}\u{98}\u{9a}\u{9a}\x03\x02\x7f\u{82}\x02\u{c14}\x02\u{198}\x03\x02\
	\x02\x02\x04\u{19c}\x03\x02\x02\x02\x06\u{1a4}\x03\x02\x02\x02\x08\u{1a7}\
	\x03\x02\x02\x02\x0a\u{1c9}\x03\x02\x02\x02\x0c\u{1cb}\x03\x02\x02\x02\x0e\
	\u{1e0}\x03\x02\x02\x02\x10\u{1e2}\x03\x02\x02\x02\x12\u{1ed}\x03\x02\x02\
	\x02\x14\u{1fb}\x03\x02\x02\x02\x16\u{1fd}\x03\x02\x02\x02\x18\u{1ff}\x03\
	\x02\x02\x02\x1a\u{201}\x03\x02\x02\x02\x1c\u{21a}\x03\x02\x02\x02\x1e\u{226}\
	\x03\x02\x02\x02\x20\u{228}\x03\x02\x02\x02\x22\u{237}\x03\x02\x02\x02\x24\
	\u{23b}\x03\x02\x02\x02\x26\u{248}\x03\x02\x02\x02\x28\u{251}\x03\x02\x02\
	\x02\x2a\u{253}\x03\x02\x02\x02\x2c\u{260}\x03\x02\x02\x02\x2e\u{268}\x03\
	\x02\x02\x02\x30\u{26e}\x03\x02\x02\x02\x32\u{274}\x03\x02\x02\x02\x34\u{281}\
	\x03\x02\x02\x02\x36\u{299}\x03\x02\x02\x02\x38\u{2a9}\x03\x02\x02\x02\x3a\
	\u{2c0}\x03\x02\x02\x02\x3c\u{2d4}\x03\x02\x02\x02\x3e\u{2e7}\x03\x02\x02\
	\x02\x40\u{31c}\x03\x02\x02\x02\x42\u{31f}\x03\x02\x02\x02\x44\u{325}\x03\
	\x02\x02\x02\x46\u{32e}\x03\x02\x02\x02\x48\u{34a}\x03\x02\x02\x02\x4a\u{34f}\
	\x03\x02\x02\x02\x4c\u{359}\x03\x02\x02\x02\x4e\u{35b}\x03\x02\x02\x02\x50\
	\u{369}\x03\x02\x02\x02\x52\u{372}\x03\x02\x02\x02\x54\u{379}\x03\x02\x02\
	\x02\x56\u{37b}\x03\x02\x02\x02\x58\u{380}\x03\x02\x02\x02\x5a\u{38b}\x03\
	\x02\x02\x02\x5c\u{3aa}\x03\x02\x02\x02\x5e\u{3ac}\x03\x02\x02\x02\x60\u{3bc}\
	\x03\x02\x02\x02\x62\u{3d5}\x03\x02\x02\x02\x64\u{3e6}\x03\x02\x02\x02\x66\
	\u{3e8}\x03\x02\x02\x02\x68\u{3f2}\x03\x02\x02\x02\x6a\u{40d}\x03\x02\x02\
	\x02\x6c\u{41d}\x03\x02\x02\x02\x6e\u{424}\x03\x02\x02\x02\x70\u{426}\x03\
	\x02\x02\x02\x72\u{441}\x03\x02\x02\x02\x74\u{443}\x03\x02\x02\x02\x76\u{447}\
	\x03\x02\x02\x02\x78\u{457}\x03\x02\x02\x02\x7a\u{467}\x03\x02\x02\x02\x7c\
	\u{477}\x03\x02\x02\x02\x7e\u{487}\x03\x02\x02\x02\u{80}\u{497}\x03\x02\
	\x02\x02\u{82}\u{4a0}\x03\x02\x02\x02\u{84}\u{4a9}\x03\x02\x02\x02\u{86}\
	\u{4b2}\x03\x02\x02\x02\u{88}\u{4bb}\x03\x02\x02\x02\u{8a}\u{4e3}\x03\x02\
	\x02\x02\u{8c}\u{504}\x03\x02\x02\x02\u{8e}\u{525}\x03\x02\x02\x02\u{90}\
	\u{546}\x03\x02\x02\x02\u{92}\u{548}\x03\x02\x02\x02\u{94}\u{553}\x03\x02\
	\x02\x02\u{96}\u{55e}\x03\x02\x02\x02\u{98}\u{569}\x03\x02\x02\x02\u{9a}\
	\u{574}\x03\x02\x02\x02\u{9c}\u{57f}\x03\x02\x02\x02\u{9e}\u{585}\x03\x02\
	\x02\x02\u{a0}\u{58b}\x03\x02\x02\x02\u{a2}\u{591}\x03\x02\x02\x02\u{a4}\
	\u{597}\x03\x02\x02\x02\u{a6}\u{59d}\x03\x02\x02\x02\u{a8}\u{5a3}\x03\x02\
	\x02\x02\u{aa}\u{5a9}\x03\x02\x02\x02\u{ac}\u{5af}\x03\x02\x02\x02\u{ae}\
	\u{5b5}\x03\x02\x02\x02\u{b0}\u{5bb}\x03\x02\x02\x02\u{b2}\u{5c5}\x03\x02\
	\x02\x02\u{b4}\u{5cf}\x03\x02\x02\x02\u{b6}\u{5d9}\x03\x02\x02\x02\u{b8}\
	\u{5e3}\x03\x02\x02\x02\u{ba}\u{5ee}\x03\x02\x02\x02\u{bc}\u{5f5}\x03\x02\
	\x02\x02\u{be}\u{601}\x03\x02\x02\x02\u{c0}\u{603}\x03\x02\x02\x02\u{c2}\
	\u{60b}\x03\x02\x02\x02\u{c4}\u{62b}\x03\x02\x02\x02\u{c6}\u{62d}\x03\x02\
	\x02\x02\u{c8}\u{641}\x03\x02\x02\x02\u{ca}\u{64a}\x03\x02\x02\x02\u{cc}\
	\u{65c}\x03\x02\x02\x02\u{ce}\u{660}\x03\x02\x02\x02\u{d0}\u{662}\x03\x02\
	\x02\x02\u{d2}\u{67f}\x03\x02\x02\x02\u{d4}\u{695}\x03\x02\x02\x02\u{d6}\
	\u{6a0}\x03\x02\x02\x02\u{d8}\u{6ac}\x03\x02\x02\x02\u{da}\u{6b1}\x03\x02\
	\x02\x02\u{dc}\u{6b4}\x03\x02\x02\x02\u{de}\u{6b6}\x03\x02\x02\x02\u{e0}\
	\u{6b8}\x03\x02\x02\x02\u{e2}\u{6c9}\x03\x02\x02\x02\u{e4}\u{6cb}\x03\x02\
	\x02\x02\u{e6}\u{6e9}\x03\x02\x02\x02\u{e8}\u{6eb}\x03\x02\x02\x02\u{ea}\
	\u{766}\x03\x02\x02\x02\u{ec}\u{786}\x03\x02\x02\x02\u{ee}\u{78e}\x03\x02\
	\x02\x02\u{f0}\u{796}\x03\x02\x02\x02\u{f2}\u{79d}\x03\x02\x02\x02\u{f4}\
	\u{7b1}\x03\x02\x02\x02\u{f6}\u{7b3}\x03\x02\x02\x02\u{f8}\u{7c4}\x03\x02\
	\x02\x02\u{fa}\u{7dd}\x03\x02\x02\x02\u{fc}\u{7df}\x03\x02\x02\x02\u{fe}\
	\u{7fa}\x03\x02\x02\x02\u{100}\u{7fc}\x03\x02\x02\x02\u{102}\u{803}\x03\
	\x02\x02\x02\u{104}\u{813}\x03\x02\x02\x02\u{106}\u{815}\x03\x02\x02\x02\
	\u{108}\u{823}\x03\x02\x02\x02\u{10a}\u{833}\x03\x02\x02\x02\u{10c}\u{835}\
	\x03\x02\x02\x02\u{10e}\u{845}\x03\x02\x02\x02\u{110}\u{858}\x03\x02\x02\
	\x02\u{112}\u{865}\x03\x02\x02\x02\u{114}\u{867}\x03\x02\x02\x02\u{116}\
	\u{869}\x03\x02\x02\x02\u{118}\u{86e}\x03\x02\x02\x02\u{11a}\u{880}\x03\
	\x02\x02\x02\u{11c}\u{88b}\x03\x02\x02\x02\u{11e}\u{893}\x03\x02\x02\x02\
	\u{120}\u{89b}\x03\x02\x02\x02\u{122}\u{8a3}\x03\x02\x02\x02\u{124}\u{8ab}\
	\x03\x02\x02\x02\u{126}\u{8b3}\x03\x02\x02\x02\u{128}\u{8cd}\x03\x02\x02\
	\x02\u{12a}\u{8cf}\x03\x02\x02\x02\u{12c}\u{8dd}\x03\x02\x02\x02\u{12e}\
	\u{8e0}\x03\x02\x02\x02\u{130}\u{8e7}\x03\x02\x02\x02\u{132}\u{8e9}\x03\
	\x02\x02\x02\u{134}\u{8f5}\x03\x02\x02\x02\u{136}\u{902}\x03\x02\x02\x02\
	\u{138}\u{917}\x03\x02\x02\x02\u{13a}\u{925}\x03\x02\x02\x02\u{13c}\u{927}\
	\x03\x02\x02\x02\u{13e}\u{933}\x03\x02\x02\x02\u{140}\u{93c}\x03\x02\x02\
	\x02\u{142}\u{93e}\x03\x02\x02\x02\u{144}\u{95c}\x03\x02\x02\x02\u{146}\
	\u{968}\x03\x02\x02\x02\u{148}\u{991}\x03\x02\x02\x02\u{14a}\u{993}\x03\
	\x02\x02\x02\u{14c}\u{998}\x03\x02\x02\x02\u{14e}\u{99d}\x03\x02\x02\x02\
	\u{150}\u{9a2}\x03\x02\x02\x02\u{152}\u{9a7}\x03\x02\x02\x02\u{154}\u{9ad}\
	\x03\x02\x02\x02\u{156}\u{9cb}\x03\x02\x02\x02\u{158}\u{9d8}\x03\x02\x02\
	\x02\u{15a}\u{9e5}\x03\x02\x02\x02\u{15c}\u{9ed}\x03\x02\x02\x02\u{15e}\
	\u{9f1}\x03\x02\x02\x02\u{160}\u{a02}\x03\x02\x02\x02\u{162}\u{a0b}\x03\
	\x02\x02\x02\u{164}\u{a1d}\x03\x02\x02\x02\u{166}\u{a36}\x03\x02\x02\x02\
	\u{168}\u{a38}\x03\x02\x02\x02\u{16a}\u{a46}\x03\x02\x02\x02\u{16c}\u{a4e}\
	\x03\x02\x02\x02\u{16e}\u{a56}\x03\x02\x02\x02\u{170}\u{a76}\x03\x02\x02\
	\x02\u{172}\u{a78}\x03\x02\x02\x02\u{174}\u{a80}\x03\x02\x02\x02\u{176}\
	\u{a93}\x03\x02\x02\x02\u{178}\u{ab0}\x03\x02\x02\x02\u{17a}\u{ab2}\x03\
	\x02\x02\x02\u{17c}\u{ab4}\x03\x02\x02\x02\u{17e}\u{ab7}\x03\x02\x02\x02\
	\u{180}\u{acb}\x03\x02\x02\x02\u{182}\u{ad3}\x03\x02\x02\x02\u{184}\u{adf}\
	\x03\x02\x02\x02\u{186}\u{ae7}\x03\x02\x02\x02\u{188}\u{ae9}\x03\x02\x02\
	\x02\u{18a}\u{af3}\x03\x02\x02\x02\u{18c}\u{afd}\x03\x02\x02\x02\u{18e}\
	\u{b04}\x03\x02\x02\x02\u{190}\u{b0a}\x03\x02\x02\x02\u{192}\u{b14}\x03\
	\x02\x02\x02\u{194}\u{b17}\x03\x02\x02\x02\u{196}\u{b22}\x03\x02\x02\x02\
	\u{198}\u{199}\x07\u{94}\x02\x02\u{199}\x03\x03\x02\x02\x02\u{19a}\u{19d}\
	\x05\x02\x02\x02\u{19b}\u{19d}\x07\u{93}\x02\x02\u{19c}\u{19a}\x03\x02\x02\
	\x02\u{19c}\u{19b}\x03\x02\x02\x02\u{19d}\x05\x03\x02\x02\x02\u{19e}\u{1a3}\
	\x05\x0c\x07\x02\u{19f}\u{1a3}\x05\x10\x09\x02\u{1a0}\u{1a3}\x05\x14\x0b\
	\x02\u{1a1}\u{1a3}\x05\x08\x05\x02\u{1a2}\u{19e}\x03\x02\x02\x02\u{1a2}\
	\u{19f}\x03\x02\x02\x02\u{1a2}\u{1a0}\x03\x02\x02\x02\u{1a2}\u{1a1}\x03\
	\x02\x02\x02\u{1a3}\u{1a6}\x03\x02\x02\x02\u{1a4}\u{1a2}\x03\x02\x02\x02\
	\u{1a4}\u{1a5}\x03\x02\x02\x02\u{1a5}\x07\x03\x02\x02\x02\u{1a6}\u{1a4}\
	\x03\x02\x02\x02\u{1a7}\u{1a8}\x07\x03\x02\x02\u{1a8}\u{1a9}\x05\x16\x0c\
	\x02\u{1a9}\u{1af}\x07\x04\x02\x02\u{1aa}\u{1ae}\x05\x0c\x07\x02\u{1ab}\
	\u{1ae}\x05\x10\x09\x02\u{1ac}\u{1ae}\x05\x14\x0b\x02\u{1ad}\u{1aa}\x03\
	\x02\x02\x02\u{1ad}\u{1ab}\x03\x02\x02\x02\u{1ad}\u{1ac}\x03\x02\x02\x02\
	\u{1ae}\u{1b1}\x03\x02\x02\x02\u{1af}\u{1ad}\x03\x02\x02\x02\u{1af}\u{1b0}\
	\x03\x02\x02\x02\u{1b0}\u{1b2}\x03\x02\x02\x02\u{1b1}\u{1af}\x03\x02\x02\
	\x02\u{1b2}\u{1b5}\x07\x05\x02\x02\u{1b3}\u{1b4}\x07\x06\x02\x02\u{1b4}\
	\u{1b6}\x05\x16\x0c\x02\u{1b5}\u{1b3}\x03\x02\x02\x02\u{1b5}\u{1b6}\x03\
	\x02\x02\x02\u{1b6}\x09\x03\x02\x02\x02\u{1b7}\u{1b9}\x05\x0c\x07\x02\u{1b8}\
	\u{1b7}\x03\x02\x02\x02\u{1b9}\u{1bc}\x03\x02\x02\x02\u{1ba}\u{1b8}\x03\
	\x02\x02\x02\u{1ba}\u{1bb}\x03\x02\x02\x02\u{1bb}\u{1ca}\x03\x02\x02\x02\
	\u{1bc}\u{1ba}\x03\x02\x02\x02\u{1bd}\u{1bf}\x05\x10\x09\x02\u{1be}\u{1bd}\
	\x03\x02\x02\x02\u{1bf}\u{1c2}\x03\x02\x02\x02\u{1c0}\u{1be}\x03\x02\x02\
	\x02\u{1c0}\u{1c1}\x03\x02\x02\x02\u{1c1}\u{1ca}\x03\x02\x02\x02\u{1c2}\
	\u{1c0}\x03\x02\x02\x02\u{1c3}\u{1c5}\x05\x14\x0b\x02\u{1c4}\u{1c3}\x03\
	\x02\x02\x02\u{1c5}\u{1c8}\x03\x02\x02\x02\u{1c6}\u{1c4}\x03\x02\x02\x02\
	\u{1c6}\u{1c7}\x03\x02\x02\x02\u{1c7}\u{1ca}\x03\x02\x02\x02\u{1c8}\u{1c6}\
	\x03\x02\x02\x02\u{1c9}\u{1ba}\x03\x02\x02\x02\u{1c9}\u{1c0}\x03\x02\x02\
	\x02\u{1c9}\u{1c6}\x03\x02\x02\x02\u{1ca}\x0b\x03\x02\x02\x02\u{1cb}\u{1cc}\
	\x07\x07\x02\x02\u{1cc}\u{1d1}\x05\x0e\x08\x02\u{1cd}\u{1ce}\x07\x08\x02\
	\x02\u{1ce}\u{1d0}\x05\x0e\x08\x02\u{1cf}\u{1cd}\x03\x02\x02\x02\u{1d0}\
	\u{1d3}\x03\x02\x02\x02\u{1d1}\u{1cf}\x03\x02\x02\x02\u{1d1}\u{1d2}\x03\
	\x02\x02\x02\u{1d2}\u{1d4}\x03\x02\x02\x02\u{1d3}\u{1d1}\x03\x02\x02\x02\
	\u{1d4}\u{1d5}\x07\x04\x02\x02\u{1d5}\x0d\x03\x02\x02\x02\u{1d6}\u{1d7}\
	\x05\x16\x0c\x02\u{1d7}\u{1d8}\x07\x09\x02\x02\u{1d8}\u{1d9}\x07\x0a\x02\
	\x02\u{1d9}\u{1e1}\x03\x02\x02\x02\u{1da}\u{1de}\x05\x04\x03\x02\u{1db}\
	\u{1dc}\x07\x0b\x02\x02\u{1dc}\u{1dd}\x07\x0c\x02\x02\u{1dd}\u{1df}\x07\
	\x0d\x02\x02\u{1de}\u{1db}\x03\x02\x02\x02\u{1de}\u{1df}\x03\x02\x02\x02\
	\u{1df}\u{1e1}\x03\x02\x02\x02\u{1e0}\u{1d6}\x03\x02\x02\x02\u{1e0}\u{1da}\
	\x03\x02\x02\x02\u{1e1}\x0f\x03\x02\x02\x02\u{1e2}\u{1e3}\x07\x0e\x02\x02\
	\u{1e3}\u{1e8}\x05\x12\x0a\x02\u{1e4}\u{1e5}\x07\x08\x02\x02\u{1e5}\u{1e7}\
	\x05\x12\x0a\x02\u{1e6}\u{1e4}\x03\x02\x02\x02\u{1e7}\u{1ea}\x03\x02\x02\
	\x02\u{1e8}\u{1e6}\x03\x02\x02\x02\u{1e8}\u{1e9}\x03\x02\x02\x02\u{1e9}\
	\u{1eb}\x03\x02\x02\x02\u{1ea}\u{1e8}\x03\x02\x02\x02\u{1eb}\u{1ec}\x07\
	\x04\x02\x02\u{1ec}\x11\x03\x02\x02\x02\u{1ed}\u{1ee}\x05\x16\x0c\x02\u{1ee}\
	\u{1ef}\x07\x09\x02\x02\u{1ef}\u{1f0}\x07\x0a\x02\x02\u{1f0}\x13\x03\x02\
	\x02\x02\u{1f1}\u{1fc}\x05\x32\x1a\x02\u{1f2}\u{1fc}\x05\x20\x11\x02\u{1f3}\
	\u{1fc}\x05\x54\x2b\x02\u{1f4}\u{1fc}\x05\x6a\x36\x02\u{1f5}\u{1fc}\x05\
	\x70\x39\x02\u{1f6}\u{1fc}\x05\u{c4}\x63\x02\u{1f7}\u{1fc}\x05\u{136}\u{9c}\
	\x02\u{1f8}\u{1fc}\x05\u{142}\u{a2}\x02\u{1f9}\u{1fc}\x05\u{146}\u{a4}\x02\
	\u{1fa}\u{1fc}\x05\u{17e}\u{c0}\x02\u{1fb}\u{1f1}\x03\x02\x02\x02\u{1fb}\
	\u{1f2}\x03\x02\x02\x02\u{1fb}\u{1f3}\x03\x02\x02\x02\u{1fb}\u{1f4}\x03\
	\x02\x02\x02\u{1fb}\u{1f5}\x03\x02\x02\x02\u{1fb}\u{1f6}\x03\x02\x02\x02\
	\u{1fb}\u{1f7}\x03\x02\x02\x02\u{1fb}\u{1f8}\x03\x02\x02\x02\u{1fb}\u{1f9}\
	\x03\x02\x02\x02\u{1fb}\u{1fa}\x03\x02\x02\x02\u{1fc}\x15\x03\x02\x02\x02\
	\u{1fd}\u{1fe}\x07\u{93}\x02\x02\u{1fe}\x17\x03\x02\x02\x02\u{1ff}\u{200}\
	\x05\x1c\x0f\x02\u{200}\x19\x03\x02\x02\x02\u{201}\u{202}\x07\u{98}\x02\
	\x02\u{202}\x1b\x03\x02\x02\x02\u{203}\u{210}\x05\x1e\x10\x02\u{204}\u{205}\
	\x07\x0f\x02\x02\u{205}\u{206}\x07\x0b\x02\x02\u{206}\u{20b}\x05\x18\x0d\
	\x02\u{207}\u{208}\x07\x08\x02\x02\u{208}\u{20a}\x05\x18\x0d\x02\u{209}\
	\u{207}\x03\x02\x02\x02\u{20a}\u{20d}\x03\x02\x02\x02\u{20b}\u{209}\x03\
	\x02\x02\x02\u{20b}\u{20c}\x03\x02\x02\x02\u{20c}\u{20e}\x03\x02\x02\x02\
	\u{20d}\u{20b}\x03\x02\x02\x02\u{20e}\u{20f}\x07\x0d\x02\x02\u{20f}\u{211}\
	\x03\x02\x02\x02\u{210}\u{204}\x03\x02\x02\x02\u{210}\u{211}\x03\x02\x02\
	\x02\u{211}\u{21b}\x03\x02\x02\x02\u{212}\u{21b}\x05\x1a\x0e\x02\u{213}\
	\u{214}\x07\x10\x02\x02\u{214}\u{215}\x07\x11\x02\x02\u{215}\u{216}\x05\
	\x1a\x0e\x02\u{216}\u{217}\x07\x06\x02\x02\u{217}\u{218}\x05\x1a\x0e\x02\
	\u{218}\u{219}\x07\x12\x02\x02\u{219}\u{21b}\x03\x02\x02\x02\u{21a}\u{203}\
	\x03\x02\x02\x02\u{21a}\u{212}\x03\x02\x02\x02\u{21a}\u{213}\x03\x02\x02\
	\x02\u{21b}\x1d\x03\x02\x02\x02\u{21c}\u{21d}\x07\u{93}\x02\x02\u{21d}\u{21f}\
	\x07\x09\x02\x02\u{21e}\u{21c}\x03\x02\x02\x02\u{21f}\u{222}\x03\x02\x02\
	\x02\u{220}\u{21e}\x03\x02\x02\x02\u{220}\u{221}\x03\x02\x02\x02\u{221}\
	\u{223}\x03\x02\x02\x02\u{222}\u{220}\x03\x02\x02\x02\u{223}\u{227}\x07\
	\u{93}\x02\x02\u{224}\u{227}\x07\x13\x02\x02\u{225}\u{227}\x05\x02\x02\x02\
	\u{226}\u{220}\x03\x02\x02\x02\u{226}\u{224}\x03\x02\x02\x02\u{226}\u{225}\
	\x03\x02\x02\x02\u{227}\x1f\x03\x02\x02\x02\u{228}\u{229}\x05\u{12c}\u{97}\
	\x02\u{229}\u{22a}\x07\x14\x02\x02\u{22a}\u{22b}\x05\x22\x12\x02\u{22b}\
	\u{22f}\x07\x04\x02\x02\u{22c}\u{22e}\x05\x28\x15\x02\u{22d}\u{22c}\x03\
	\x02\x02\x02\u{22e}\u{231}\x03\x02\x02\x02\u{22f}\u{22d}\x03\x02\x02\x02\
	\u{22f}\u{230}\x03\x02\x02\x02\u{230}\u{232}\x03\x02\x02\x02\u{231}\u{22f}\
	\x03\x02\x02\x02\u{232}\u{235}\x07\x15\x02\x02\u{233}\u{234}\x07\x06\x02\
	\x02\u{234}\u{236}\x05\x1e\x10\x02\u{235}\u{233}\x03\x02\x02\x02\u{235}\
	\u{236}\x03\x02\x02\x02\u{236}\x21\x03\x02\x02\x02\u{237}\u{239}\x05\x1e\
	\x10\x02\u{238}\u{23a}\x05\x24\x13\x02\u{239}\u{238}\x03\x02\x02\x02\u{239}\
	\u{23a}\x03\x02\x02\x02\u{23a}\x23\x03\x02\x02\x02\u{23b}\u{23c}\x07\x0f\
	\x02\x02\u{23c}\u{23d}\x07\x0b\x02\x02\u{23d}\u{242}\x05\x26\x14\x02\u{23e}\
	\u{23f}\x07\x08\x02\x02\u{23f}\u{241}\x05\x26\x14\x02\u{240}\u{23e}\x03\
	\x02\x02\x02\u{241}\u{244}\x03\x02\x02\x02\u{242}\u{240}\x03\x02\x02\x02\
	\u{242}\u{243}\x03\x02\x02\x02\u{243}\u{245}\x03\x02\x02\x02\u{244}\u{242}\
	\x03\x02\x02\x02\u{245}\u{246}\x07\x0d\x02\x02\u{246}\x25\x03\x02\x02\x02\
	\u{247}\u{249}\x07\x16\x02\x02\u{248}\u{247}\x03\x02\x02\x02\u{248}\u{249}\
	\x03\x02\x02\x02\u{249}\u{24b}\x03\x02\x02\x02\u{24a}\u{24c}\x07\x17\x02\
	\x02\u{24b}\u{24a}\x03\x02\x02\x02\u{24b}\u{24c}\x03\x02\x02\x02\u{24c}\
	\u{24d}\x03\x02\x02\x02\u{24d}\u{24e}\x05\x1e\x10\x02\u{24e}\x27\x03\x02\
	\x02\x02\u{24f}\u{252}\x05\x2a\x16\x02\u{250}\u{252}\x05\x30\x19\x02\u{251}\
	\u{24f}\x03\x02\x02\x02\u{251}\u{250}\x03\x02\x02\x02\u{252}\x29\x03\x02\
	\x02\x02\u{253}\u{254}\x05\u{12c}\u{97}\x02\u{254}\u{255}\x07\x18\x02\x02\
	\u{255}\u{256}\x05\x3e\x20\x02\u{256}\u{25c}\x05\x02\x02\x02\u{257}\u{259}\
	\x07\x0b\x02\x02\u{258}\u{25a}\x05\x2c\x17\x02\u{259}\u{258}\x03\x02\x02\
	\x02\u{259}\u{25a}\x03\x02\x02\x02\u{25a}\u{25b}\x03\x02\x02\x02\u{25b}\
	\u{25d}\x07\x0d\x02\x02\u{25c}\u{257}\x03\x02\x02\x02\u{25c}\u{25d}\x03\
	\x02\x02\x02\u{25d}\u{25e}\x03\x02\x02\x02\u{25e}\u{25f}\x07\x04\x02\x02\
	\u{25f}\x2b\x03\x02\x02\x02\u{260}\u{265}\x05\x2e\x18\x02\u{261}\u{262}\
	\x07\x08\x02\x02\u{262}\u{264}\x05\x2e\x18\x02\u{263}\u{261}\x03\x02\x02\
	\x02\u{264}\u{267}\x03\x02\x02\x02\u{265}\u{263}\x03\x02\x02\x02\u{265}\
	\u{266}\x03\x02\x02\x02\u{266}\x2d\x03\x02\x02\x02\u{267}\u{265}\x03\x02\
	\x02\x02\u{268}\u{26a}\x05\u{12c}\u{97}\x02\u{269}\u{26b}\x05\x18\x0d\x02\
	\u{26a}\u{269}\x03\x02\x02\x02\u{26a}\u{26b}\x03\x02\x02\x02\u{26b}\u{26c}\
	\x03\x02\x02\x02\u{26c}\u{26d}\x05\x02\x02\x02\u{26d}\x2f\x03\x02\x02\x02\
	\u{26e}\u{26f}\x05\u{12c}\u{97}\x02\u{26f}\u{270}\x07\x14\x02\x02\u{270}\
	\u{271}\x05\x22\x12\x02\u{271}\u{272}\x05\x02\x02\x02\u{272}\u{273}\x07\
	\x04\x02\x02\u{273}\x31\x03\x02\x02\x02\u{274}\u{275}\x05\u{12c}\u{97}\x02\
	\u{275}\u{279}\x05\x34\x1b\x02\u{276}\u{278}\x05\x3c\x1f\x02\u{277}\u{276}\
	\x03\x02\x02\x02\u{278}\u{27b}\x03\x02\x02\x02\u{279}\u{277}\x03\x02\x02\
	\x02\u{279}\u{27a}\x03\x02\x02\x02\u{27a}\u{27c}\x03\x02\x02\x02\u{27b}\
	\u{279}\x03\x02\x02\x02\u{27c}\u{27f}\x07\x19\x02\x02\u{27d}\u{27e}\x07\
	\x06\x02\x02\u{27e}\u{280}\x05\x02\x02\x02\u{27f}\u{27d}\x03\x02\x02\x02\
	\u{27f}\u{280}\x03\x02\x02\x02\u{280}\x33\x03\x02\x02\x02\u{281}\u{286}\
	\x07\x1a\x02\x02\u{282}\u{283}\x07\x11\x02\x02\u{283}\u{284}\x05\u{d2}\x6a\
	\x02\u{284}\u{285}\x07\x12\x02\x02\u{285}\u{287}\x03\x02\x02\x02\u{286}\
	\u{282}\x03\x02\x02\x02\u{286}\u{287}\x03\x02\x02\x02\u{287}\u{288}\x03\
	\x02\x02\x02\u{288}\u{28f}\x05\x02\x02\x02\u{289}\u{28a}\x07\x0f\x02\x02\
	\u{28a}\u{28c}\x07\x0b\x02\x02\u{28b}\u{28d}\x05\x36\x1c\x02\u{28c}\u{28b}\
	\x03\x02\x02\x02\u{28c}\u{28d}\x03\x02\x02\x02\u{28d}\u{28e}\x03\x02\x02\
	\x02\u{28e}\u{290}\x07\x0d\x02\x02\u{28f}\u{289}\x03\x02\x02\x02\u{28f}\
	\u{290}\x03\x02\x02\x02\u{290}\u{291}\x03\x02\x02\x02\u{291}\u{292}\x07\
	\x0b\x02\x02\u{292}\u{293}\x05\x18\x0d\x02\u{293}\u{295}\x07\x0d\x02\x02\
	\u{294}\u{296}\x05\u{132}\u{9a}\x02\u{295}\u{294}\x03\x02\x02\x02\u{295}\
	\u{296}\x03\x02\x02\x02\u{296}\u{297}\x03\x02\x02\x02\u{297}\u{298}\x07\
	\x04\x02\x02\u{298}\x35\x03\x02\x02\x02\u{299}\u{29e}\x05\x38\x1d\x02\u{29a}\
	\u{29b}\x07\x08\x02\x02\u{29b}\u{29d}\x05\x38\x1d\x02\u{29c}\u{29a}\x03\
	\x02\x02\x02\u{29d}\u{2a0}\x03\x02\x02\x02\u{29e}\u{29c}\x03\x02\x02\x02\
	\u{29e}\u{29f}\x03\x02\x02\x02\u{29f}\x37\x03\x02\x02\x02\u{2a0}\u{29e}\
	\x03\x02\x02\x02\u{2a1}\u{2a3}\x05\u{12c}\u{97}\x02\u{2a2}\u{2a4}\x07\x1b\
	\x02\x02\u{2a3}\u{2a2}\x03\x02\x02\x02\u{2a3}\u{2a4}\x03\x02\x02\x02\u{2a4}\
	\u{2a5}\x03\x02\x02\x02\u{2a5}\u{2a6}\x05\x18\x0d\x02\u{2a6}\u{2a7}\x05\
	\x02\x02\x02\u{2a7}\u{2aa}\x03\x02\x02\x02\u{2a8}\u{2aa}\x05\u{c6}\x64\x02\
	\u{2a9}\u{2a1}\x03\x02\x02\x02\u{2a9}\u{2a8}\x03\x02\x02\x02\u{2aa}\x39\
	\x03\x02\x02\x02\u{2ab}\u{2ac}\x05\u{12c}\u{97}\x02\u{2ac}\u{2ad}\x05\x18\
	\x0d\x02\u{2ad}\u{2c1}\x03\x02\x02\x02\u{2ae}\u{2af}\x05\u{12c}\u{97}\x02\
	\u{2af}\u{2b0}\x05\x18\x0d\x02\u{2b0}\u{2b2}\x05\x02\x02\x02\u{2b1}\u{2b3}\
	\x07\x1c\x02\x02\u{2b2}\u{2b1}\x03\x02\x02\x02\u{2b2}\u{2b3}\x03\x02\x02\
	\x02\u{2b3}\u{2bd}\x03\x02\x02\x02\u{2b4}\u{2b5}\x07\x08\x02\x02\u{2b5}\
	\u{2b6}\x05\u{12c}\u{97}\x02\u{2b6}\u{2b7}\x05\x18\x0d\x02\u{2b7}\u{2b9}\
	\x05\x02\x02\x02\u{2b8}\u{2ba}\x07\x1c\x02\x02\u{2b9}\u{2b8}\x03\x02\x02\
	\x02\u{2b9}\u{2ba}\x03\x02\x02\x02\u{2ba}\u{2bc}\x03\x02\x02\x02\u{2bb}\
	\u{2b4}\x03\x02\x02\x02\u{2bc}\u{2bf}\x03\x02\x02\x02\u{2bd}\u{2bb}\x03\
	\x02\x02\x02\u{2bd}\u{2be}\x03\x02\x02\x02\u{2be}\u{2c1}\x03\x02\x02\x02\
	\u{2bf}\u{2bd}\x03\x02\x02\x02\u{2c0}\u{2ab}\x03\x02\x02\x02\u{2c0}\u{2ae}\
	\x03\x02\x02\x02\u{2c1}\x3b\x03\x02\x02\x02\u{2c2}\u{2d5}\x05\x40\x21\x02\
	\u{2c3}\u{2d5}\x05\x48\x25\x02\u{2c4}\u{2d5}\x05\x4e\x28\x02\u{2c5}\u{2d5}\
	\x05\u{102}\u{82}\x02\u{2c6}\u{2d5}\x05\u{100}\u{81}\x02\u{2c7}\u{2c8}\x05\
	\u{d2}\x6a\x02\u{2c8}\u{2c9}\x07\x04\x02\x02\u{2c9}\u{2d5}\x03\x02\x02\x02\
	\u{2ca}\u{2d5}\x05\u{d0}\x69\x02\u{2cb}\u{2d5}\x05\x6a\x36\x02\u{2cc}\u{2d5}\
	\x05\x70\x39\x02\u{2cd}\u{2d5}\x05\u{c4}\x63\x02\u{2ce}\u{2d5}\x05\x32\x1a\
	\x02\u{2cf}\u{2d5}\x05\x7c\x3f\x02\u{2d0}\u{2d5}\x05\u{86}\x44\x02\u{2d1}\
	\u{2d5}\x05\u{8e}\x48\x02\u{2d2}\u{2d5}\x05\u{b6}\x5c\x02\u{2d3}\u{2d5}\
	\x05\u{ac}\x57\x02\u{2d4}\u{2c2}\x03\x02\x02\x02\u{2d4}\u{2c3}\x03\x02\x02\
	\x02\u{2d4}\u{2c4}\x03\x02\x02\x02\u{2d4}\u{2c5}\x03\x02\x02\x02\u{2d4}\
	\u{2c6}\x03\x02\x02\x02\u{2d4}\u{2c7}\x03\x02\x02\x02\u{2d4}\u{2ca}\x03\
	\x02\x02\x02\u{2d4}\u{2cb}\x03\x02\x02\x02\u{2d4}\u{2cc}\x03\x02\x02\x02\
	\u{2d4}\u{2cd}\x03\x02\x02\x02\u{2d4}\u{2ce}\x03\x02\x02\x02\u{2d4}\u{2cf}\
	\x03\x02\x02\x02\u{2d4}\u{2d0}\x03\x02\x02\x02\u{2d4}\u{2d1}\x03\x02\x02\
	\x02\u{2d4}\u{2d2}\x03\x02\x02\x02\u{2d4}\u{2d3}\x03\x02\x02\x02\u{2d5}\
	\x3d\x03\x02\x02\x02\u{2d6}\u{2d8}\x05\x18\x0d\x02\u{2d7}\u{2d6}\x03\x02\
	\x02\x02\u{2d7}\u{2d8}\x03\x02\x02\x02\u{2d8}\u{2e8}\x03\x02\x02\x02\u{2d9}\
	\u{2e8}\x07\x1d\x02\x02\u{2da}\u{2db}\x07\x1e\x02\x02\u{2db}\u{2dc}\x07\
	\x0f\x02\x02\u{2dc}\u{2dd}\x07\x0b\x02\x02\u{2dd}\u{2e2}\x05\x18\x0d\x02\
	\u{2de}\u{2df}\x07\x08\x02\x02\u{2df}\u{2e1}\x05\x18\x0d\x02\u{2e0}\u{2de}\
	\x03\x02\x02\x02\u{2e1}\u{2e4}\x03\x02\x02\x02\u{2e2}\u{2e0}\x03\x02\x02\
	\x02\u{2e2}\u{2e3}\x03\x02\x02\x02\u{2e3}\u{2e5}\x03\x02\x02\x02\u{2e4}\
	\u{2e2}\x03\x02\x02\x02\u{2e5}\u{2e6}\x07\x0d\x02\x02\u{2e6}\u{2e8}\x03\
	\x02\x02\x02\u{2e7}\u{2d7}\x03\x02\x02\x02\u{2e7}\u{2d9}\x03\x02\x02\x02\
	\u{2e7}\u{2da}\x03\x02\x02\x02\u{2e8}\x3f\x03\x02\x02\x02\u{2e9}\u{2ea}\
	\x07\x18\x02\x02\u{2ea}\u{2eb}\x05\x3e\x20\x02\u{2eb}\u{2f1}\x05\x02\x02\
	\x02\u{2ec}\u{2ee}\x07\x0b\x02\x02\u{2ed}\u{2ef}\x05\x44\x23\x02\u{2ee}\
	\u{2ed}\x03\x02\x02\x02\u{2ee}\u{2ef}\x03\x02\x02\x02\u{2ef}\u{2f0}\x03\
	\x02\x02\x02\u{2f0}\u{2f2}\x07\x0d\x02\x02\u{2f1}\u{2ec}\x03\x02\x02\x02\
	\u{2f1}\u{2f2}\x03\x02\x02\x02\u{2f2}\u{2f4}\x03\x02\x02\x02\u{2f3}\u{2f5}\
	\x05\x42\x22\x02\u{2f4}\u{2f3}\x03\x02\x02\x02\u{2f4}\u{2f5}\x03\x02\x02\
	\x02\u{2f5}\u{2f6}\x03\x02\x02\x02\u{2f6}\u{304}\x07\x04\x02\x02\u{2f7}\
	\u{305}\x05\u{cc}\x67\x02\u{2f8}\u{2fa}\x05\u{fa}\x7e\x02\u{2f9}\u{2f8}\
	\x03\x02\x02\x02\u{2fa}\u{2fd}\x03\x02\x02\x02\u{2fb}\u{2f9}\x03\x02\x02\
	\x02\u{2fb}\u{2fc}\x03\x02\x02\x02\u{2fc}\u{305}\x03\x02\x02\x02\u{2fd}\
	\u{2fb}\x03\x02\x02\x02\u{2fe}\u{300}\x05\u{fe}\u{80}\x02\u{2ff}\u{2fe}\
	\x03\x02\x02\x02\u{300}\u{303}\x03\x02\x02\x02\u{301}\u{2ff}\x03\x02\x02\
	\x02\u{301}\u{302}\x03\x02\x02\x02\u{302}\u{305}\x03\x02\x02\x02\u{303}\
	\u{301}\x03\x02\x02\x02\u{304}\u{2f7}\x03\x02\x02\x02\u{304}\u{2fb}\x03\
	\x02\x02\x02\u{304}\u{301}\x03\x02\x02\x02\u{305}\u{306}\x03\x02\x02\x02\
	\u{306}\u{309}\x07\x1f\x02\x02\u{307}\u{308}\x07\x06\x02\x02\u{308}\u{30a}\
	\x05\x02\x02\x02\u{309}\u{307}\x03\x02\x02\x02\u{309}\u{30a}\x03\x02\x02\
	\x02\u{30a}\u{31d}\x03\x02\x02\x02\u{30b}\u{30c}\x07\x18\x02\x02\u{30c}\
	\u{30d}\x05\x3e\x20\x02\u{30d}\u{313}\x05\x02\x02\x02\u{30e}\u{310}\x07\
	\x0b\x02\x02\u{30f}\u{311}\x05\x44\x23\x02\u{310}\u{30f}\x03\x02\x02\x02\
	\u{310}\u{311}\x03\x02\x02\x02\u{311}\u{312}\x03\x02\x02\x02\u{312}\u{314}\
	\x07\x0d\x02\x02\u{313}\u{30e}\x03\x02\x02\x02\u{313}\u{314}\x03\x02\x02\
	\x02\u{314}\u{316}\x03\x02\x02\x02\u{315}\u{317}\x05\x42\x22\x02\u{316}\
	\u{315}\x03\x02\x02\x02\u{316}\u{317}\x03\x02\x02\x02\u{317}\u{318}\x03\
	\x02\x02\x02\u{318}\u{319}\x07\x20\x02\x02\u{319}\u{31a}\x05\u{d2}\x6a\x02\
	\u{31a}\u{31b}\x07\x04\x02\x02\u{31b}\u{31d}\x03\x02\x02\x02\u{31c}\u{2e9}\
	\x03\x02\x02\x02\u{31c}\u{30b}\x03\x02\x02\x02\u{31d}\x41\x03\x02\x02\x02\
	\u{31e}\u{320}\x07\x21\x02\x02\u{31f}\u{31e}\x03\x02\x02\x02\u{31f}\u{320}\
	\x03\x02\x02\x02\u{320}\u{321}\x03\x02\x02\x02\u{321}\u{322}\x07\x0b\x02\
	\x02\u{322}\u{323}\x05\u{f2}\x7a\x02\u{323}\u{324}\x07\x0d\x02\x02\u{324}\
	\x43\x03\x02\x02\x02\u{325}\u{32a}\x05\x46\x24\x02\u{326}\u{327}\x07\x08\
	\x02\x02\u{327}\u{329}\x05\x46\x24\x02\u{328}\u{326}\x03\x02\x02\x02\u{329}\
	\u{32c}\x03\x02\x02\x02\u{32a}\u{328}\x03\x02\x02\x02\u{32a}\u{32b}\x03\
	\x02\x02\x02\u{32b}\x45\x03\x02\x02\x02\u{32c}\u{32a}\x03\x02\x02\x02\u{32d}\
	\u{32f}\x05\x18\x0d\x02\u{32e}\u{32d}\x03\x02\x02\x02\u{32e}\u{32f}\x03\
	\x02\x02\x02\u{32f}\u{330}\x03\x02\x02\x02\u{330}\u{331}\x05\x02\x02\x02\
	\u{331}\x47\x03\x02\x02\x02\u{332}\u{333}\x07\x14\x02\x02\u{333}\u{334}\
	\x07\u{93}\x02\x02\u{334}\u{335}\x05\x02\x02\x02\u{335}\u{339}\x07\x04\x02\
	\x02\u{336}\u{338}\x05\x4a\x26\x02\u{337}\u{336}\x03\x02\x02\x02\u{338}\
	\u{33b}\x03\x02\x02\x02\u{339}\u{337}\x03\x02\x02\x02\u{339}\u{33a}\x03\
	\x02\x02\x02\u{33a}\u{33c}\x03\x02\x02\x02\u{33b}\u{339}\x03\x02\x02\x02\
	\u{33c}\u{33f}\x07\x15\x02\x02\u{33d}\u{33e}\x07\x06\x02\x02\u{33e}\u{340}\
	\x05\x02\x02\x02\u{33f}\u{33d}\x03\x02\x02\x02\u{33f}\u{340}\x03\x02\x02\
	\x02\u{340}\u{34b}\x03\x02\x02\x02\u{341}\u{343}\x07\x14\x02\x02\u{342}\
	\u{344}\x05\x18\x0d\x02\u{343}\u{342}\x03\x02\x02\x02\u{343}\u{344}\x03\
	\x02\x02\x02\u{344}\u{345}\x03\x02\x02\x02\u{345}\u{346}\x05\x02\x02\x02\
	\u{346}\u{347}\x07\x20\x02\x02\u{347}\u{348}\x05\u{d2}\x6a\x02\u{348}\u{349}\
	\x07\x04\x02\x02\u{349}\u{34b}\x03\x02\x02\x02\u{34a}\u{332}\x03\x02\x02\
	\x02\u{34a}\u{341}\x03\x02\x02\x02\u{34b}\x49\x03\x02\x02\x02\u{34c}\u{350}\
	\x05\x40\x21\x02\u{34d}\u{350}\x05\x48\x25\x02\u{34e}\u{350}\x05\x4c\x27\
	\x02\u{34f}\u{34c}\x03\x02\x02\x02\u{34f}\u{34d}\x03\x02\x02\x02\u{34f}\
	\u{34e}\x03\x02\x02\x02\u{350}\x4b\x03\x02\x02\x02\u{351}\u{35a}\x05\x6a\
	\x36\x02\u{352}\u{35a}\x05\x70\x39\x02\u{353}\u{35a}\x05\u{c4}\x63\x02\u{354}\
	\u{35a}\x05\x7e\x40\x02\u{355}\u{35a}\x05\u{88}\x45\x02\u{356}\u{35a}\x05\
	\u{90}\x49\x02\u{357}\u{35a}\x05\u{b8}\x5d\x02\u{358}\u{35a}\x05\u{ae}\x58\
	\x02\u{359}\u{351}\x03\x02\x02\x02\u{359}\u{352}\x03\x02\x02\x02\u{359}\
	\u{353}\x03\x02\x02\x02\u{359}\u{354}\x03\x02\x02\x02\u{359}\u{355}\x03\
	\x02\x02\x02\u{359}\u{356}\x03\x02\x02\x02\u{359}\u{357}\x03\x02\x02\x02\
	\u{359}\u{358}\x03\x02\x02\x02\u{35a}\x4d\x03\x02\x02\x02\u{35b}\u{35c}\
	\x05\u{12c}\u{97}\x02\u{35c}\u{35d}\x07\x22\x02\x02\u{35d}\u{35f}\x05\x02\
	\x02\x02\u{35e}\u{360}\x05\x50\x29\x02\u{35f}\u{35e}\x03\x02\x02\x02\u{35f}\
	\u{360}\x03\x02\x02\x02\u{360}\u{361}\x03\x02\x02\x02\u{361}\u{362}\x07\
	\x04\x02\x02\u{362}\u{363}\x05\x52\x2a\x02\u{363}\u{366}\x07\x23\x02\x02\
	\u{364}\u{365}\x07\x06\x02\x02\u{365}\u{367}\x05\x02\x02\x02\u{366}\u{364}\
	\x03\x02\x02\x02\u{366}\u{367}\x03\x02\x02\x02\u{367}\x4f\x03\x02\x02\x02\
	\u{368}\u{36a}\x07\x21\x02\x02\u{369}\u{368}\x03\x02\x02\x02\u{369}\u{36a}\
	\x03\x02\x02\x02\u{36a}\u{36b}\x03\x02\x02\x02\u{36b}\u{36c}\x07\x0b\x02\
	\x02\u{36c}\u{36d}\x05\u{f2}\x7a\x02\u{36d}\u{36e}\x07\x0d\x02\x02\u{36e}\
	\x51\x03\x02\x02\x02\u{36f}\u{371}\x05\u{fa}\x7e\x02\u{370}\u{36f}\x03\x02\
	\x02\x02\u{371}\u{374}\x03\x02\x02\x02\u{372}\u{370}\x03\x02\x02\x02\u{372}\
	\u{373}\x03\x02\x02\x02\u{373}\x53\x03\x02\x02\x02\u{374}\u{372}\x03\x02\
	\x02\x02\u{375}\u{37a}\x05\x56\x2c\x02\u{376}\u{37a}\x05\x58\x2d\x02\u{377}\
	\u{37a}\x05\x5e\x30\x02\u{378}\u{37a}\x05\x60\x31\x02\u{379}\u{375}\x03\
	\x02\x02\x02\u{379}\u{376}\x03\x02\x02\x02\u{379}\u{377}\x03\x02\x02\x02\
	\u{379}\u{378}\x03\x02\x02\x02\u{37a}\x55\x03\x02\x02\x02\u{37b}\u{37c}\
	\x07\x24\x02\x02\u{37c}\u{37d}\x05\x18\x0d\x02\u{37d}\u{37e}\x05\x22\x12\
	\x02\u{37e}\u{37f}\x07\x04\x02\x02\u{37f}\x57\x03\x02\x02\x02\u{380}\u{381}\
	\x07\x24\x02\x02\u{381}\u{382}\x07\x25\x02\x02\u{382}\u{383}\x07\x26\x02\
	\x02\u{383}\u{384}\x05\x5a\x2e\x02\u{384}\u{385}\x07\x27\x02\x02\u{385}\
	\u{387}\x07\u{93}\x02\x02\u{386}\u{388}\x05\u{144}\u{a3}\x02\u{387}\u{386}\
	\x03\x02\x02\x02\u{387}\u{388}\x03\x02\x02\x02\u{388}\u{389}\x03\x02\x02\
	\x02\u{389}\u{38a}\x07\x04\x02\x02\u{38a}\x59\x03\x02\x02\x02\u{38b}\u{390}\
	\x05\x5c\x2f\x02\u{38c}\u{38d}\x07\x08\x02\x02\u{38d}\u{38f}\x05\x5c\x2f\
	\x02\u{38e}\u{38c}\x03\x02\x02\x02\u{38f}\u{392}\x03\x02\x02\x02\u{390}\
	\u{38e}\x03\x02\x02\x02\u{390}\u{391}\x03\x02\x02\x02\u{391}\x5b\x03\x02\
	\x02\x02\u{392}\u{390}\x03\x02\x02\x02\u{393}\u{396}\x07\u{93}\x02\x02\u{394}\
	\u{395}\x07\x20\x02\x02\u{395}\u{397}\x07\u{98}\x02\x02\u{396}\u{394}\x03\
	\x02\x02\x02\u{396}\u{397}\x03\x02\x02\x02\u{397}\u{3ab}\x03\x02\x02\x02\
	\u{398}\u{399}\x07\u{93}\x02\x02\u{399}\u{39a}\x07\x11\x02\x02\u{39a}\u{39b}\
	\x07\u{98}\x02\x02\u{39b}\u{39e}\x07\x12\x02\x02\u{39c}\u{39d}\x07\x20\x02\
	\x02\u{39d}\u{39f}\x07\u{98}\x02\x02\u{39e}\u{39c}\x03\x02\x02\x02\u{39e}\
	\u{39f}\x03\x02\x02\x02\u{39f}\u{3ab}\x03\x02\x02\x02\u{3a0}\u{3a1}\x07\
	\u{93}\x02\x02\u{3a1}\u{3a2}\x07\x11\x02\x02\u{3a2}\u{3a3}\x07\u{98}\x02\
	\x02\u{3a3}\u{3a4}\x07\x06\x02\x02\u{3a4}\u{3a5}\x07\u{98}\x02\x02\u{3a5}\
	\u{3a8}\x07\x12\x02\x02\u{3a6}\u{3a7}\x07\x20\x02\x02\u{3a7}\u{3a9}\x07\
	\u{98}\x02\x02\u{3a8}\u{3a6}\x03\x02\x02\x02\u{3a8}\u{3a9}\x03\x02\x02\x02\
	\u{3a9}\u{3ab}\x03\x02\x02\x02\u{3aa}\u{393}\x03\x02\x02\x02\u{3aa}\u{398}\
	\x03\x02\x02\x02\u{3aa}\u{3a0}\x03\x02\x02\x02\u{3ab}\x5d\x03\x02\x02\x02\
	\u{3ac}\u{3ad}\x07\x24\x02\x02\u{3ad}\u{3ae}\x07\x28\x02\x02\u{3ae}\u{3b2}\
	\x07\x26\x02\x02\u{3af}\u{3b1}\x05\x62\x32\x02\u{3b0}\u{3af}\x03\x02\x02\
	\x02\u{3b1}\u{3b4}\x03\x02\x02\x02\u{3b2}\u{3b0}\x03\x02\x02\x02\u{3b2}\
	\u{3b3}\x03\x02\x02\x02\u{3b3}\u{3b5}\x03\x02\x02\x02\u{3b4}\u{3b2}\x03\
	\x02\x02\x02\u{3b5}\u{3b6}\x07\x27\x02\x02\u{3b6}\u{3b8}\x05\x22\x12\x02\
	\u{3b7}\u{3b9}\x05\u{144}\u{a3}\x02\u{3b8}\u{3b7}\x03\x02\x02\x02\u{3b8}\
	\u{3b9}\x03\x02\x02\x02\u{3b9}\u{3ba}\x03\x02\x02\x02\u{3ba}\u{3bb}\x07\
	\x04\x02\x02\u{3bb}\x5f\x03\x02\x02\x02\u{3bc}\u{3bd}\x07\x24\x02\x02\u{3bd}\
	\u{3be}\x07\x29\x02\x02\u{3be}\u{3bf}\x07\x2a\x02\x02\u{3bf}\u{3c3}\x07\
	\x26\x02\x02\u{3c0}\u{3c2}\x05\x64\x33\x02\u{3c1}\u{3c0}\x03\x02\x02\x02\
	\u{3c2}\u{3c5}\x03\x02\x02\x02\u{3c3}\u{3c1}\x03\x02\x02\x02\u{3c3}\u{3c4}\
	\x03\x02\x02\x02\u{3c4}\u{3c6}\x03\x02\x02\x02\u{3c5}\u{3c3}\x03\x02\x02\
	\x02\u{3c6}\u{3c7}\x07\x27\x02\x02\u{3c7}\u{3c9}\x05\x22\x12\x02\u{3c8}\
	\u{3ca}\x05\u{144}\u{a3}\x02\u{3c9}\u{3c8}\x03\x02\x02\x02\u{3c9}\u{3ca}\
	\x03\x02\x02\x02\u{3ca}\u{3cb}\x03\x02\x02\x02\u{3cb}\u{3cc}\x07\x04\x02\
	\x02\u{3cc}\x61\x03\x02\x02\x02\u{3cd}\u{3ce}\x05\x18\x0d\x02\u{3ce}\u{3cf}\
	\x05\x02\x02\x02\u{3cf}\u{3d0}\x07\x04\x02\x02\u{3d0}\u{3d6}\x03\x02\x02\
	\x02\u{3d1}\u{3d2}\x05\x68\x35\x02\u{3d2}\u{3d3}\x05\x02\x02\x02\u{3d3}\
	\u{3d4}\x07\x04\x02\x02\u{3d4}\u{3d6}\x03\x02\x02\x02\u{3d5}\u{3cd}\x03\
	\x02\x02\x02\u{3d5}\u{3d1}\x03\x02\x02\x02\u{3d6}\x63\x03\x02\x02\x02\u{3d7}\
	\u{3d8}\x05\x18\x0d\x02\u{3d8}\u{3d9}\x07\u{93}\x02\x02\u{3d9}\u{3da}\x07\
	\x04\x02\x02\u{3da}\u{3e7}\x03\x02\x02\x02\u{3db}\u{3dc}\x05\x66\x34\x02\
	\u{3dc}\u{3dd}\x07\u{93}\x02\x02\u{3dd}\u{3de}\x07\x04\x02\x02\u{3de}\u{3e7}\
	\x03\x02\x02\x02\u{3df}\u{3e0}\x05\x68\x35\x02\u{3e0}\u{3e1}\x07\u{93}\x02\
	\x02\u{3e1}\u{3e2}\x07\x04\x02\x02\u{3e2}\u{3e7}\x03\x02\x02\x02\u{3e3}\
	\u{3e4}\x07\x2b\x02\x02\u{3e4}\u{3e5}\x07\u{93}\x02\x02\u{3e5}\u{3e7}\x07\
	\x04\x02\x02\u{3e6}\u{3d7}\x03\x02\x02\x02\u{3e6}\u{3db}\x03\x02\x02\x02\
	\u{3e6}\u{3df}\x03\x02\x02\x02\u{3e6}\u{3e3}\x03\x02\x02\x02\u{3e7}\x65\
	\x03\x02\x02\x02\u{3e8}\u{3e9}\x07\x28\x02\x02\u{3e9}\u{3ed}\x07\x26\x02\
	\x02\u{3ea}\u{3ec}\x05\x62\x32\x02\u{3eb}\u{3ea}\x03\x02\x02\x02\u{3ec}\
	\u{3ef}\x03\x02\x02\x02\u{3ed}\u{3eb}\x03\x02\x02\x02\u{3ed}\u{3ee}\x03\
	\x02\x02\x02\u{3ee}\u{3f0}\x03\x02\x02\x02\u{3ef}\u{3ed}\x03\x02\x02\x02\
	\u{3f0}\u{3f1}\x07\x27\x02\x02\u{3f1}\x67\x03\x02\x02\x02\u{3f2}\u{3f3}\
	\x07\x29\x02\x02\u{3f3}\u{3f4}\x07\x2a\x02\x02\u{3f4}\u{3f8}\x07\x26\x02\
	\x02\u{3f5}\u{3f7}\x05\x64\x33\x02\u{3f6}\u{3f5}\x03\x02\x02\x02\u{3f7}\
	\u{3fa}\x03\x02\x02\x02\u{3f8}\u{3f6}\x03\x02\x02\x02\u{3f8}\u{3f9}\x03\
	\x02\x02\x02\u{3f9}\u{3fb}\x03\x02\x02\x02\u{3fa}\u{3f8}\x03\x02\x02\x02\
	\u{3fb}\u{3fc}\x07\x27\x02\x02\u{3fc}\x69\x03\x02\x02\x02\u{3fd}\u{400}\
	\x05\u{12c}\u{97}\x02\u{3fe}\u{401}\x07\x2c\x02\x02\u{3ff}\u{401}\x05\x18\
	\x0d\x02\u{400}\u{3fe}\x03\x02\x02\x02\u{400}\u{3ff}\x03\x02\x02\x02\u{401}\
	\u{402}\x03\x02\x02\x02\u{402}\u{407}\x05\x6e\x38\x02\u{403}\u{404}\x07\
	\x08\x02\x02\u{404}\u{406}\x05\x6e\x38\x02\u{405}\u{403}\x03\x02\x02\x02\
	\u{406}\u{409}\x03\x02\x02\x02\u{407}\u{405}\x03\x02\x02\x02\u{407}\u{408}\
	\x03\x02\x02\x02\u{408}\u{40a}\x03\x02\x02\x02\u{409}\u{407}\x03\x02\x02\
	\x02\u{40a}\u{40b}\x07\x04\x02\x02\u{40b}\u{40e}\x03\x02\x02\x02\u{40c}\
	\u{40e}\x07\x2d\x02\x02\u{40d}\u{3fd}\x03\x02\x02\x02\u{40d}\u{40c}\x03\
	\x02\x02\x02\u{40e}\x6b\x03\x02\x02\x02\u{40f}\u{410}\x05\u{12c}\u{97}\x02\
	\u{410}\u{411}\x07\x2e\x02\x02\u{411}\u{412}\x05\u{112}\u{8a}\x02\u{412}\
	\u{413}\x07\x20\x02\x02\u{413}\u{414}\x05\u{d2}\x6a\x02\u{414}\u{415}\x07\
	\x04\x02\x02\u{415}\u{41e}\x03\x02\x02\x02\u{416}\u{417}\x05\u{12c}\u{97}\
	\x02\u{417}\u{418}\x07\x2e\x02\x02\u{418}\u{419}\x05\u{112}\u{8a}\x02\u{419}\
	\u{41a}\x07\x2f\x02\x02\u{41a}\u{41b}\x05\u{d2}\x6a\x02\u{41b}\u{41c}\x07\
	\x04\x02\x02\u{41c}\u{41e}\x03\x02\x02\x02\u{41d}\u{40f}\x03\x02\x02\x02\
	\u{41d}\u{416}\x03\x02\x02\x02\u{41e}\x6d\x03\x02\x02\x02\u{41f}\u{425}\
	\x05\x70\x39\x02\u{420}\u{421}\x05\x02\x02\x02\u{421}\u{422}\x07\x2f\x02\
	\x02\u{422}\u{423}\x05\u{d2}\x6a\x02\u{423}\u{425}\x03\x02\x02\x02\u{424}\
	\u{41f}\x03\x02\x02\x02\u{424}\u{420}\x03\x02\x02\x02\u{425}\x6f\x03\x02\
	\x02\x02\u{426}\u{427}\x05\x02\x02\x02\u{427}\u{428}\x07\x20\x02\x02\u{428}\
	\u{429}\x05\u{d2}\x6a\x02\u{429}\x71\x03\x02\x02\x02\u{42a}\u{442}\x05\x02\
	\x02\x02\u{42b}\u{42c}\x05\u{ea}\x76\x02\u{42c}\u{42d}\x07\x30\x02\x02\u{42d}\
	\u{42e}\x05\x02\x02\x02\u{42e}\u{442}\x03\x02\x02\x02\u{42f}\u{430}\x05\
	\u{ea}\x76\x02\u{430}\u{431}\x07\x11\x02\x02\u{431}\u{432}\x05\u{d2}\x6a\
	\x02\u{432}\u{433}\x07\x12\x02\x02\u{433}\u{442}\x03\x02\x02\x02\u{434}\
	\u{435}\x05\u{ea}\x76\x02\u{435}\u{436}\x07\x11\x02\x02\u{436}\u{43d}\x05\
	\u{d2}\x6a\x02\u{437}\u{438}\x07\x06\x02\x02\u{438}\u{43e}\x05\u{d2}\x6a\
	\x02\u{439}\u{43a}\x07\x31\x02\x02\u{43a}\u{43e}\x07\u{98}\x02\x02\u{43b}\
	\u{43c}\x07\x32\x02\x02\u{43c}\u{43e}\x07\u{98}\x02\x02\u{43d}\u{437}\x03\
	\x02\x02\x02\u{43d}\u{439}\x03\x02\x02\x02\u{43d}\u{43b}\x03\x02\x02\x02\
	\u{43e}\u{43f}\x03\x02\x02\x02\u{43f}\u{440}\x07\x12\x02\x02\u{440}\u{442}\
	\x03\x02\x02\x02\u{441}\u{42a}\x03\x02\x02\x02\u{441}\u{42b}\x03\x02\x02\
	\x02\u{441}\u{42f}\x03\x02\x02\x02\u{441}\u{434}\x03\x02\x02\x02\u{442}\
	\x73\x03\x02\x02\x02\u{443}\u{444}\x05\x72\x3a\x02\u{444}\u{445}\x07\x33\
	\x02\x02\u{445}\u{446}\x05\u{d2}\x6a\x02\u{446}\x75\x03\x02\x02\x02\u{447}\
	\u{44a}\x07\x34\x02\x02\u{448}\u{449}\x07\x06\x02\x02\u{449}\u{44b}\x05\
	\x02\x02\x02\u{44a}\u{448}\x03\x02\x02\x02\u{44a}\u{44b}\x03\x02\x02\x02\
	\u{44b}\u{44f}\x03\x02\x02\x02\u{44c}\u{44e}\x05\u{ce}\x68\x02\u{44d}\u{44c}\
	\x03\x02\x02\x02\u{44e}\u{451}\x03\x02\x02\x02\u{44f}\u{44d}\x03\x02\x02\
	\x02\u{44f}\u{450}\x03\x02\x02\x02\u{450}\u{452}\x03\x02\x02\x02\u{451}\
	\u{44f}\x03\x02\x02\x02\u{452}\u{455}\x07\x35\x02\x02\u{453}\u{454}\x07\
	\x06\x02\x02\u{454}\u{456}\x05\x02\x02\x02\u{455}\u{453}\x03\x02\x02\x02\
	\u{455}\u{456}\x03\x02\x02\x02\u{456}\x77\x03\x02\x02\x02\u{457}\u{45a}\
	\x07\x34\x02\x02\u{458}\u{459}\x07\x06\x02\x02\u{459}\u{45b}\x05\x02\x02\
	\x02\u{45a}\u{458}\x03\x02\x02\x02\u{45a}\u{45b}\x03\x02\x02\x02\u{45b}\
	\u{45f}\x03\x02\x02\x02\u{45c}\u{45e}\x05\u{fa}\x7e\x02\u{45d}\u{45c}\x03\
	\x02\x02\x02\u{45e}\u{461}\x03\x02\x02\x02\u{45f}\u{45d}\x03\x02\x02\x02\
	\u{45f}\u{460}\x03\x02\x02\x02\u{460}\u{462}\x03\x02\x02\x02\u{461}\u{45f}\
	\x03\x02\x02\x02\u{462}\u{465}\x07\x35\x02\x02\u{463}\u{464}\x07\x06\x02\
	\x02\u{464}\u{466}\x05\x02\x02\x02\u{465}\u{463}\x03\x02\x02\x02\u{465}\
	\u{466}\x03\x02\x02\x02\u{466}\x79\x03\x02\x02\x02\u{467}\u{46a}\x07\x34\
	\x02\x02\u{468}\u{469}\x07\x06\x02\x02\u{469}\u{46b}\x05\x02\x02\x02\u{46a}\
	\u{468}\x03\x02\x02\x02\u{46a}\u{46b}\x03\x02\x02\x02\u{46b}\u{46f}\x03\
	\x02\x02\x02\u{46c}\u{46e}\x05\u{fe}\u{80}\x02\u{46d}\u{46c}\x03\x02\x02\
	\x02\u{46e}\u{471}\x03\x02\x02\x02\u{46f}\u{46d}\x03\x02\x02\x02\u{46f}\
	\u{470}\x03\x02\x02\x02\u{470}\u{472}\x03\x02\x02\x02\u{471}\u{46f}\x03\
	\x02\x02\x02\u{472}\u{475}\x07\x35\x02\x02\u{473}\u{474}\x07\x06\x02\x02\
	\u{474}\u{476}\x05\x02\x02\x02\u{475}\u{473}\x03\x02\x02\x02\u{475}\u{476}\
	\x03\x02\x02\x02\u{476}\x7b\x03\x02\x02\x02\u{477}\u{47a}\x07\x34\x02\x02\
	\u{478}\u{479}\x07\x06\x02\x02\u{479}\u{47b}\x05\x02\x02\x02\u{47a}\u{478}\
	\x03\x02\x02\x02\u{47a}\u{47b}\x03\x02\x02\x02\u{47b}\u{47f}\x03\x02\x02\
	\x02\u{47c}\u{47e}\x05\x3c\x1f\x02\u{47d}\u{47c}\x03\x02\x02\x02\u{47e}\
	\u{481}\x03\x02\x02\x02\u{47f}\u{47d}\x03\x02\x02\x02\u{47f}\u{480}\x03\
	\x02\x02\x02\u{480}\u{482}\x03\x02\x02\x02\u{481}\u{47f}\x03\x02\x02\x02\
	\u{482}\u{485}\x07\x35\x02\x02\u{483}\u{484}\x07\x06\x02\x02\u{484}\u{486}\
	\x05\x02\x02\x02\u{485}\u{483}\x03\x02\x02\x02\u{485}\u{486}\x03\x02\x02\
	\x02\u{486}\x7d\x03\x02\x02\x02\u{487}\u{48a}\x07\x34\x02\x02\u{488}\u{489}\
	\x07\x06\x02\x02\u{489}\u{48b}\x05\x02\x02\x02\u{48a}\u{488}\x03\x02\x02\
	\x02\u{48a}\u{48b}\x03\x02\x02\x02\u{48b}\u{48f}\x03\x02\x02\x02\u{48c}\
	\u{48e}\x05\x4c\x27\x02\u{48d}\u{48c}\x03\x02\x02\x02\u{48e}\u{491}\x03\
	\x02\x02\x02\u{48f}\u{48d}\x03\x02\x02\x02\u{48f}\u{490}\x03\x02\x02\x02\
	\u{490}\u{492}\x03\x02\x02\x02\u{491}\u{48f}\x03\x02\x02\x02\u{492}\u{495}\
	\x07\x35\x02\x02\u{493}\u{494}\x07\x06\x02\x02\u{494}\u{496}\x05\x02\x02\
	\x02\u{495}\u{493}\x03\x02\x02\x02\u{495}\u{496}\x03\x02\x02\x02\u{496}\
	\x7f\x03\x02\x02\x02\u{497}\u{498}\x07\x21\x02\x02\u{498}\u{499}\x07\x0b\
	\x02\x02\u{499}\u{49a}\x05\u{f2}\x7a\x02\u{49a}\u{49b}\x07\x0d\x02\x02\u{49b}\
	\u{49e}\x05\u{ce}\x68\x02\u{49c}\u{49d}\x07\x36\x02\x02\u{49d}\u{49f}\x05\
	\u{ce}\x68\x02\u{49e}\u{49c}\x03\x02\x02\x02\u{49e}\u{49f}\x03\x02\x02\x02\
	\u{49f}\u{81}\x03\x02\x02\x02\u{4a0}\u{4a1}\x07\x21\x02\x02\u{4a1}\u{4a2}\
	\x07\x0b\x02\x02\u{4a2}\u{4a3}\x05\u{f2}\x7a\x02\u{4a3}\u{4a4}\x07\x0d\x02\
	\x02\u{4a4}\u{4a7}\x05\u{fa}\x7e\x02\u{4a5}\u{4a6}\x07\x36\x02\x02\u{4a6}\
	\u{4a8}\x05\u{fa}\x7e\x02\u{4a7}\u{4a5}\x03\x02\x02\x02\u{4a7}\u{4a8}\x03\
	\x02\x02\x02\u{4a8}\u{83}\x03\x02\x02\x02\u{4a9}\u{4aa}\x07\x21\x02\x02\
	\u{4aa}\u{4ab}\x07\x0b\x02\x02\u{4ab}\u{4ac}\x05\u{f2}\x7a\x02\u{4ac}\u{4ad}\
	\x07\x0d\x02\x02\u{4ad}\u{4b0}\x05\u{fe}\u{80}\x02\u{4ae}\u{4af}\x07\x36\
	\x02\x02\u{4af}\u{4b1}\x05\u{fe}\u{80}\x02\u{4b0}\u{4ae}\x03\x02\x02\x02\
	\u{4b0}\u{4b1}\x03\x02\x02\x02\u{4b1}\u{85}\x03\x02\x02\x02\u{4b2}\u{4b3}\
	\x07\x21\x02\x02\u{4b3}\u{4b4}\x07\x0b\x02\x02\u{4b4}\u{4b5}\x05\u{f2}\x7a\
	\x02\u{4b5}\u{4b6}\x07\x0d\x02\x02\u{4b6}\u{4b9}\x05\x3c\x1f\x02\u{4b7}\
	\u{4b8}\x07\x36\x02\x02\u{4b8}\u{4ba}\x05\x3c\x1f\x02\u{4b9}\u{4b7}\x03\
	\x02\x02\x02\u{4b9}\u{4ba}\x03\x02\x02\x02\u{4ba}\u{87}\x03\x02\x02\x02\
	\u{4bb}\u{4bc}\x07\x21\x02\x02\u{4bc}\u{4bd}\x07\x0b\x02\x02\u{4bd}\u{4be}\
	\x05\u{f2}\x7a\x02\u{4be}\u{4bf}\x07\x0d\x02\x02\u{4bf}\u{4c2}\x05\x4c\x27\
	\x02\u{4c0}\u{4c1}\x07\x36\x02\x02\u{4c1}\u{4c3}\x05\x4c\x27\x02\u{4c2}\
	\u{4c0}\x03\x02\x02\x02\u{4c2}\u{4c3}\x03\x02\x02\x02\u{4c3}\u{89}\x03\x02\
	\x02\x02\u{4c4}\u{4c5}\x07\x37\x02\x02\u{4c5}\u{4c6}\x07\x0b\x02\x02\u{4c6}\
	\u{4c7}\x05\u{d2}\x6a\x02\u{4c7}\u{4cb}\x07\x0d\x02\x02\u{4c8}\u{4ca}\x05\
	\u{94}\x4b\x02\u{4c9}\u{4c8}\x03\x02\x02\x02\u{4ca}\u{4cd}\x03\x02\x02\x02\
	\u{4cb}\u{4c9}\x03\x02\x02\x02\u{4cb}\u{4cc}\x03\x02\x02\x02\u{4cc}\u{4cf}\
	\x03\x02\x02\x02\u{4cd}\u{4cb}\x03\x02\x02\x02\u{4ce}\u{4d0}\x05\u{9e}\x50\
	\x02\u{4cf}\u{4ce}\x03\x02\x02\x02\u{4cf}\u{4d0}\x03\x02\x02\x02\u{4d0}\
	\u{4d1}\x03\x02\x02\x02\u{4d1}\u{4d2}\x07\x38\x02\x02\u{4d2}\u{4e4}\x03\
	\x02\x02\x02\u{4d3}\u{4d4}\x07\x37\x02\x02\u{4d4}\u{4d5}\x07\x0b\x02\x02\
	\u{4d5}\u{4d6}\x05\u{d2}\x6a\x02\u{4d6}\u{4d7}\x07\x0d\x02\x02\u{4d7}\u{4db}\
	\x07\x39\x02\x02\u{4d8}\u{4da}\x05\u{11e}\u{90}\x02\u{4d9}\u{4d8}\x03\x02\
	\x02\x02\u{4da}\u{4dd}\x03\x02\x02\x02\u{4db}\u{4d9}\x03\x02\x02\x02\u{4db}\
	\u{4dc}\x03\x02\x02\x02\u{4dc}\u{4df}\x03\x02\x02\x02\u{4dd}\u{4db}\x03\
	\x02\x02\x02\u{4de}\u{4e0}\x05\u{9e}\x50\x02\u{4df}\u{4de}\x03\x02\x02\x02\
	\u{4df}\u{4e0}\x03\x02\x02\x02\u{4e0}\u{4e1}\x03\x02\x02\x02\u{4e1}\u{4e2}\
	\x07\x38\x02\x02\u{4e2}\u{4e4}\x03\x02\x02\x02\u{4e3}\u{4c4}\x03\x02\x02\
	\x02\u{4e3}\u{4d3}\x03\x02\x02\x02\u{4e4}\u{8b}\x03\x02\x02\x02\u{4e5}\u{4e6}\
	\x07\x37\x02\x02\u{4e6}\u{4e7}\x07\x0b\x02\x02\u{4e7}\u{4e8}\x05\u{d2}\x6a\
	\x02\u{4e8}\u{4ec}\x07\x0d\x02\x02\u{4e9}\u{4eb}\x05\u{96}\x4c\x02\u{4ea}\
	\u{4e9}\x03\x02\x02\x02\u{4eb}\u{4ee}\x03\x02\x02\x02\u{4ec}\u{4ea}\x03\
	\x02\x02\x02\u{4ec}\u{4ed}\x03\x02\x02\x02\u{4ed}\u{4f0}\x03\x02\x02\x02\
	\u{4ee}\u{4ec}\x03\x02\x02\x02\u{4ef}\u{4f1}\x05\u{a0}\x51\x02\u{4f0}\u{4ef}\
	\x03\x02\x02\x02\u{4f0}\u{4f1}\x03\x02\x02\x02\u{4f1}\u{4f2}\x03\x02\x02\
	\x02\u{4f2}\u{4f3}\x07\x38\x02\x02\u{4f3}\u{505}\x03\x02\x02\x02\u{4f4}\
	\u{4f5}\x07\x37\x02\x02\u{4f5}\u{4f6}\x07\x0b\x02\x02\u{4f6}\u{4f7}\x05\
	\u{d2}\x6a\x02\u{4f7}\u{4f8}\x07\x0d\x02\x02\u{4f8}\u{4fc}\x07\x39\x02\x02\
	\u{4f9}\u{4fb}\x05\u{120}\u{91}\x02\u{4fa}\u{4f9}\x03\x02\x02\x02\u{4fb}\
	\u{4fe}\x03\x02\x02\x02\u{4fc}\u{4fa}\x03\x02\x02\x02\u{4fc}\u{4fd}\x03\
	\x02\x02\x02\u{4fd}\u{500}\x03\x02\x02\x02\u{4fe}\u{4fc}\x03\x02\x02\x02\
	\u{4ff}\u{501}\x05\u{a0}\x51\x02\u{500}\u{4ff}\x03\x02\x02\x02\u{500}\u{501}\
	\x03\x02\x02\x02\u{501}\u{502}\x03\x02\x02\x02\u{502}\u{503}\x07\x38\x02\
	\x02\u{503}\u{505}\x03\x02\x02\x02\u{504}\u{4e5}\x03\x02\x02\x02\u{504}\
	\u{4f4}\x03\x02\x02\x02\u{505}\u{8d}\x03\x02\x02\x02\u{506}\u{507}\x07\x37\
	\x02\x02\u{507}\u{508}\x07\x0b\x02\x02\u{508}\u{509}\x05\u{d2}\x6a\x02\u{509}\
	\u{50d}\x07\x0d\x02\x02\u{50a}\u{50c}\x05\u{98}\x4d\x02\u{50b}\u{50a}\x03\
	\x02\x02\x02\u{50c}\u{50f}\x03\x02\x02\x02\u{50d}\u{50b}\x03\x02\x02\x02\
	\u{50d}\u{50e}\x03\x02\x02\x02\u{50e}\u{511}\x03\x02\x02\x02\u{50f}\u{50d}\
	\x03\x02\x02\x02\u{510}\u{512}\x05\u{a2}\x52\x02\u{511}\u{510}\x03\x02\x02\
	\x02\u{511}\u{512}\x03\x02\x02\x02\u{512}\u{513}\x03\x02\x02\x02\u{513}\
	\u{514}\x07\x38\x02\x02\u{514}\u{526}\x03\x02\x02\x02\u{515}\u{516}\x07\
	\x37\x02\x02\u{516}\u{517}\x07\x0b\x02\x02\u{517}\u{518}\x05\u{d2}\x6a\x02\
	\u{518}\u{519}\x07\x0d\x02\x02\u{519}\u{51d}\x07\x39\x02\x02\u{51a}\u{51c}\
	\x05\u{122}\u{92}\x02\u{51b}\u{51a}\x03\x02\x02\x02\u{51c}\u{51f}\x03\x02\
	\x02\x02\u{51d}\u{51b}\x03\x02\x02\x02\u{51d}\u{51e}\x03\x02\x02\x02\u{51e}\
	\u{521}\x03\x02\x02\x02\u{51f}\u{51d}\x03\x02\x02\x02\u{520}\u{522}\x05\
	\u{a2}\x52\x02\u{521}\u{520}\x03\x02\x02\x02\u{521}\u{522}\x03\x02\x02\x02\
	\u{522}\u{523}\x03\x02\x02\x02\u{523}\u{524}\x07\x38\x02\x02\u{524}\u{526}\
	\x03\x02\x02\x02\u{525}\u{506}\x03\x02\x02\x02\u{525}\u{515}\x03\x02\x02\
	\x02\u{526}\u{8f}\x03\x02\x02\x02\u{527}\u{528}\x07\x37\x02\x02\u{528}\u{529}\
	\x07\x0b\x02\x02\u{529}\u{52a}\x05\u{d2}\x6a\x02\u{52a}\u{52e}\x07\x0d\x02\
	\x02\u{52b}\u{52d}\x05\u{9a}\x4e\x02\u{52c}\u{52b}\x03\x02\x02\x02\u{52d}\
	\u{530}\x03\x02\x02\x02\u{52e}\u{52c}\x03\x02\x02\x02\u{52e}\u{52f}\x03\
	\x02\x02\x02\u{52f}\u{532}\x03\x02\x02\x02\u{530}\u{52e}\x03\x02\x02\x02\
	\u{531}\u{533}\x05\u{a4}\x53\x02\u{532}\u{531}\x03\x02\x02\x02\u{532}\u{533}\
	\x03\x02\x02\x02\u{533}\u{534}\x03\x02\x02\x02\u{534}\u{535}\x07\x38\x02\
	\x02\u{535}\u{547}\x03\x02\x02\x02\u{536}\u{537}\x07\x37\x02\x02\u{537}\
	\u{538}\x07\x0b\x02\x02\u{538}\u{539}\x05\u{d2}\x6a\x02\u{539}\u{53a}\x07\
	\x0d\x02\x02\u{53a}\u{53e}\x07\x39\x02\x02\u{53b}\u{53d}\x05\u{124}\u{93}\
	\x02\u{53c}\u{53b}\x03\x02\x02\x02\u{53d}\u{540}\x03\x02\x02\x02\u{53e}\
	\u{53c}\x03\x02\x02\x02\u{53e}\u{53f}\x03\x02\x02\x02\u{53f}\u{542}\x03\
	\x02\x02\x02\u{540}\u{53e}\x03\x02\x02\x02\u{541}\u{543}\x05\u{a4}\x53\x02\
	\u{542}\u{541}\x03\x02\x02\x02\u{542}\u{543}\x03\x02\x02\x02\u{543}\u{544}\
	\x03\x02\x02\x02\u{544}\u{545}\x07\x38\x02\x02\u{545}\u{547}\x03\x02\x02\
	\x02\u{546}\u{527}\x03\x02\x02\x02\u{546}\u{536}\x03\x02\x02\x02\u{547}\
	\u{91}\x03\x02\x02\x02\u{548}\u{54d}\x05\u{d2}\x6a\x02\u{549}\u{54a}\x07\
	\x08\x02\x02\u{54a}\u{54c}\x05\u{d2}\x6a\x02\u{54b}\u{549}\x03\x02\x02\x02\
	\u{54c}\u{54f}\x03\x02\x02\x02\u{54d}\u{54b}\x03\x02\x02\x02\u{54d}\u{54e}\
	\x03\x02\x02\x02\u{54e}\u{550}\x03\x02\x02\x02\u{54f}\u{54d}\x03\x02\x02\
	\x02\u{550}\u{551}\x07\x06\x02\x02\u{551}\u{552}\x05\u{ce}\x68\x02\u{552}\
	\u{93}\x03\x02\x02\x02\u{553}\u{558}\x05\u{d2}\x6a\x02\u{554}\u{555}\x07\
	\x08\x02\x02\u{555}\u{557}\x05\u{d2}\x6a\x02\u{556}\u{554}\x03\x02\x02\x02\
	\u{557}\u{55a}\x03\x02\x02\x02\u{558}\u{556}\x03\x02\x02\x02\u{558}\u{559}\
	\x03\x02\x02\x02\u{559}\u{55b}\x03\x02\x02\x02\u{55a}\u{558}\x03\x02\x02\
	\x02\u{55b}\u{55c}\x07\x06\x02\x02\u{55c}\u{55d}\x05\u{fa}\x7e\x02\u{55d}\
	\u{95}\x03\x02\x02\x02\u{55e}\u{563}\x05\u{d2}\x6a\x02\u{55f}\u{560}\x07\
	\x08\x02\x02\u{560}\u{562}\x05\u{d2}\x6a\x02\u{561}\u{55f}\x03\x02\x02\x02\
	\u{562}\u{565}\x03\x02\x02\x02\u{563}\u{561}\x03\x02\x02\x02\u{563}\u{564}\
	\x03\x02\x02\x02\u{564}\u{566}\x03\x02\x02\x02\u{565}\u{563}\x03\x02\x02\
	\x02\u{566}\u{567}\x07\x06\x02\x02\u{567}\u{568}\x05\u{fe}\u{80}\x02\u{568}\
	\u{97}\x03\x02\x02\x02\u{569}\u{56e}\x05\u{d2}\x6a\x02\u{56a}\u{56b}\x07\
	\x08\x02\x02\u{56b}\u{56d}\x05\u{d2}\x6a\x02\u{56c}\u{56a}\x03\x02\x02\x02\
	\u{56d}\u{570}\x03\x02\x02\x02\u{56e}\u{56c}\x03\x02\x02\x02\u{56e}\u{56f}\
	\x03\x02\x02\x02\u{56f}\u{571}\x03\x02\x02\x02\u{570}\u{56e}\x03\x02\x02\
	\x02\u{571}\u{572}\x07\x06\x02\x02\u{572}\u{573}\x05\x3c\x1f\x02\u{573}\
	\u{99}\x03\x02\x02\x02\u{574}\u{579}\x05\u{d2}\x6a\x02\u{575}\u{576}\x07\
	\x08\x02\x02\u{576}\u{578}\x05\u{d2}\x6a\x02\u{577}\u{575}\x03\x02\x02\x02\
	\u{578}\u{57b}\x03\x02\x02\x02\u{579}\u{577}\x03\x02\x02\x02\u{579}\u{57a}\
	\x03\x02\x02\x02\u{57a}\u{57c}\x03\x02\x02\x02\u{57b}\u{579}\x03\x02\x02\
	\x02\u{57c}\u{57d}\x07\x06\x02\x02\u{57d}\u{57e}\x05\x4c\x27\x02\u{57e}\
	\u{9b}\x03\x02\x02\x02\u{57f}\u{581}\x07\x3a\x02\x02\u{580}\u{582}\x07\x06\
	\x02\x02\u{581}\u{580}\x03\x02\x02\x02\u{581}\u{582}\x03\x02\x02\x02\u{582}\
	\u{583}\x03\x02\x02\x02\u{583}\u{584}\x05\u{ce}\x68\x02\u{584}\u{9d}\x03\
	\x02\x02\x02\u{585}\u{587}\x07\x3a\x02\x02\u{586}\u{588}\x07\x06\x02\x02\
	\u{587}\u{586}\x03\x02\x02\x02\u{587}\u{588}\x03\x02\x02\x02\u{588}\u{589}\
	\x03\x02\x02\x02\u{589}\u{58a}\x05\u{fa}\x7e\x02\u{58a}\u{9f}\x03\x02\x02\
	\x02\u{58b}\u{58d}\x07\x3a\x02\x02\u{58c}\u{58e}\x07\x06\x02\x02\u{58d}\
	\u{58c}\x03\x02\x02\x02\u{58d}\u{58e}\x03\x02\x02\x02\u{58e}\u{58f}\x03\
	\x02\x02\x02\u{58f}\u{590}\x05\u{fe}\u{80}\x02\u{590}\u{a1}\x03\x02\x02\
	\x02\u{591}\u{593}\x07\x3a\x02\x02\u{592}\u{594}\x07\x06\x02\x02\u{593}\
	\u{592}\x03\x02\x02\x02\u{593}\u{594}\x03\x02\x02\x02\u{594}\u{595}\x03\
	\x02\x02\x02\u{595}\u{596}\x05\x3c\x1f\x02\u{596}\u{a3}\x03\x02\x02\x02\
	\u{597}\u{599}\x07\x3a\x02\x02\u{598}\u{59a}\x07\x06\x02\x02\u{599}\u{598}\
	\x03\x02\x02\x02\u{599}\u{59a}\x03\x02\x02\x02\u{59a}\u{59b}\x03\x02\x02\
	\x02\u{59b}\u{59c}\x05\x4c\x27\x02\u{59c}\u{a5}\x03\x02\x02\x02\u{59d}\u{59e}\
	\x07\x3b\x02\x02\u{59e}\u{59f}\x07\x0b\x02\x02\u{59f}\u{5a0}\x05\u{d2}\x6a\
	\x02\u{5a0}\u{5a1}\x07\x0d\x02\x02\u{5a1}\u{5a2}\x05\u{ce}\x68\x02\u{5a2}\
	\u{a7}\x03\x02\x02\x02\u{5a3}\u{5a4}\x07\x3b\x02\x02\u{5a4}\u{5a5}\x07\x0b\
	\x02\x02\u{5a5}\u{5a6}\x05\u{d2}\x6a\x02\u{5a6}\u{5a7}\x07\x0d\x02\x02\u{5a7}\
	\u{5a8}\x05\u{fa}\x7e\x02\u{5a8}\u{a9}\x03\x02\x02\x02\u{5a9}\u{5aa}\x07\
	\x3b\x02\x02\u{5aa}\u{5ab}\x07\x0b\x02\x02\u{5ab}\u{5ac}\x05\u{d2}\x6a\x02\
	\u{5ac}\u{5ad}\x07\x0d\x02\x02\u{5ad}\u{5ae}\x05\u{fe}\u{80}\x02\u{5ae}\
	\u{ab}\x03\x02\x02\x02\u{5af}\u{5b0}\x07\x3b\x02\x02\u{5b0}\u{5b1}\x07\x0b\
	\x02\x02\u{5b1}\u{5b2}\x05\u{d2}\x6a\x02\u{5b2}\u{5b3}\x07\x0d\x02\x02\u{5b3}\
	\u{5b4}\x05\x3c\x1f\x02\u{5b4}\u{ad}\x03\x02\x02\x02\u{5b5}\u{5b6}\x07\x3b\
	\x02\x02\u{5b6}\u{5b7}\x07\x0b\x02\x02\u{5b7}\u{5b8}\x05\u{d2}\x6a\x02\u{5b8}\
	\u{5b9}\x07\x0d\x02\x02\u{5b9}\u{5ba}\x05\x4c\x27\x02\u{5ba}\u{af}\x03\x02\
	\x02\x02\u{5bb}\u{5bc}\x07\x3c\x02\x02\u{5bc}\u{5bd}\x07\x0b\x02\x02\u{5bd}\
	\u{5be}\x05\u{bc}\x5f\x02\u{5be}\u{5bf}\x07\x04\x02\x02\u{5bf}\u{5c0}\x05\
	\u{be}\x60\x02\u{5c0}\u{5c1}\x07\x04\x02\x02\u{5c1}\u{5c2}\x05\u{c0}\x61\
	\x02\u{5c2}\u{5c3}\x07\x0d\x02\x02\u{5c3}\u{5c4}\x05\u{ce}\x68\x02\u{5c4}\
	\u{b1}\x03\x02\x02\x02\u{5c5}\u{5c6}\x07\x3c\x02\x02\u{5c6}\u{5c7}\x07\x0b\
	\x02\x02\u{5c7}\u{5c8}\x05\u{bc}\x5f\x02\u{5c8}\u{5c9}\x07\x04\x02\x02\u{5c9}\
	\u{5ca}\x05\u{be}\x60\x02\u{5ca}\u{5cb}\x07\x04\x02\x02\u{5cb}\u{5cc}\x05\
	\u{c0}\x61\x02\u{5cc}\u{5cd}\x07\x0d\x02\x02\u{5cd}\u{5ce}\x05\u{fa}\x7e\
	\x02\u{5ce}\u{b3}\x03\x02\x02\x02\u{5cf}\u{5d0}\x07\x3c\x02\x02\u{5d0}\u{5d1}\
	\x07\x0b\x02\x02\u{5d1}\u{5d2}\x05\u{bc}\x5f\x02\u{5d2}\u{5d3}\x07\x04\x02\
	\x02\u{5d3}\u{5d4}\x05\u{be}\x60\x02\u{5d4}\u{5d5}\x07\x04\x02\x02\u{5d5}\
	\u{5d6}\x05\u{c0}\x61\x02\u{5d6}\u{5d7}\x07\x0d\x02\x02\u{5d7}\u{5d8}\x05\
	\u{fe}\u{80}\x02\u{5d8}\u{b5}\x03\x02\x02\x02\u{5d9}\u{5da}\x07\x3c\x02\
	\x02\u{5da}\u{5db}\x07\x0b\x02\x02\u{5db}\u{5dc}\x05\u{bc}\x5f\x02\u{5dc}\
	\u{5dd}\x07\x04\x02\x02\u{5dd}\u{5de}\x05\u{be}\x60\x02\u{5de}\u{5df}\x07\
	\x04\x02\x02\u{5df}\u{5e0}\x05\u{c0}\x61\x02\u{5e0}\u{5e1}\x07\x0d\x02\x02\
	\u{5e1}\u{5e2}\x05\x3c\x1f\x02\u{5e2}\u{b7}\x03\x02\x02\x02\u{5e3}\u{5e4}\
	\x07\x3c\x02\x02\u{5e4}\u{5e5}\x07\x0b\x02\x02\u{5e5}\u{5e6}\x05\u{bc}\x5f\
	\x02\u{5e6}\u{5e7}\x07\x04\x02\x02\u{5e7}\u{5e8}\x05\u{be}\x60\x02\u{5e8}\
	\u{5e9}\x07\x04\x02\x02\u{5e9}\u{5ea}\x05\u{c0}\x61\x02\u{5ea}\u{5eb}\x07\
	\x0d\x02\x02\u{5eb}\u{5ec}\x05\x4c\x27\x02\u{5ec}\u{b9}\x03\x02\x02\x02\
	\u{5ed}\u{5ef}\x05\x18\x0d\x02\u{5ee}\u{5ed}\x03\x02\x02\x02\u{5ee}\u{5ef}\
	\x03\x02\x02\x02\u{5ef}\u{5f0}\x03\x02\x02\x02\u{5f0}\u{5f1}\x05\x02\x02\
	\x02\u{5f1}\u{5f2}\x07\x20\x02\x02\u{5f2}\u{5f3}\x05\u{d2}\x6a\x02\u{5f3}\
	\u{bb}\x03\x02\x02\x02\u{5f4}\u{5f6}\x05\x18\x0d\x02\u{5f5}\u{5f4}\x03\x02\
	\x02\x02\u{5f5}\u{5f6}\x03\x02\x02\x02\u{5f6}\u{5f7}\x03\x02\x02\x02\u{5f7}\
	\u{5f8}\x05\x02\x02\x02\u{5f8}\u{5f9}\x07\x20\x02\x02\u{5f9}\u{5fe}\x05\
	\u{d2}\x6a\x02\u{5fa}\u{5fb}\x07\x08\x02\x02\u{5fb}\u{5fd}\x05\u{ba}\x5e\
	\x02\u{5fc}\u{5fa}\x03\x02\x02\x02\u{5fd}\u{600}\x03\x02\x02\x02\u{5fe}\
	\u{5fc}\x03\x02\x02\x02\u{5fe}\u{5ff}\x03\x02\x02\x02\u{5ff}\u{bd}\x03\x02\
	\x02\x02\u{600}\u{5fe}\x03\x02\x02\x02\u{601}\u{602}\x05\u{d2}\x6a\x02\u{602}\
	\u{bf}\x03\x02\x02\x02\u{603}\u{608}\x05\u{c2}\x62\x02\u{604}\u{605}\x07\
	\x08\x02\x02\u{605}\u{607}\x05\u{c2}\x62\x02\u{606}\u{604}\x03\x02\x02\x02\
	\u{607}\u{60a}\x03\x02\x02\x02\u{608}\u{606}\x03\x02\x02\x02\u{608}\u{609}\
	\x03\x02\x02\x02\u{609}\u{c1}\x03\x02\x02\x02\u{60a}\u{608}\x03\x02\x02\
	\x02\u{60b}\u{60c}\x05\x02\x02\x02\u{60c}\u{60d}\x07\x20\x02\x02\u{60d}\
	\u{60e}\x05\u{d2}\x6a\x02\u{60e}\u{c3}\x03\x02\x02\x02\u{60f}\u{610}\x05\
	\u{12c}\u{97}\x02\u{610}\u{611}\x05\u{c6}\x64\x02\u{611}\u{612}\x05\u{cc}\
	\x67\x02\u{612}\u{615}\x07\x3d\x02\x02\u{613}\u{614}\x07\x06\x02\x02\u{614}\
	\u{616}\x05\x02\x02\x02\u{615}\u{613}\x03\x02\x02\x02\u{615}\u{616}\x03\
	\x02\x02\x02\u{616}\u{62c}\x03\x02\x02\x02\u{617}\u{619}\x07\x3e\x02\x02\
	\u{618}\u{61a}\x05\x18\x0d\x02\u{619}\u{618}\x03\x02\x02\x02\u{619}\u{61a}\
	\x03\x02\x02\x02\u{61a}\u{61d}\x03\x02\x02\x02\u{61b}\u{61e}\x05\x02\x02\
	\x02\u{61c}\u{61e}\x07\u{95}\x02\x02\u{61d}\u{61b}\x03\x02\x02\x02\u{61d}\
	\u{61c}\x03\x02\x02\x02\u{61e}\u{61f}\x03\x02\x02\x02\u{61f}\u{621}\x07\
	\x0b\x02\x02\u{620}\u{622}\x05\u{c8}\x65\x02\u{621}\u{620}\x03\x02\x02\x02\
	\u{621}\u{622}\x03\x02\x02\x02\u{622}\u{623}\x03\x02\x02\x02\u{623}\u{625}\
	\x07\x0d\x02\x02\u{624}\u{626}\x05\u{132}\u{9a}\x02\u{625}\u{624}\x03\x02\
	\x02\x02\u{625}\u{626}\x03\x02\x02\x02\u{626}\u{627}\x03\x02\x02\x02\u{627}\
	\u{628}\x07\x20\x02\x02\u{628}\u{629}\x05\u{d2}\x6a\x02\u{629}\u{62a}\x07\
	\x04\x02\x02\u{62a}\u{62c}\x03\x02\x02\x02\u{62b}\u{60f}\x03\x02\x02\x02\
	\u{62b}\u{617}\x03\x02\x02\x02\u{62c}\u{c5}\x03\x02\x02\x02\u{62d}\u{62f}\
	\x07\x3e\x02\x02\u{62e}\u{630}\x05\x18\x0d\x02\u{62f}\u{62e}\x03\x02\x02\
	\x02\u{62f}\u{630}\x03\x02\x02\x02\u{630}\u{633}\x03\x02\x02\x02\u{631}\
	\u{634}\x05\x02\x02\x02\u{632}\u{634}\x07\u{95}\x02\x02\u{633}\u{631}\x03\
	\x02\x02\x02\u{633}\u{632}\x03\x02\x02\x02\u{634}\u{63a}\x03\x02\x02\x02\
	\u{635}\u{637}\x07\x0b\x02\x02\u{636}\u{638}\x05\u{c8}\x65\x02\u{637}\u{636}\
	\x03\x02\x02\x02\u{637}\u{638}\x03\x02\x02\x02\u{638}\u{639}\x03\x02\x02\
	\x02\u{639}\u{63b}\x07\x0d\x02\x02\u{63a}\u{635}\x03\x02\x02\x02\u{63a}\
	\u{63b}\x03\x02\x02\x02\u{63b}\u{63d}\x03\x02\x02\x02\u{63c}\u{63e}\x05\
	\u{132}\u{9a}\x02\u{63d}\u{63c}\x03\x02\x02\x02\u{63d}\u{63e}\x03\x02\x02\
	\x02\u{63e}\u{63f}\x03\x02\x02\x02\u{63f}\u{640}\x07\x04\x02\x02\u{640}\
	\u{c7}\x03\x02\x02\x02\u{641}\u{646}\x05\u{ca}\x66\x02\u{642}\u{643}\x07\
	\x08\x02\x02\u{643}\u{645}\x05\u{ca}\x66\x02\u{644}\u{642}\x03\x02\x02\x02\
	\u{645}\u{648}\x03\x02\x02\x02\u{646}\u{644}\x03\x02\x02\x02\u{646}\u{647}\
	\x03\x02\x02\x02\u{647}\u{c9}\x03\x02\x02\x02\u{648}\u{646}\x03\x02\x02\
	\x02\u{649}\u{64b}\x05\x18\x0d\x02\u{64a}\u{649}\x03\x02\x02\x02\u{64a}\
	\u{64b}\x03\x02\x02\x02\u{64b}\u{64c}\x03\x02\x02\x02\u{64c}\u{652}\x05\
	\x02\x02\x02\u{64d}\u{64f}\x07\x0b\x02\x02\u{64e}\u{650}\x05\u{c8}\x65\x02\
	\u{64f}\u{64e}\x03\x02\x02\x02\u{64f}\u{650}\x03\x02\x02\x02\u{650}\u{651}\
	\x03\x02\x02\x02\u{651}\u{653}\x07\x0d\x02\x02\u{652}\u{64d}\x03\x02\x02\
	\x02\u{652}\u{653}\x03\x02\x02\x02\u{653}\u{cb}\x03\x02\x02\x02\u{654}\u{65d}\
	\x05\u{f8}\x7d\x02\u{655}\u{65d}\x05\u{fc}\x7f\x02\u{656}\u{658}\x05\u{ce}\
	\x68\x02\u{657}\u{656}\x03\x02\x02\x02\u{658}\u{65b}\x03\x02\x02\x02\u{659}\
	\u{657}\x03\x02\x02\x02\u{659}\u{65a}\x03\x02\x02\x02\u{65a}\u{65d}\x03\
	\x02\x02\x02\u{65b}\u{659}\x03\x02\x02\x02\u{65c}\u{654}\x03\x02\x02\x02\
	\u{65c}\u{655}\x03\x02\x02\x02\u{65c}\u{659}\x03\x02\x02\x02\u{65d}\u{cd}\
	\x03\x02\x02\x02\u{65e}\u{661}\x05\u{d0}\x69\x02\u{65f}\u{661}\x05\x4c\x27\
	\x02\u{660}\u{65e}\x03\x02\x02\x02\u{660}\u{65f}\x03\x02\x02\x02\u{661}\
	\u{cf}\x03\x02\x02\x02\u{662}\u{663}\x07\x3f\x02\x02\u{663}\u{664}\x05\u{d2}\
	\x6a\x02\u{664}\u{665}\x07\x04\x02\x02\u{665}\u{d1}\x03\x02\x02\x02\u{666}\
	\u{667}\x08\x6a\x01\x02\u{667}\u{668}\x07\x37\x02\x02\u{668}\u{669}\x07\
	\x0b\x02\x02\u{669}\u{66a}\x05\u{d2}\x6a\x02\u{66a}\u{677}\x07\x0d\x02\x02\
	\u{66b}\u{66d}\x07\x39\x02\x02\u{66c}\u{66e}\x05\u{d4}\x6b\x02\u{66d}\u{66c}\
	\x03\x02\x02\x02\u{66e}\u{66f}\x03\x02\x02\x02\u{66f}\u{66d}\x03\x02\x02\
	\x02\u{66f}\u{670}\x03\x02\x02\x02\u{670}\u{678}\x03\x02\x02\x02\u{671}\
	\u{673}\x05\u{d6}\x6c\x02\u{672}\u{671}\x03\x02\x02\x02\u{673}\u{676}\x03\
	\x02\x02\x02\u{674}\u{672}\x03\x02\x02\x02\u{674}\u{675}\x03\x02\x02\x02\
	\u{675}\u{678}\x03\x02\x02\x02\u{676}\u{674}\x03\x02\x02\x02\u{677}\u{66b}\
	\x03\x02\x02\x02\u{677}\u{674}\x03\x02\x02\x02\u{678}\u{67a}\x03\x02\x02\
	\x02\u{679}\u{67b}\x05\u{d8}\x6d\x02\u{67a}\u{679}\x03\x02\x02\x02\u{67a}\
	\u{67b}\x03\x02\x02\x02\u{67b}\u{67c}\x03\x02\x02\x02\u{67c}\u{67d}\x07\
	\x38\x02\x02\u{67d}\u{680}\x03\x02\x02\x02\u{67e}\u{680}\x05\u{e0}\x71\x02\
	\u{67f}\u{666}\x03\x02\x02\x02\u{67f}\u{67e}\x03\x02\x02\x02\u{680}\u{692}\
	\x03\x02\x02\x02\u{681}\u{682}\x0c\x06\x02\x02\u{682}\u{683}\x07\x40\x02\
	\x02\u{683}\u{684}\x05\u{d2}\x6a\x02\u{684}\u{685}\x07\x06\x02\x02\u{685}\
	\u{686}\x05\u{d2}\x6a\x07\u{686}\u{691}\x03\x02\x02\x02\u{687}\u{688}\x0c\
	\x05\x02\x02\u{688}\u{689}\x07\x39\x02\x02\u{689}\u{68d}\x05\u{112}\u{8a}\
	\x02\u{68a}\u{68c}\x05\u{da}\x6e\x02\u{68b}\u{68a}\x03\x02\x02\x02\u{68c}\
	\u{68f}\x03\x02\x02\x02\u{68d}\u{68b}\x03\x02\x02\x02\u{68d}\u{68e}\x03\
	\x02\x02\x02\u{68e}\u{691}\x03\x02\x02\x02\u{68f}\u{68d}\x03\x02\x02\x02\
	\u{690}\u{681}\x03\x02\x02\x02\u{690}\u{687}\x03\x02\x02\x02\u{691}\u{694}\
	\x03\x02\x02\x02\u{692}\u{690}\x03\x02\x02\x02\u{692}\u{693}\x03\x02\x02\
	\x02\u{693}\u{d3}\x03\x02\x02\x02\u{694}\u{692}\x03\x02\x02\x02\u{695}\u{699}\
	\x05\u{112}\u{8a}\x02\u{696}\u{698}\x05\u{da}\x6e\x02\u{697}\u{696}\x03\
	\x02\x02\x02\u{698}\u{69b}\x03\x02\x02\x02\u{699}\u{697}\x03\x02\x02\x02\
	\u{699}\u{69a}\x03\x02\x02\x02\u{69a}\u{69c}\x03\x02\x02\x02\u{69b}\u{699}\
	\x03\x02\x02\x02\u{69c}\u{69d}\x07\x06\x02\x02\u{69d}\u{69e}\x05\u{d2}\x6a\
	\x02\u{69e}\u{69f}\x07\x04\x02\x02\u{69f}\u{d5}\x03\x02\x02\x02\u{6a0}\u{6a5}\
	\x05\u{d2}\x6a\x02\u{6a1}\u{6a2}\x07\x08\x02\x02\u{6a2}\u{6a4}\x05\u{d2}\
	\x6a\x02\u{6a3}\u{6a1}\x03\x02\x02\x02\u{6a4}\u{6a7}\x03\x02\x02\x02\u{6a5}\
	\u{6a3}\x03\x02\x02\x02\u{6a5}\u{6a6}\x03\x02\x02\x02\u{6a6}\u{6a8}\x03\
	\x02\x02\x02\u{6a7}\u{6a5}\x03\x02\x02\x02\u{6a8}\u{6a9}\x07\x06\x02\x02\
	\u{6a9}\u{6aa}\x05\u{d2}\x6a\x02\u{6aa}\u{6ab}\x07\x04\x02\x02\u{6ab}\u{d7}\
	\x03\x02\x02\x02\u{6ac}\u{6ad}\x07\x3a\x02\x02\u{6ad}\u{6ae}\x07\x06\x02\
	\x02\u{6ae}\u{6af}\x05\u{d2}\x6a\x02\u{6af}\u{6b0}\x07\x04\x02\x02\u{6b0}\
	\u{d9}\x03\x02\x02\x02\u{6b1}\u{6b2}\x07\x41\x02\x02\u{6b2}\u{6b3}\x05\u{d2}\
	\x6a\x02\u{6b3}\u{db}\x03\x02\x02\x02\u{6b4}\u{6b5}\x09\x02\x02\x02\u{6b5}\
	\u{dd}\x03\x02\x02\x02\u{6b6}\u{6b7}\x09\x03\x02\x02\u{6b7}\u{df}\x03\x02\
	\x02\x02\u{6b8}\u{6b9}\x08\x71\x01\x02\u{6b9}\u{6ba}\x05\u{e2}\x72\x02\u{6ba}\
	\u{6c1}\x03\x02\x02\x02\u{6bb}\u{6bc}\x0c\x04\x02\x02\u{6bc}\u{6bd}\x05\
	\u{de}\x70\x02\u{6bd}\u{6be}\x05\u{e0}\x71\x05\u{6be}\u{6c0}\x03\x02\x02\
	\x02\u{6bf}\u{6bb}\x03\x02\x02\x02\u{6c0}\u{6c3}\x03\x02\x02\x02\u{6c1}\
	\u{6bf}\x03\x02\x02\x02\u{6c1}\u{6c2}\x03\x02\x02\x02\u{6c2}\u{e1}\x03\x02\
	\x02\x02\u{6c3}\u{6c1}\x03\x02\x02\x02\u{6c4}\u{6c5}\x09\x04\x02\x02\u{6c5}\
	\u{6ca}\x05\u{ea}\x76\x02\u{6c6}\u{6c7}\x09\x05\x02\x02\u{6c7}\u{6ca}\x05\
	\u{ea}\x76\x02\u{6c8}\u{6ca}\x05\u{ea}\x76\x02\u{6c9}\u{6c4}\x03\x02\x02\
	\x02\u{6c9}\u{6c6}\x03\x02\x02\x02\u{6c9}\u{6c8}\x03\x02\x02\x02\u{6ca}\
	\u{e3}\x03\x02\x02\x02\u{6cb}\u{6cd}\x08\x73\x01\x02\u{6cc}\u{6ce}\x05\u{dc}\
	\x6f\x02\u{6cd}\u{6cc}\x03\x02\x02\x02\u{6cd}\u{6ce}\x03\x02\x02\x02\u{6ce}\
	\u{6cf}\x03\x02\x02\x02\u{6cf}\u{6d0}\x05\u{e6}\x74\x02\u{6d0}\u{6dd}\x03\
	\x02\x02\x02\u{6d1}\u{6d2}\x0c\x04\x02\x02\u{6d2}\u{6d3}\x05\u{de}\x70\x02\
	\u{6d3}\u{6d4}\x05\u{e4}\x73\x05\u{6d4}\u{6dc}\x03\x02\x02\x02\u{6d5}\u{6d6}\
	\x0c\x03\x02\x02\u{6d6}\u{6d7}\x07\x40\x02\x02\u{6d7}\u{6d8}\x05\u{e4}\x73\
	\x02\u{6d8}\u{6d9}\x07\x06\x02\x02\u{6d9}\u{6da}\x05\u{e4}\x73\x04\u{6da}\
	\u{6dc}\x03\x02\x02\x02\u{6db}\u{6d1}\x03\x02\x02\x02\u{6db}\u{6d5}\x03\
	\x02\x02\x02\u{6dc}\u{6df}\x03\x02\x02\x02\u{6dd}\u{6db}\x03\x02\x02\x02\
	\u{6dd}\u{6de}\x03\x02\x02\x02\u{6de}\u{e5}\x03\x02\x02\x02\u{6df}\u{6dd}\
	\x03\x02\x02\x02\u{6e0}\u{6ea}\x07\u{98}\x02\x02\u{6e1}\u{6ea}\x07\u{9a}\
	\x02\x02\u{6e2}\u{6ea}\x07\u{97}\x02\x02\u{6e3}\u{6ea}\x07\x40\x02\x02\u{6e4}\
	\u{6e5}\x09\x06\x02\x02\u{6e5}\u{6e6}\x07\x0b\x02\x02\u{6e6}\u{6e7}\x05\
	\x18\x0d\x02\u{6e7}\u{6e8}\x07\x0d\x02\x02\u{6e8}\u{6ea}\x03\x02\x02\x02\
	\u{6e9}\u{6e0}\x03\x02\x02\x02\u{6e9}\u{6e1}\x03\x02\x02\x02\u{6e9}\u{6e2}\
	\x03\x02\x02\x02\u{6e9}\u{6e3}\x03\x02\x02\x02\u{6e9}\u{6e4}\x03\x02\x02\
	\x02\u{6ea}\u{e7}\x03\x02\x02\x02\u{6eb}\u{6ec}\x07\x26\x02\x02\u{6ec}\u{6f1}\
	\x05\u{d2}\x6a\x02\u{6ed}\u{6ee}\x07\x08\x02\x02\u{6ee}\u{6f0}\x05\u{d2}\
	\x6a\x02\u{6ef}\u{6ed}\x03\x02\x02\x02\u{6f0}\u{6f3}\x03\x02\x02\x02\u{6f1}\
	\u{6ef}\x03\x02\x02\x02\u{6f1}\u{6f2}\x03\x02\x02\x02\u{6f2}\u{6f4}\x03\
	\x02\x02\x02\u{6f3}\u{6f1}\x03\x02\x02\x02\u{6f4}\u{6f5}\x07\x27\x02\x02\
	\u{6f5}\u{e9}\x03\x02\x02\x02\u{6f6}\u{6f7}\x08\x76\x01\x02\u{6f7}\u{6f8}\
	\x07\x0b\x02\x02\u{6f8}\u{6f9}\x05\u{d2}\x6a\x02\u{6f9}\u{6fa}\x07\x0d\x02\
	\x02\u{6fa}\u{767}\x03\x02\x02\x02\u{6fb}\u{701}\x05\x18\x0d\x02\u{6fc}\
	\u{6fd}\x07\x0b\x02\x02\u{6fd}\u{6fe}\x05\x18\x0d\x02\u{6fe}\u{6ff}\x07\
	\x0d\x02\x02\u{6ff}\u{701}\x03\x02\x02\x02\u{700}\u{6fb}\x03\x02\x02\x02\
	\u{700}\u{6fc}\x03\x02\x02\x02\u{701}\u{702}\x03\x02\x02\x02\u{702}\u{703}\
	\x07\x5c\x02\x02\u{703}\u{704}\x05\u{ea}\x76\x10\u{704}\u{767}\x03\x02\x02\
	\x02\u{705}\u{706}\x07\u{93}\x02\x02\u{706}\u{708}\x07\x09\x02\x02\u{707}\
	\u{705}\x03\x02\x02\x02\u{708}\u{70b}\x03\x02\x02\x02\u{709}\u{707}\x03\
	\x02\x02\x02\u{709}\u{70a}\x03\x02\x02\x02\u{70a}\u{70c}\x03\x02\x02\x02\
	\u{70b}\u{709}\x03\x02\x02\x02\u{70c}\u{767}\x05\x02\x02\x02\u{70d}\u{767}\
	\x05\u{e4}\x73\x02\u{70e}\u{767}\x05\u{e8}\x75\x02\u{70f}\u{710}\x07\x5d\
	\x02\x02\u{710}\u{719}\x07\x0b\x02\x02\u{711}\u{716}\x05\u{d2}\x6a\x02\u{712}\
	\u{713}\x07\x08\x02\x02\u{713}\u{715}\x05\u{d2}\x6a\x02\u{714}\u{712}\x03\
	\x02\x02\x02\u{715}\u{718}\x03\x02\x02\x02\u{716}\u{714}\x03\x02\x02\x02\
	\u{716}\u{717}\x03\x02\x02\x02\u{717}\u{71a}\x03\x02\x02\x02\u{718}\u{716}\
	\x03\x02\x02\x02\u{719}\u{711}\x03\x02\x02\x02\u{719}\u{71a}\x03\x02\x02\
	\x02\u{71a}\u{71b}\x03\x02\x02\x02\u{71b}\u{767}\x07\x0d\x02\x02\u{71c}\
	\u{729}\x07\u{96}\x02\x02\u{71d}\u{726}\x07\x0b\x02\x02\u{71e}\u{723}\x05\
	\u{d2}\x6a\x02\u{71f}\u{720}\x07\x08\x02\x02\u{720}\u{722}\x05\u{d2}\x6a\
	\x02\u{721}\u{71f}\x03\x02\x02\x02\u{722}\u{725}\x03\x02\x02\x02\u{723}\
	\u{721}\x03\x02\x02\x02\u{723}\u{724}\x03\x02\x02\x02\u{724}\u{727}\x03\
	\x02\x02\x02\u{725}\u{723}\x03\x02\x02\x02\u{726}\u{71e}\x03\x02\x02\x02\
	\u{726}\u{727}\x03\x02\x02\x02\u{727}\u{728}\x03\x02\x02\x02\u{728}\u{72a}\
	\x07\x0d\x02\x02\u{729}\u{71d}\x03\x02\x02\x02\u{729}\u{72a}\x03\x02\x02\
	\x02\u{72a}\u{767}\x03\x02\x02\x02\u{72b}\u{72c}\x07\x5e\x02\x02\u{72c}\
	\u{767}\x05\u{ea}\x76\x08\u{72d}\u{72e}\x07\x5f\x02\x02\u{72e}\u{767}\x05\
	\u{ea}\x76\x07\u{72f}\u{730}\x05\x18\x0d\x02\u{730}\u{740}\x07\x60\x02\x02\
	\u{731}\u{732}\x07\x26\x02\x02\u{732}\u{737}\x05\u{d2}\x6a\x02\u{733}\u{734}\
	\x07\x08\x02\x02\u{734}\u{736}\x05\u{d2}\x6a\x02\u{735}\u{733}\x03\x02\x02\
	\x02\u{736}\u{739}\x03\x02\x02\x02\u{737}\u{735}\x03\x02\x02\x02\u{737}\
	\u{738}\x03\x02\x02\x02\u{738}\u{73a}\x03\x02\x02\x02\u{739}\u{737}\x03\
	\x02\x02\x02\u{73a}\u{73b}\x07\x27\x02\x02\u{73b}\u{741}\x03\x02\x02\x02\
	\u{73c}\u{73d}\x07\x0b\x02\x02\u{73d}\u{73e}\x05\u{d2}\x6a\x02\u{73e}\u{73f}\
	\x07\x0d\x02\x02\u{73f}\u{741}\x03\x02\x02\x02\u{740}\u{731}\x03\x02\x02\
	\x02\u{740}\u{73c}\x03\x02\x02\x02\u{741}\u{767}\x03\x02\x02\x02\u{742}\
	\u{744}\x07\x2a\x02\x02\u{743}\u{742}\x03\x02\x02\x02\u{743}\u{744}\x03\
	\x02\x02\x02\u{744}\u{749}\x03\x02\x02\x02\u{745}\u{746}\x07\u{93}\x02\x02\
	\u{746}\u{748}\x07\x09\x02\x02\u{747}\u{745}\x03\x02\x02\x02\u{748}\u{74b}\
	\x03\x02\x02\x02\u{749}\u{747}\x03\x02\x02\x02\u{749}\u{74a}\x03\x02\x02\
	\x02\u{74a}\u{74c}\x03\x02\x02\x02\u{74b}\u{749}\x03\x02\x02\x02\u{74c}\
	\u{753}\x07\u{93}\x02\x02\u{74d}\u{74e}\x07\x26\x02\x02\u{74e}\u{74f}\x05\
	\u{ec}\x77\x02\u{74f}\u{750}\x07\x27\x02\x02\u{750}\u{754}\x03\x02\x02\x02\
	\u{751}\u{754}\x05\u{ea}\x76\x02\u{752}\u{754}\x03\x02\x02\x02\u{753}\u{74d}\
	\x03\x02\x02\x02\u{753}\u{751}\x03\x02\x02\x02\u{753}\u{752}\x03\x02\x02\
	\x02\u{754}\u{767}\x03\x02\x02\x02\u{755}\u{756}\x07\x14\x02\x02\u{756}\
	\u{758}\x05\x18\x0d\x02\u{757}\u{759}\x07\x04\x02\x02\u{758}\u{757}\x03\
	\x02\x02\x02\u{758}\u{759}\x03\x02\x02\x02\u{759}\u{75d}\x03\x02\x02\x02\
	\u{75a}\u{75c}\x05\u{f0}\x79\x02\u{75b}\u{75a}\x03\x02\x02\x02\u{75c}\u{75f}\
	\x03\x02\x02\x02\u{75d}\u{75b}\x03\x02\x02\x02\u{75d}\u{75e}\x03\x02\x02\
	\x02\u{75e}\u{760}\x03\x02\x02\x02\u{75f}\u{75d}\x03\x02\x02\x02\u{760}\
	\u{763}\x07\x15\x02\x02\u{761}\u{762}\x07\x06\x02\x02\u{762}\u{764}\x05\
	\x1e\x10\x02\u{763}\u{761}\x03\x02\x02\x02\u{763}\u{764}\x03\x02\x02\x02\
	\u{764}\u{767}\x03\x02\x02\x02\u{765}\u{767}\x05\u{f6}\x7c\x02\u{766}\u{6f6}\
	\x03\x02\x02\x02\u{766}\u{700}\x03\x02\x02\x02\u{766}\u{709}\x03\x02\x02\
	\x02\u{766}\u{70d}\x03\x02\x02\x02\u{766}\u{70e}\x03\x02\x02\x02\u{766}\
	\u{70f}\x03\x02\x02\x02\u{766}\u{71c}\x03\x02\x02\x02\u{766}\u{72b}\x03\
	\x02\x02\x02\u{766}\u{72d}\x03\x02\x02\x02\u{766}\u{72f}\x03\x02\x02\x02\
	\u{766}\u{743}\x03\x02\x02\x02\u{766}\u{755}\x03\x02\x02\x02\u{766}\u{765}\
	\x03\x02\x02\x02\u{767}\u{783}\x03\x02\x02\x02\u{768}\u{769}\x0c\x11\x02\
	\x02\u{769}\u{76a}\x07\x30\x02\x02\u{76a}\u{782}\x05\x04\x03\x02\u{76b}\
	\u{76c}\x0c\x0c\x02\x02\u{76c}\u{76d}\x07\x11\x02\x02\u{76d}\u{770}\x05\
	\u{e4}\x73\x02\u{76e}\u{76f}\x07\x06\x02\x02\u{76f}\u{771}\x05\u{e4}\x73\
	\x02\u{770}\u{76e}\x03\x02\x02\x02\u{770}\u{771}\x03\x02\x02\x02\u{771}\
	\u{772}\x03\x02\x02\x02\u{772}\u{773}\x07\x12\x02\x02\u{773}\u{782}\x03\
	\x02\x02\x02\u{774}\u{775}\x0c\x0b\x02\x02\u{775}\u{77e}\x07\x0b\x02\x02\
	\u{776}\u{77b}\x05\u{d2}\x6a\x02\u{777}\u{778}\x07\x08\x02\x02\u{778}\u{77a}\
	\x05\u{d2}\x6a\x02\u{779}\u{777}\x03\x02\x02\x02\u{77a}\u{77d}\x03\x02\x02\
	\x02\u{77b}\u{779}\x03\x02\x02\x02\u{77b}\u{77c}\x03\x02\x02\x02\u{77c}\
	\u{77f}\x03\x02\x02\x02\u{77d}\u{77b}\x03\x02\x02\x02\u{77e}\u{776}\x03\
	\x02\x02\x02\u{77e}\u{77f}\x03\x02\x02\x02\u{77f}\u{780}\x03\x02\x02\x02\
	\u{780}\u{782}\x07\x0d\x02\x02\u{781}\u{768}\x03\x02\x02\x02\u{781}\u{76b}\
	\x03\x02\x02\x02\u{781}\u{774}\x03\x02\x02\x02\u{782}\u{785}\x03\x02\x02\
	\x02\u{783}\u{781}\x03\x02\x02\x02\u{783}\u{784}\x03\x02\x02\x02\u{784}\
	\u{eb}\x03\x02\x02\x02\u{785}\u{783}\x03\x02\x02\x02\u{786}\u{78b}\x05\u{ee}\
	\x78\x02\u{787}\u{788}\x07\x08\x02\x02\u{788}\u{78a}\x05\u{ee}\x78\x02\u{789}\
	\u{787}\x03\x02\x02\x02\u{78a}\u{78d}\x03\x02\x02\x02\u{78b}\u{789}\x03\
	\x02\x02\x02\u{78b}\u{78c}\x03\x02\x02\x02\u{78c}\u{ed}\x03\x02\x02\x02\
	\u{78d}\u{78b}\x03\x02\x02\x02\u{78e}\u{78f}\x05\x02\x02\x02\u{78f}\u{790}\
	\x07\x06\x02\x02\u{790}\u{791}\x05\u{d2}\x6a\x02\u{791}\u{ef}\x03\x02\x02\
	\x02\u{792}\u{797}\x05\x40\x21\x02\u{793}\u{797}\x05\x48\x25\x02\u{794}\
	\u{797}\x05\x6a\x36\x02\u{795}\u{797}\x05\x70\x39\x02\u{796}\u{792}\x03\
	\x02\x02\x02\u{796}\u{793}\x03\x02\x02\x02\u{796}\u{794}\x03\x02\x02\x02\
	\u{796}\u{795}\x03\x02\x02\x02\u{797}\u{f1}\x03\x02\x02\x02\u{798}\u{79e}\
	\x05\u{d2}\x6a\x02\u{799}\u{79a}\x05\u{d2}\x6a\x02\u{79a}\u{79b}\x07\x39\
	\x02\x02\u{79b}\u{79c}\x05\u{112}\u{8a}\x02\u{79c}\u{79e}\x03\x02\x02\x02\
	\u{79d}\u{798}\x03\x02\x02\x02\u{79d}\u{799}\x03\x02\x02\x02\u{79e}\u{7a9}\
	\x03\x02\x02\x02\u{79f}\u{7a5}\x07\x41\x02\x02\u{7a0}\u{7a6}\x05\u{d2}\x6a\
	\x02\u{7a1}\u{7a2}\x05\u{d2}\x6a\x02\u{7a2}\u{7a3}\x07\x39\x02\x02\u{7a3}\
	\u{7a4}\x05\u{112}\u{8a}\x02\u{7a4}\u{7a6}\x03\x02\x02\x02\u{7a5}\u{7a0}\
	\x03\x02\x02\x02\u{7a5}\u{7a1}\x03\x02\x02\x02\u{7a6}\u{7a8}\x03\x02\x02\
	\x02\u{7a7}\u{79f}\x03\x02\x02\x02\u{7a8}\u{7ab}\x03\x02\x02\x02\u{7a9}\
	\u{7a7}\x03\x02\x02\x02\u{7a9}\u{7aa}\x03\x02\x02\x02\u{7aa}\u{f3}\x03\x02\
	\x02\x02\u{7ab}\u{7a9}\x03\x02\x02\x02\u{7ac}\u{7b2}\x05\u{d2}\x6a\x02\u{7ad}\
	\u{7ae}\x05\u{d2}\x6a\x02\u{7ae}\u{7af}\x07\x39\x02\x02\u{7af}\u{7b0}\x05\
	\u{112}\u{8a}\x02\u{7b0}\u{7b2}\x03\x02\x02\x02\u{7b1}\u{7ac}\x03\x02\x02\
	\x02\u{7b1}\u{7ad}\x03\x02\x02\x02\u{7b2}\u{f5}\x03\x02\x02\x02\u{7b3}\u{7b6}\
	\x07\x34\x02\x02\u{7b4}\u{7b5}\x07\x06\x02\x02\u{7b5}\u{7b7}\x05\x02\x02\
	\x02\u{7b6}\u{7b4}\x03\x02\x02\x02\u{7b6}\u{7b7}\x03\x02\x02\x02\u{7b7}\
	\u{7bb}\x03\x02\x02\x02\u{7b8}\u{7ba}\x05\x4c\x27\x02\u{7b9}\u{7b8}\x03\
	\x02\x02\x02\u{7ba}\u{7bd}\x03\x02\x02\x02\u{7bb}\u{7b9}\x03\x02\x02\x02\
	\u{7bb}\u{7bc}\x03\x02\x02\x02\u{7bc}\u{7be}\x03\x02\x02\x02\u{7bd}\u{7bb}\
	\x03\x02\x02\x02\u{7be}\u{7bf}\x05\u{d2}\x6a\x02\u{7bf}\u{7c2}\x07\x35\x02\
	\x02\u{7c0}\u{7c1}\x07\x06\x02\x02\u{7c1}\u{7c3}\x05\x02\x02\x02\u{7c2}\
	\u{7c0}\x03\x02\x02\x02\u{7c2}\u{7c3}\x03\x02\x02\x02\u{7c3}\u{f7}\x03\x02\
	\x02\x02\u{7c4}\u{7c8}\x07\x61\x02\x02\u{7c5}\u{7c7}\x05\u{fa}\x7e\x02\u{7c6}\
	\u{7c5}\x03\x02\x02\x02\u{7c7}\u{7ca}\x03\x02\x02\x02\u{7c8}\u{7c6}\x03\
	\x02\x02\x02\u{7c8}\u{7c9}\x03\x02\x02\x02\u{7c9}\u{7cb}\x03\x02\x02\x02\
	\u{7ca}\u{7c8}\x03\x02\x02\x02\u{7cb}\u{7cc}\x07\x62\x02\x02\u{7cc}\u{f9}\
	\x03\x02\x02\x02\u{7cd}\u{7de}\x05\x74\x3b\x02\u{7ce}\u{7de}\x05\u{102}\
	\u{82}\x02\u{7cf}\u{7de}\x05\u{100}\u{81}\x02\u{7d0}\u{7d1}\x05\u{d2}\x6a\
	\x02\u{7d1}\u{7d2}\x07\x04\x02\x02\u{7d2}\u{7de}\x03\x02\x02\x02\u{7d3}\
	\u{7de}\x05\u{f8}\x7d\x02\u{7d4}\u{7de}\x05\x4c\x27\x02\u{7d5}\u{7de}\x05\
	\u{c4}\x63\x02\u{7d6}\u{7de}\x05\x32\x1a\x02\u{7d7}\u{7de}\x05\x6a\x36\x02\
	\u{7d8}\u{7de}\x05\x78\x3d\x02\u{7d9}\u{7de}\x05\u{82}\x42\x02\u{7da}\u{7de}\
	\x05\u{8a}\x46\x02\u{7db}\u{7de}\x05\u{b2}\x5a\x02\u{7dc}\u{7de}\x05\u{a8}\
	\x55\x02\u{7dd}\u{7cd}\x03\x02\x02\x02\u{7dd}\u{7ce}\x03\x02\x02\x02\u{7dd}\
	\u{7cf}\x03\x02\x02\x02\u{7dd}\u{7d0}\x03\x02\x02\x02\u{7dd}\u{7d3}\x03\
	\x02\x02\x02\u{7dd}\u{7d4}\x03\x02\x02\x02\u{7dd}\u{7d5}\x03\x02\x02\x02\
	\u{7dd}\u{7d6}\x03\x02\x02\x02\u{7dd}\u{7d7}\x03\x02\x02\x02\u{7dd}\u{7d8}\
	\x03\x02\x02\x02\u{7dd}\u{7d9}\x03\x02\x02\x02\u{7dd}\u{7da}\x03\x02\x02\
	\x02\u{7dd}\u{7db}\x03\x02\x02\x02\u{7dd}\u{7dc}\x03\x02\x02\x02\u{7de}\
	\u{fb}\x03\x02\x02\x02\u{7df}\u{7e3}\x07\x63\x02\x02\u{7e0}\u{7e2}\x05\u{fe}\
	\u{80}\x02\u{7e1}\u{7e0}\x03\x02\x02\x02\u{7e2}\u{7e5}\x03\x02\x02\x02\u{7e3}\
	\u{7e1}\x03\x02\x02\x02\u{7e3}\u{7e4}\x03\x02\x02\x02\u{7e4}\u{7e6}\x03\
	\x02\x02\x02\u{7e5}\u{7e3}\x03\x02\x02\x02\u{7e6}\u{7e7}\x07\x64\x02\x02\
	\u{7e7}\u{fd}\x03\x02\x02\x02\u{7e8}\u{7fb}\x05\x74\x3b\x02\u{7e9}\u{7fb}\
	\x05\u{102}\u{82}\x02\u{7ea}\u{7fb}\x05\u{100}\u{81}\x02\u{7eb}\u{7fb}\x05\
	\u{fc}\x7f\x02\u{7ec}\u{7ee}\x05\u{d2}\x6a\x02\u{7ed}\u{7ec}\x03\x02\x02\
	\x02\u{7ed}\u{7ee}\x03\x02\x02\x02\u{7ee}\u{7ef}\x03\x02\x02\x02\u{7ef}\
	\u{7fb}\x07\x04\x02\x02\u{7f0}\u{7fb}\x05\u{d0}\x69\x02\u{7f1}\u{7fb}\x05\
	\x6a\x36\x02\u{7f2}\u{7fb}\x05\x70\x39\x02\u{7f3}\u{7fb}\x05\u{c4}\x63\x02\
	\u{7f4}\u{7fb}\x05\x32\x1a\x02\u{7f5}\u{7fb}\x05\x7a\x3e\x02\u{7f6}\u{7fb}\
	\x05\u{84}\x43\x02\u{7f7}\u{7fb}\x05\u{8c}\x47\x02\u{7f8}\u{7fb}\x05\u{b4}\
	\x5b\x02\u{7f9}\u{7fb}\x05\u{aa}\x56\x02\u{7fa}\u{7e8}\x03\x02\x02\x02\u{7fa}\
	\u{7e9}\x03\x02\x02\x02\u{7fa}\u{7ea}\x03\x02\x02\x02\u{7fa}\u{7eb}\x03\
	\x02\x02\x02\u{7fa}\u{7ed}\x03\x02\x02\x02\u{7fa}\u{7f0}\x03\x02\x02\x02\
	\u{7fa}\u{7f1}\x03\x02\x02\x02\u{7fa}\u{7f2}\x03\x02\x02\x02\u{7fa}\u{7f3}\
	\x03\x02\x02\x02\u{7fa}\u{7f4}\x03\x02\x02\x02\u{7fa}\u{7f5}\x03\x02\x02\
	\x02\u{7fa}\u{7f6}\x03\x02\x02\x02\u{7fa}\u{7f7}\x03\x02\x02\x02\u{7fa}\
	\u{7f8}\x03\x02\x02\x02\u{7fa}\u{7f9}\x03\x02\x02\x02\u{7fb}\u{ff}\x03\x02\
	\x02\x02\u{7fc}\u{7fd}\x05\u{12c}\u{97}\x02\u{7fd}\u{7fe}\x05\x18\x0d\x02\
	\u{7fe}\u{7ff}\x05\x02\x02\x02\u{7ff}\u{800}\x07\x2f\x02\x02\u{800}\u{801}\
	\x05\u{d2}\x6a\x02\u{801}\u{802}\x07\x04\x02\x02\u{802}\u{101}\x03\x02\x02\
	\x02\u{803}\u{804}\x05\u{12c}\u{97}\x02\u{804}\u{805}\x05\x02\x02\x02\u{805}\
	\u{806}\x07\x2f\x02\x02\u{806}\u{807}\x05\u{d2}\x6a\x02\u{807}\u{808}\x07\
	\x04\x02\x02\u{808}\u{103}\x03\x02\x02\x02\u{809}\u{80a}\x05\x18\x0d\x02\
	\u{80a}\u{80b}\x07\x5c\x02\x02\u{80b}\u{80c}\x05\u{e8}\x75\x02\u{80c}\u{814}\
	\x03\x02\x02\x02\u{80d}\u{80e}\x05\x18\x0d\x02\u{80e}\u{80f}\x07\x5c\x02\
	\x02\u{80f}\u{810}\x07\x0b\x02\x02\u{810}\u{811}\x05\u{d2}\x6a\x02\u{811}\
	\u{812}\x07\x0d\x02\x02\u{812}\u{814}\x03\x02\x02\x02\u{813}\u{809}\x03\
	\x02\x02\x02\u{813}\u{80d}\x03\x02\x02\x02\u{814}\u{105}\x03\x02\x02\x02\
	\u{815}\u{816}\x07\u{93}\x02\x02\u{816}\u{81f}\x07\x26\x02\x02\u{817}\u{81c}\
	\x05\u{108}\u{85}\x02\u{818}\u{819}\x07\x08\x02\x02\u{819}\u{81b}\x05\u{108}\
	\u{85}\x02\u{81a}\u{818}\x03\x02\x02\x02\u{81b}\u{81e}\x03\x02\x02\x02\u{81c}\
	\u{81a}\x03\x02\x02\x02\u{81c}\u{81d}\x03\x02\x02\x02\u{81d}\u{820}\x03\
	\x02\x02\x02\u{81e}\u{81c}\x03\x02\x02\x02\u{81f}\u{817}\x03\x02\x02\x02\
	\u{81f}\u{820}\x03\x02\x02\x02\u{820}\u{821}\x03\x02\x02\x02\u{821}\u{822}\
	\x07\x27\x02\x02\u{822}\u{107}\x03\x02\x02\x02\u{823}\u{824}\x05\x02\x02\
	\x02\u{824}\u{825}\x07\x06\x02\x02\u{825}\u{826}\x05\u{d2}\x6a\x02\u{826}\
	\u{109}\x03\x02\x02\x02\u{827}\u{828}\x07\x2a\x02\x02\u{828}\u{829}\x07\
	\u{93}\x02\x02\u{829}\u{82a}\x07\x26\x02\x02\u{82a}\u{82b}\x05\u{108}\u{85}\
	\x02\u{82b}\u{82c}\x07\x08\x02\x02\u{82c}\u{82d}\x05\u{108}\u{85}\x02\u{82d}\
	\u{82e}\x03\x02\x02\x02\u{82e}\u{82f}\x07\x27\x02\x02\u{82f}\u{834}\x03\
	\x02\x02\x02\u{830}\u{831}\x07\x2a\x02\x02\u{831}\u{832}\x07\u{93}\x02\x02\
	\u{832}\u{834}\x05\u{ea}\x76\x02\u{833}\u{827}\x03\x02\x02\x02\u{833}\u{830}\
	\x03\x02\x02\x02\u{834}\u{10b}\x03\x02\x02\x02\u{835}\u{836}\x07\x14\x02\
	\x02\u{836}\u{838}\x05\x18\x0d\x02\u{837}\u{839}\x07\x04\x02\x02\u{838}\
	\u{837}\x03\x02\x02\x02\u{838}\u{839}\x03\x02\x02\x02\u{839}\u{83d}\x03\
	\x02\x02\x02\u{83a}\u{83c}\x05\x4a\x26\x02\u{83b}\u{83a}\x03\x02\x02\x02\
	\u{83c}\u{83f}\x03\x02\x02\x02\u{83d}\u{83b}\x03\x02\x02\x02\u{83d}\u{83e}\
	\x03\x02\x02\x02\u{83e}\u{840}\x03\x02\x02\x02\u{83f}\u{83d}\x03\x02\x02\
	\x02\u{840}\u{843}\x07\x15\x02\x02\u{841}\u{842}\x07\x06\x02\x02\u{842}\
	\u{844}\x07\u{93}\x02\x02\u{843}\u{841}\x03\x02\x02\x02\u{843}\u{844}\x03\
	\x02\x02\x02\u{844}\u{10d}\x03\x02\x02\x02\u{845}\u{846}\x05\u{12c}\u{97}\
	\x02\u{846}\u{849}\x07\x65\x02\x02\u{847}\u{848}\x07\x06\x02\x02\u{848}\
	\u{84a}\x05\x02\x02\x02\u{849}\u{847}\x03\x02\x02\x02\u{849}\u{84a}\x03\
	\x02\x02\x02\u{84a}\u{84e}\x03\x02\x02\x02\u{84b}\u{84d}\x05\u{110}\u{89}\
	\x02\u{84c}\u{84b}\x03\x02\x02\x02\u{84d}\u{850}\x03\x02\x02\x02\u{84e}\
	\u{84c}\x03\x02\x02\x02\u{84e}\u{84f}\x03\x02\x02\x02\u{84f}\u{851}\x03\
	\x02\x02\x02\u{850}\u{84e}\x03\x02\x02\x02\u{851}\u{854}\x07\x66\x02\x02\
	\u{852}\u{853}\x07\x06\x02\x02\u{853}\u{855}\x05\x02\x02\x02\u{854}\u{852}\
	\x03\x02\x02\x02\u{854}\u{855}\x03\x02\x02\x02\u{855}\u{10f}\x03\x02\x02\
	\x02\u{856}\u{859}\x05\x4e\x28\x02\u{857}\u{859}\x05\x4c\x27\x02\u{858}\
	\u{856}\x03\x02\x02\x02\u{858}\u{857}\x03\x02\x02\x02\u{859}\u{111}\x03\
	\x02\x02\x02\u{85a}\u{85b}\x07\x30\x02\x02\u{85b}\u{866}\x05\x02\x02\x02\
	\u{85c}\u{866}\x07\x67\x02\x02\u{85d}\u{866}\x05\u{114}\u{8b}\x02\u{85e}\
	\u{866}\x05\u{116}\u{8c}\x02\u{85f}\u{866}\x05\u{118}\u{8d}\x02\u{860}\u{866}\
	\x05\u{11a}\u{8e}\x02\u{861}\u{862}\x07\x0b\x02\x02\u{862}\u{863}\x05\u{112}\
	\u{8a}\x02\u{863}\u{864}\x07\x0d\x02\x02\u{864}\u{866}\x03\x02\x02\x02\u{865}\
	\u{85a}\x03\x02\x02\x02\u{865}\u{85c}\x03\x02\x02\x02\u{865}\u{85d}\x03\
	\x02\x02\x02\u{865}\u{85e}\x03\x02\x02\x02\u{865}\u{85f}\x03\x02\x02\x02\
	\u{865}\u{860}\x03\x02\x02\x02\u{865}\u{861}\x03\x02\x02\x02\u{866}\u{113}\
	\x03\x02\x02\x02\u{867}\u{868}\x09\x07\x02\x02\u{868}\u{115}\x03\x02\x02\
	\x02\u{869}\u{86a}\x07\x2a\x02\x02\u{86a}\u{86c}\x07\u{93}\x02\x02\u{86b}\
	\u{86d}\x05\u{112}\u{8a}\x02\u{86c}\u{86b}\x03\x02\x02\x02\u{86c}\u{86d}\
	\x03\x02\x02\x02\u{86d}\u{117}\x03\x02\x02\x02\u{86e}\u{86f}\x07\x2a\x02\
	\x02\u{86f}\u{870}\x07\u{93}\x02\x02\u{870}\u{871}\x07\x26\x02\x02\u{871}\
	\u{872}\x05\x02\x02\x02\u{872}\u{873}\x07\x06\x02\x02\u{873}\u{87b}\x05\
	\u{112}\u{8a}\x02\u{874}\u{875}\x07\x08\x02\x02\u{875}\u{876}\x05\x02\x02\
	\x02\u{876}\u{877}\x07\x06\x02\x02\u{877}\u{878}\x05\u{112}\u{8a}\x02\u{878}\
	\u{87a}\x03\x02\x02\x02\u{879}\u{874}\x03\x02\x02\x02\u{87a}\u{87d}\x03\
	\x02\x02\x02\u{87b}\u{879}\x03\x02\x02\x02\u{87b}\u{87c}\x03\x02\x02\x02\
	\u{87c}\u{87e}\x03\x02\x02\x02\u{87d}\u{87b}\x03\x02\x02\x02\u{87e}\u{87f}\
	\x07\x27\x02\x02\u{87f}\u{119}\x03\x02\x02\x02\u{880}\u{881}\x07\x26\x02\
	\x02\u{881}\u{886}\x05\u{112}\u{8a}\x02\u{882}\u{883}\x07\x08\x02\x02\u{883}\
	\u{885}\x05\u{112}\u{8a}\x02\u{884}\u{882}\x03\x02\x02\x02\u{885}\u{888}\
	\x03\x02\x02\x02\u{886}\u{884}\x03\x02\x02\x02\u{886}\u{887}\x03\x02\x02\
	\x02\u{887}\u{889}\x03\x02\x02\x02\u{888}\u{886}\x03\x02\x02\x02\u{889}\
	\u{88a}\x07\x27\x02\x02\u{88a}\u{11b}\x03\x02\x02\x02\u{88b}\u{88e}\x05\
	\u{112}\u{8a}\x02\u{88c}\u{88d}\x07\x41\x02\x02\u{88d}\u{88f}\x05\u{d2}\
	\x6a\x02\u{88e}\u{88c}\x03\x02\x02\x02\u{88e}\u{88f}\x03\x02\x02\x02\u{88f}\
	\u{890}\x03\x02\x02\x02\u{890}\u{891}\x07\x06\x02\x02\u{891}\u{892}\x05\
	\u{ce}\x68\x02\u{892}\u{11d}\x03\x02\x02\x02\u{893}\u{896}\x05\u{112}\u{8a}\
	\x02\u{894}\u{895}\x07\x41\x02\x02\u{895}\u{897}\x05\u{d2}\x6a\x02\u{896}\
	\u{894}\x03\x02\x02\x02\u{896}\u{897}\x03\x02\x02\x02\u{897}\u{898}\x03\
	\x02\x02\x02\u{898}\u{899}\x07\x06\x02\x02\u{899}\u{89a}\x05\u{fa}\x7e\x02\
	\u{89a}\u{11f}\x03\x02\x02\x02\u{89b}\u{89e}\x05\u{112}\u{8a}\x02\u{89c}\
	\u{89d}\x07\x41\x02\x02\u{89d}\u{89f}\x05\u{d2}\x6a\x02\u{89e}\u{89c}\x03\
	\x02\x02\x02\u{89e}\u{89f}\x03\x02\x02\x02\u{89f}\u{8a0}\x03\x02\x02\x02\
	\u{8a0}\u{8a1}\x07\x06\x02\x02\u{8a1}\u{8a2}\x05\u{fe}\u{80}\x02\u{8a2}\
	\u{121}\x03\x02\x02\x02\u{8a3}\u{8a6}\x05\u{112}\u{8a}\x02\u{8a4}\u{8a5}\
	\x07\x41\x02\x02\u{8a5}\u{8a7}\x05\u{d2}\x6a\x02\u{8a6}\u{8a4}\x03\x02\x02\
	\x02\u{8a6}\u{8a7}\x03\x02\x02\x02\u{8a7}\u{8a8}\x03\x02\x02\x02\u{8a8}\
	\u{8a9}\x07\x06\x02\x02\u{8a9}\u{8aa}\x05\x3c\x1f\x02\u{8aa}\u{123}\x03\
	\x02\x02\x02\u{8ab}\u{8ae}\x05\u{112}\u{8a}\x02\u{8ac}\u{8ad}\x07\x41\x02\
	\x02\u{8ad}\u{8af}\x05\u{d2}\x6a\x02\u{8ae}\u{8ac}\x03\x02\x02\x02\u{8ae}\
	\u{8af}\x03\x02\x02\x02\u{8af}\u{8b0}\x03\x02\x02\x02\u{8b0}\u{8b1}\x07\
	\x06\x02\x02\u{8b1}\u{8b2}\x05\x4c\x27\x02\u{8b2}\u{125}\x03\x02\x02\x02\
	\u{8b3}\u{8b4}\x07\x37\x02\x02\u{8b4}\u{8b5}\x07\x0b\x02\x02\u{8b5}\u{8b6}\
	\x05\u{d2}\x6a\x02\u{8b6}\u{8b7}\x07\x0d\x02\x02\u{8b7}\u{8bb}\x07\x39\x02\
	\x02\u{8b8}\u{8ba}\x05\u{128}\u{95}\x02\u{8b9}\u{8b8}\x03\x02\x02\x02\u{8ba}\
	\u{8bd}\x03\x02\x02\x02\u{8bb}\u{8b9}\x03\x02\x02\x02\u{8bb}\u{8bc}\x03\
	\x02\x02\x02\u{8bc}\u{8be}\x03\x02\x02\x02\u{8bd}\u{8bb}\x03\x02\x02\x02\
	\u{8be}\u{8bf}\x07\x38\x02\x02\u{8bf}\u{127}\x03\x02\x02\x02\u{8c0}\u{8c3}\
	\x05\u{112}\u{8a}\x02\u{8c1}\u{8c2}\x07\x41\x02\x02\u{8c2}\u{8c4}\x05\u{d2}\
	\x6a\x02\u{8c3}\u{8c1}\x03\x02\x02\x02\u{8c3}\u{8c4}\x03\x02\x02\x02\u{8c4}\
	\u{8c5}\x03\x02\x02\x02\u{8c5}\u{8c6}\x07\x06\x02\x02\u{8c6}\u{8c7}\x05\
	\u{d2}\x6a\x02\u{8c7}\u{8ce}\x03\x02\x02\x02\u{8c8}\u{8ca}\x07\x3a\x02\x02\
	\u{8c9}\u{8cb}\x07\x06\x02\x02\u{8ca}\u{8c9}\x03\x02\x02\x02\u{8ca}\u{8cb}\
	\x03\x02\x02\x02\u{8cb}\u{8cc}\x03\x02\x02\x02\u{8cc}\u{8ce}\x05\u{d2}\x6a\
	\x02\u{8cd}\u{8c0}\x03\x02\x02\x02\u{8cd}\u{8c8}\x03\x02\x02\x02\u{8ce}\
	\u{129}\x03\x02\x02\x02\u{8cf}\u{8d0}\x07\x68\x02\x02\u{8d0}\u{8d5}\x05\
	\u{12e}\u{98}\x02\u{8d1}\u{8d2}\x07\x08\x02\x02\u{8d2}\u{8d4}\x05\u{12e}\
	\u{98}\x02\u{8d3}\u{8d1}\x03\x02\x02\x02\u{8d4}\u{8d7}\x03\x02\x02\x02\u{8d5}\
	\u{8d3}\x03\x02\x02\x02\u{8d5}\u{8d6}\x03\x02\x02\x02\u{8d6}\u{8d8}\x03\
	\x02\x02\x02\u{8d7}\u{8d5}\x03\x02\x02\x02\u{8d8}\u{8d9}\x07\x69\x02\x02\
	\u{8d9}\u{12b}\x03\x02\x02\x02\u{8da}\u{8dc}\x05\u{12a}\u{96}\x02\u{8db}\
	\u{8da}\x03\x02\x02\x02\u{8dc}\u{8df}\x03\x02\x02\x02\u{8dd}\u{8db}\x03\
	\x02\x02\x02\u{8dd}\u{8de}\x03\x02\x02\x02\u{8de}\u{12d}\x03\x02\x02\x02\
	\u{8df}\u{8dd}\x03\x02\x02\x02\u{8e0}\u{8e3}\x05\u{130}\u{99}\x02\u{8e1}\
	\u{8e2}\x07\x20\x02\x02\u{8e2}\u{8e4}\x05\u{d2}\x6a\x02\u{8e3}\u{8e1}\x03\
	\x02\x02\x02\u{8e3}\u{8e4}\x03\x02\x02\x02\u{8e4}\u{12f}\x03\x02\x02\x02\
	\u{8e5}\u{8e8}\x05\x02\x02\x02\u{8e6}\u{8e8}\x07\u{93}\x02\x02\u{8e7}\u{8e5}\
	\x03\x02\x02\x02\u{8e7}\u{8e6}\x03\x02\x02\x02\u{8e8}\u{131}\x03\x02\x02\
	\x02\u{8e9}\u{8ea}\x07\x6a\x02\x02\u{8ea}\u{8eb}\x07\x0b\x02\x02\u{8eb}\
	\u{8f0}\x05\u{134}\u{9b}\x02\u{8ec}\u{8ed}\x07\x08\x02\x02\u{8ed}\u{8ef}\
	\x05\u{134}\u{9b}\x02\u{8ee}\u{8ec}\x03\x02\x02\x02\u{8ef}\u{8f2}\x03\x02\
	\x02\x02\u{8f0}\u{8ee}\x03\x02\x02\x02\u{8f0}\u{8f1}\x03\x02\x02\x02\u{8f1}\
	\u{8f3}\x03\x02\x02\x02\u{8f2}\u{8f0}\x03\x02\x02\x02\u{8f3}\u{8f4}\x07\
	\x0d\x02\x02\u{8f4}\u{133}\x03\x02\x02\x02\u{8f5}\u{8f6}\x07\u{93}\x02\x02\
	\u{8f6}\u{8f7}\x07\x0f\x02\x02\u{8f7}\u{8f8}\x07\x0b\x02\x02\u{8f8}\u{8fd}\
	\x05\x18\x0d\x02\u{8f9}\u{8fa}\x07\x08\x02\x02\u{8fa}\u{8fc}\x05\x18\x0d\
	\x02\u{8fb}\u{8f9}\x03\x02\x02\x02\u{8fc}\u{8ff}\x03\x02\x02\x02\u{8fd}\
	\u{8fb}\x03\x02\x02\x02\u{8fd}\u{8fe}\x03\x02\x02\x02\u{8fe}\u{900}\x03\
	\x02\x02\x02\u{8ff}\u{8fd}\x03\x02\x02\x02\u{900}\u{901}\x07\x0d\x02\x02\
	\u{901}\u{135}\x03\x02\x02\x02\u{902}\u{903}\x07\x6b\x02\x02\u{903}\u{904}\
	\x05\u{138}\u{9d}\x02\u{904}\u{906}\x05\x24\x13\x02\u{905}\u{907}\x05\u{132}\
	\u{9a}\x02\u{906}\u{905}\x03\x02\x02\x02\u{906}\u{907}\x03\x02\x02\x02\u{907}\
	\u{909}\x03\x02\x02\x02\u{908}\u{90a}\x05\u{13c}\u{9f}\x02\u{909}\u{908}\
	\x03\x02\x02\x02\u{909}\u{90a}\x03\x02\x02\x02\u{90a}\u{90b}\x03\x02\x02\
	\x02\u{90b}\u{90f}\x07\x04\x02\x02\u{90c}\u{90e}\x05\u{140}\u{a1}\x02\u{90d}\
	\u{90c}\x03\x02\x02\x02\u{90e}\u{911}\x03\x02\x02\x02\u{90f}\u{90d}\x03\
	\x02\x02\x02\u{90f}\u{910}\x03\x02\x02\x02\u{910}\u{912}\x03\x02\x02\x02\
	\u{911}\u{90f}\x03\x02\x02\x02\u{912}\u{915}\x07\x6c\x02\x02\u{913}\u{914}\
	\x07\x06\x02\x02\u{914}\u{916}\x07\u{93}\x02\x02\u{915}\u{913}\x03\x02\x02\
	\x02\u{915}\u{916}\x03\x02\x02\x02\u{916}\u{137}\x03\x02\x02\x02\u{917}\
	\u{918}\x07\u{93}\x02\x02\u{918}\u{139}\x03\x02\x02\x02\u{919}\u{926}\x05\
	\x1e\x10\x02\u{91a}\u{91b}\x07\x0b\x02\x02\u{91b}\u{920}\x05\x1e\x10\x02\
	\u{91c}\u{91d}\x07\x08\x02\x02\u{91d}\u{91f}\x05\x1e\x10\x02\u{91e}\u{91c}\
	\x03\x02\x02\x02\u{91f}\u{922}\x03\x02\x02\x02\u{920}\u{91e}\x03\x02\x02\
	\x02\u{920}\u{921}\x03\x02\x02\x02\u{921}\u{923}\x03\x02\x02\x02\u{922}\
	\u{920}\x03\x02\x02\x02\u{923}\u{924}\x07\x0d\x02\x02\u{924}\u{926}\x03\
	\x02\x02\x02\u{925}\u{919}\x03\x02\x02\x02\u{925}\u{91a}\x03\x02\x02\x02\
	\u{926}\u{13b}\x03\x02\x02\x02\u{927}\u{928}\x07\x6d\x02\x02\u{928}\u{929}\
	\x07\x0b\x02\x02\u{929}\u{92e}\x05\u{13e}\u{a0}\x02\u{92a}\u{92b}\x07\x08\
	\x02\x02\u{92b}\u{92d}\x05\u{13e}\u{a0}\x02\u{92c}\u{92a}\x03\x02\x02\x02\
	\u{92d}\u{930}\x03\x02\x02\x02\u{92e}\u{92c}\x03\x02\x02\x02\u{92e}\u{92f}\
	\x03\x02\x02\x02\u{92f}\u{931}\x03\x02\x02\x02\u{930}\u{92e}\x03\x02\x02\
	\x02\u{931}\u{932}\x07\x0d\x02\x02\u{932}\u{13d}\x03\x02\x02\x02\u{933}\
	\u{934}\x05\u{13a}\u{9e}\x02\u{934}\u{935}\x07\x6e\x02\x02\u{935}\u{936}\
	\x05\u{13a}\u{9e}\x02\u{936}\u{13f}\x03\x02\x02\x02\u{937}\u{93d}\x05\u{c6}\
	\x64\x02\u{938}\u{93d}\x05\x6a\x36\x02\u{939}\u{93d}\x05\x34\x1b\x02\u{93a}\
	\u{93d}\x05\x32\x1a\x02\u{93b}\u{93d}\x05\u{c4}\x63\x02\u{93c}\u{937}\x03\
	\x02\x02\x02\u{93c}\u{938}\x03\x02\x02\x02\u{93c}\u{939}\x03\x02\x02\x02\
	\u{93c}\u{93a}\x03\x02\x02\x02\u{93c}\u{93b}\x03\x02\x02\x02\u{93d}\u{141}\
	\x03\x02\x02\x02\u{93e}\u{93f}\x07\x6f\x02\x02\u{93f}\u{940}\x05\u{138}\
	\u{9d}\x02\u{940}\u{941}\x07\x0f\x02\x02\u{941}\u{942}\x07\x0b\x02\x02\u{942}\
	\u{947}\x05\x18\x0d\x02\u{943}\u{944}\x07\x08\x02\x02\u{944}\u{946}\x05\
	\x18\x0d\x02\u{945}\u{943}\x03\x02\x02\x02\u{946}\u{949}\x03\x02\x02\x02\
	\u{947}\u{945}\x03\x02\x02\x02\u{947}\u{948}\x03\x02\x02\x02\u{948}\u{94a}\
	\x03\x02\x02\x02\u{949}\u{947}\x03\x02\x02\x02\u{94a}\u{94c}\x07\x0d\x02\
	\x02\u{94b}\u{94d}\x05\u{132}\u{9a}\x02\u{94c}\u{94b}\x03\x02\x02\x02\u{94c}\
	\u{94d}\x03\x02\x02\x02\u{94d}\u{94e}\x03\x02\x02\x02\u{94e}\u{954}\x07\
	\x04\x02\x02\u{94f}\u{953}\x05\x70\x39\x02\u{950}\u{953}\x05\u{c4}\x63\x02\
	\u{951}\u{953}\x05\x32\x1a\x02\u{952}\u{94f}\x03\x02\x02\x02\u{952}\u{950}\
	\x03\x02\x02\x02\u{952}\u{951}\x03\x02\x02\x02\u{953}\u{956}\x03\x02\x02\
	\x02\u{954}\u{952}\x03\x02\x02\x02\u{954}\u{955}\x03\x02\x02\x02\u{955}\
	\u{957}\x03\x02\x02\x02\u{956}\u{954}\x03\x02\x02\x02\u{957}\u{95a}\x07\
	\x70\x02\x02\u{958}\u{959}\x07\x06\x02\x02\u{959}\u{95b}\x05\u{138}\u{9d}\
	\x02\u{95a}\u{958}\x03\x02\x02\x02\u{95a}\u{95b}\x03\x02\x02\x02\u{95b}\
	\u{143}\x03\x02\x02\x02\u{95c}\u{95d}\x07\x71\x02\x02\u{95d}\u{95e}\x07\
	\x0b\x02\x02\u{95e}\u{963}\x05\u{138}\u{9d}\x02\u{95f}\u{960}\x07\x08\x02\
	\x02\u{960}\u{962}\x05\u{138}\u{9d}\x02\u{961}\u{95f}\x03\x02\x02\x02\u{962}\
	\u{965}\x03\x02\x02\x02\u{963}\u{961}\x03\x02\x02\x02\u{963}\u{964}\x03\
	\x02\x02\x02\u{964}\u{966}\x03\x02\x02\x02\u{965}\u{963}\x03\x02\x02\x02\
	\u{966}\u{967}\x07\x0d\x02\x02\u{967}\u{145}\x03\x02\x02\x02\u{968}\u{969}\
	\x07\x0e\x02\x02\u{969}\u{96d}\x07\x72\x02\x02\u{96a}\u{96b}\x05\x02\x02\
	\x02\u{96b}\u{96c}\x07\x20\x02\x02\u{96c}\u{96e}\x03\x02\x02\x02\u{96d}\
	\u{96a}\x03\x02\x02\x02\u{96d}\u{96e}\x03\x02\x02\x02\u{96e}\u{96f}\x03\
	\x02\x02\x02\u{96f}\u{973}\x05\x34\x1b\x02\u{970}\u{972}\x05\x3c\x1f\x02\
	\u{971}\u{970}\x03\x02\x02\x02\u{972}\u{975}\x03\x02\x02\x02\u{973}\u{971}\
	\x03\x02\x02\x02\u{973}\u{974}\x03\x02\x02\x02\u{974}\u{979}\x03\x02\x02\
	\x02\u{975}\u{973}\x03\x02\x02\x02\u{976}\u{978}\x05\u{148}\u{a5}\x02\u{977}\
	\u{976}\x03\x02\x02\x02\u{978}\u{97b}\x03\x02\x02\x02\u{979}\u{977}\x03\
	\x02\x02\x02\u{979}\u{97a}\x03\x02\x02\x02\u{97a}\u{97c}\x03\x02\x02\x02\
	\u{97b}\u{979}\x03\x02\x02\x02\u{97c}\u{97f}\x07\x19\x02\x02\u{97d}\u{97e}\
	\x07\x06\x02\x02\u{97e}\u{980}\x05\x02\x02\x02\u{97f}\u{97d}\x03\x02\x02\
	\x02\u{97f}\u{980}\x03\x02\x02\x02\u{980}\u{147}\x03\x02\x02\x02\u{981}\
	\u{992}\x05\u{152}\u{aa}\x02\u{982}\u{992}\x05\u{154}\u{ab}\x02\u{983}\u{992}\
	\x05\u{156}\u{ac}\x02\u{984}\u{992}\x05\u{158}\u{ad}\x02\u{985}\u{992}\x05\
	\u{15e}\u{b0}\x02\u{986}\u{992}\x05\u{160}\u{b1}\x02\u{987}\u{992}\x05\u{162}\
	\u{b2}\x02\u{988}\u{992}\x05\u{166}\u{b4}\x02\u{989}\u{992}\x05\u{17c}\u{bf}\
	\x02\u{98a}\u{992}\x05\u{168}\u{b5}\x02\u{98b}\u{992}\x05\u{16a}\u{b6}\x02\
	\u{98c}\u{992}\x05\u{16c}\u{b7}\x02\u{98d}\u{992}\x05\u{16e}\u{b8}\x02\u{98e}\
	\u{992}\x05\u{172}\u{ba}\x02\u{98f}\u{992}\x05\u{174}\u{bb}\x02\u{990}\u{992}\
	\x05\u{178}\u{bd}\x02\u{991}\u{981}\x03\x02\x02\x02\u{991}\u{982}\x03\x02\
	\x02\x02\u{991}\u{983}\x03\x02\x02\x02\u{991}\u{984}\x03\x02\x02\x02\u{991}\
	\u{985}\x03\x02\x02\x02\u{991}\u{986}\x03\x02\x02\x02\u{991}\u{987}\x03\
	\x02\x02\x02\u{991}\u{988}\x03\x02\x02\x02\u{991}\u{989}\x03\x02\x02\x02\
	\u{991}\u{98a}\x03\x02\x02\x02\u{991}\u{98b}\x03\x02\x02\x02\u{991}\u{98c}\
	\x03\x02\x02\x02\u{991}\u{98d}\x03\x02\x02\x02\u{991}\u{98e}\x03\x02\x02\
	\x02\u{991}\u{98f}\x03\x02\x02\x02\u{991}\u{990}\x03\x02\x02\x02\u{992}\
	\u{149}\x03\x02\x02\x02\u{993}\u{994}\x07\x73\x02\x02\u{994}\u{995}\x07\
	\x0b\x02\x02\u{995}\u{996}\x05\u{15c}\u{af}\x02\u{996}\u{997}\x07\x0d\x02\
	\x02\u{997}\u{14b}\x03\x02\x02\x02\u{998}\u{999}\x07\x74\x02\x02\u{999}\
	\u{99a}\x07\x0b\x02\x02\u{99a}\u{99b}\x05\u{15c}\u{af}\x02\u{99b}\u{99c}\
	\x07\x0d\x02\x02\u{99c}\u{14d}\x03\x02\x02\x02\u{99d}\u{99e}\x07\x5e\x02\
	\x02\u{99e}\u{99f}\x07\x0b\x02\x02\u{99f}\u{9a0}\x05\u{164}\u{b3}\x02\u{9a0}\
	\u{9a1}\x07\x0d\x02\x02\u{9a1}\u{14f}\x03\x02\x02\x02\u{9a2}\u{9a3}\x07\
	\x5f\x02\x02\u{9a3}\u{9a4}\x07\x0b\x02\x02\u{9a4}\u{9a5}\x05\u{17a}\u{be}\
	\x02\u{9a5}\u{9a6}\x07\x0d\x02\x02\u{9a6}\u{151}\x03\x02\x02\x02\u{9a7}\
	\u{9a8}\x07\x1b\x02\x02\u{9a8}\u{9a9}\x05\x02\x02\x02\u{9a9}\u{9aa}\x07\
	\x20\x02\x02\u{9aa}\u{9ab}\x05\u{d2}\x6a\x02\u{9ab}\u{9ac}\x07\x04\x02\x02\
	\u{9ac}\u{153}\x03\x02\x02\x02\u{9ad}\u{9af}\x07\x18\x02\x02\u{9ae}\u{9b0}\
	\x05\u{15c}\u{af}\x02\u{9af}\u{9ae}\x03\x02\x02\x02\u{9af}\u{9b0}\x03\x02\
	\x02\x02\u{9b0}\u{9b1}\x03\x02\x02\x02\u{9b1}\u{9be}\x05\x02\x02\x02\u{9b2}\
	\u{9bb}\x07\x0b\x02\x02\u{9b3}\u{9b8}\x05\u{15c}\u{af}\x02\u{9b4}\u{9b5}\
	\x07\x08\x02\x02\u{9b5}\u{9b7}\x05\u{15c}\u{af}\x02\u{9b6}\u{9b4}\x03\x02\
	\x02\x02\u{9b7}\u{9ba}\x03\x02\x02\x02\u{9b8}\u{9b6}\x03\x02\x02\x02\u{9b8}\
	\u{9b9}\x03\x02\x02\x02\u{9b9}\u{9bc}\x03\x02\x02\x02\u{9ba}\u{9b8}\x03\
	\x02\x02\x02\u{9bb}\u{9b3}\x03\x02\x02\x02\u{9bb}\u{9bc}\x03\x02\x02\x02\
	\u{9bc}\u{9bd}\x03\x02\x02\x02\u{9bd}\u{9bf}\x07\x0d\x02\x02\u{9be}\u{9b2}\
	\x03\x02\x02\x02\u{9be}\u{9bf}\x03\x02\x02\x02\u{9bf}\u{9c6}\x03\x02\x02\
	\x02\u{9c0}\u{9c5}\x05\u{14a}\u{a6}\x02\u{9c1}\u{9c5}\x05\u{14c}\u{a7}\x02\
	\u{9c2}\u{9c5}\x05\u{14e}\u{a8}\x02\u{9c3}\u{9c5}\x05\u{150}\u{a9}\x02\u{9c4}\
	\u{9c0}\x03\x02\x02\x02\u{9c4}\u{9c1}\x03\x02\x02\x02\u{9c4}\u{9c2}\x03\
	\x02\x02\x02\u{9c4}\u{9c3}\x03\x02\x02\x02\u{9c5}\u{9c8}\x03\x02\x02\x02\
	\u{9c6}\u{9c4}\x03\x02\x02\x02\u{9c6}\u{9c7}\x03\x02\x02\x02\u{9c7}\u{9c9}\
	\x03\x02\x02\x02\u{9c8}\u{9c6}\x03\x02\x02\x02\u{9c9}\u{9ca}\x07\x04\x02\
	\x02\u{9ca}\u{155}\x03\x02\x02\x02\u{9cb}\u{9cc}\x07\x75\x02\x02\u{9cc}\
	\u{9d1}\x05\x02\x02\x02\u{9cd}\u{9d0}\x05\u{14e}\u{a8}\x02\u{9ce}\u{9d0}\
	\x05\u{150}\u{a9}\x02\u{9cf}\u{9cd}\x03\x02\x02\x02\u{9cf}\u{9ce}\x03\x02\
	\x02\x02\u{9d0}\u{9d3}\x03\x02\x02\x02\u{9d1}\u{9cf}\x03\x02\x02\x02\u{9d1}\
	\u{9d2}\x03\x02\x02\x02\u{9d2}\u{9d4}\x03\x02\x02\x02\u{9d3}\u{9d1}\x03\
	\x02\x02\x02\u{9d4}\u{9d5}\x07\x20\x02\x02\u{9d5}\u{9d6}\x05\u{d2}\x6a\x02\
	\u{9d6}\u{9d7}\x07\x04\x02\x02\u{9d7}\u{157}\x03\x02\x02\x02\u{9d8}\u{9da}\
	\x07\x76\x02\x02\u{9d9}\u{9db}\x05\x02\x02\x02\u{9da}\u{9d9}\x03\x02\x02\
	\x02\u{9da}\u{9db}\x03\x02\x02\x02\u{9db}\u{9dc}\x03\x02\x02\x02\u{9dc}\
	\u{9de}\x07\x0b\x02\x02\u{9dd}\u{9df}\x05\u{15a}\u{ae}\x02\u{9de}\u{9dd}\
	\x03\x02\x02\x02\u{9de}\u{9df}\x03\x02\x02\x02\u{9df}\u{9e0}\x03\x02\x02\
	\x02\u{9e0}\u{9e1}\x07\x0d\x02\x02\u{9e1}\u{9e2}\x07\x20\x02\x02\u{9e2}\
	\u{9e3}\x05\u{d2}\x6a\x02\u{9e3}\u{9e4}\x07\x04\x02\x02\u{9e4}\u{159}\x03\
	\x02\x02\x02\u{9e5}\u{9ea}\x05\u{15c}\u{af}\x02\u{9e6}\u{9e7}\x07\x08\x02\
	\x02\u{9e7}\u{9e8}\x05\u{12c}\u{97}\x02\u{9e8}\u{9e9}\x05\u{15c}\u{af}\x02\
	\u{9e9}\u{9eb}\x03\x02\x02\x02\u{9ea}\u{9e6}\x03\x02\x02\x02\u{9ea}\u{9eb}\
	\x03\x02\x02\x02\u{9eb}\u{15b}\x03\x02\x02\x02\u{9ec}\u{9ee}\x05\u{12a}\
	\u{96}\x02\u{9ed}\u{9ec}\x03\x02\x02\x02\u{9ed}\u{9ee}\x03\x02\x02\x02\u{9ee}\
	\u{9ef}\x03\x02\x02\x02\u{9ef}\u{9f0}\x05\x02\x02\x02\u{9f0}\u{15d}\x03\
	\x02\x02\x02\u{9f1}\u{9f3}\x07\x77\x02\x02\u{9f2}\u{9f4}\x05\x02\x02\x02\
	\u{9f3}\u{9f2}\x03\x02\x02\x02\u{9f3}\u{9f4}\x03\x02\x02\x02\u{9f4}\u{9fa}\
	\x03\x02\x02\x02\u{9f5}\u{9f7}\x07\x0b\x02\x02\u{9f6}\u{9f8}\x05\u{15a}\
	\u{ae}\x02\u{9f7}\u{9f6}\x03\x02\x02\x02\u{9f7}\u{9f8}\x03\x02\x02\x02\u{9f8}\
	\u{9f9}\x03\x02\x02\x02\u{9f9}\u{9fb}\x07\x0d\x02\x02\u{9fa}\u{9f5}\x03\
	\x02\x02\x02\u{9fa}\u{9fb}\x03\x02\x02\x02\u{9fb}\u{9fe}\x03\x02\x02\x02\
	\u{9fc}\u{9fd}\x07\x20\x02\x02\u{9fd}\u{9ff}\x05\u{d2}\x6a\x02\u{9fe}\u{9fc}\
	\x03\x02\x02\x02\u{9fe}\u{9ff}\x03\x02\x02\x02\u{9ff}\u{a00}\x03\x02\x02\
	\x02\u{a00}\u{a01}\x07\x04\x02\x02\u{a01}\u{15f}\x03\x02\x02\x02\u{a02}\
	\u{a03}\x07\x78\x02\x02\u{a03}\u{a04}\x05\x02\x02\x02\u{a04}\u{a06}\x07\
	\x0b\x02\x02\u{a05}\u{a07}\x05\u{15a}\u{ae}\x02\u{a06}\u{a05}\x03\x02\x02\
	\x02\u{a06}\u{a07}\x03\x02\x02\x02\u{a07}\u{a08}\x03\x02\x02\x02\u{a08}\
	\u{a09}\x07\x0d\x02\x02\u{a09}\u{a0a}\x07\x04\x02\x02\u{a0a}\u{161}\x03\
	\x02\x02\x02\u{a0b}\u{a0d}\x07\x79\x02\x02\u{a0c}\u{a0e}\x05\x02\x02\x02\
	\u{a0d}\u{a0c}\x03\x02\x02\x02\u{a0d}\u{a0e}\x03\x02\x02\x02\u{a0e}\u{a14}\
	\x03\x02\x02\x02\u{a0f}\u{a11}\x07\x0b\x02\x02\u{a10}\u{a12}\x05\u{15c}\
	\u{af}\x02\u{a11}\u{a10}\x03\x02\x02\x02\u{a11}\u{a12}\x03\x02\x02\x02\u{a12}\
	\u{a13}\x03\x02\x02\x02\u{a13}\u{a15}\x07\x0d\x02\x02\u{a14}\u{a0f}\x03\
	\x02\x02\x02\u{a14}\u{a15}\x03\x02\x02\x02\u{a15}\u{a17}\x03\x02\x02\x02\
	\u{a16}\u{a18}\x05\u{14e}\u{a8}\x02\u{a17}\u{a16}\x03\x02\x02\x02\u{a17}\
	\u{a18}\x03\x02\x02\x02\u{a18}\u{a19}\x03\x02\x02\x02\u{a19}\u{a1a}\x07\
	\x20\x02\x02\u{a1a}\u{a1b}\x05\u{d2}\x6a\x02\u{a1b}\u{a1c}\x07\x04\x02\x02\
	\u{a1c}\u{163}\x03\x02\x02\x02\u{a1d}\u{a1e}\x05\x02\x02\x02\u{a1e}\u{165}\
	\x03\x02\x02\x02\u{a1f}\u{a20}\x07\x7a\x02\x02\u{a20}\u{a21}\x05\x02\x02\
	\x02\u{a21}\u{a22}\x07\x04\x02\x02\u{a22}\u{a37}\x03\x02\x02\x02\u{a23}\
	\u{a25}\x07\x7a\x02\x02\u{a24}\u{a26}\x05\x02\x02\x02\u{a25}\u{a24}\x03\
	\x02\x02\x02\u{a25}\u{a26}\x03\x02\x02\x02\u{a26}\u{a2c}\x03\x02\x02\x02\
	\u{a27}\u{a29}\x07\x0b\x02\x02\u{a28}\u{a2a}\x05\u{15c}\u{af}\x02\u{a29}\
	\u{a28}\x03\x02\x02\x02\u{a29}\u{a2a}\x03\x02\x02\x02\u{a2a}\u{a2b}\x03\
	\x02\x02\x02\u{a2b}\u{a2d}\x07\x0d\x02\x02\u{a2c}\u{a27}\x03\x02\x02\x02\
	\u{a2c}\u{a2d}\x03\x02\x02\x02\u{a2d}\u{a2f}\x03\x02\x02\x02\u{a2e}\u{a30}\
	\x05\u{14e}\u{a8}\x02\u{a2f}\u{a2e}\x03\x02\x02\x02\u{a2f}\u{a30}\x03\x02\
	\x02\x02\u{a30}\u{a33}\x03\x02\x02\x02\u{a31}\u{a32}\x07\x20\x02\x02\u{a32}\
	\u{a34}\x05\u{d2}\x6a\x02\u{a33}\u{a31}\x03\x02\x02\x02\u{a33}\u{a34}\x03\
	\x02\x02\x02\u{a34}\u{a35}\x03\x02\x02\x02\u{a35}\u{a37}\x07\x04\x02\x02\
	\u{a36}\u{a1f}\x03\x02\x02\x02\u{a36}\u{a23}\x03\x02\x02\x02\u{a37}\u{167}\
	\x03\x02\x02\x02\u{a38}\u{a39}\x07\x7b\x02\x02\u{a39}\u{a3f}\x05\x02\x02\
	\x02\u{a3a}\u{a3c}\x07\x0b\x02\x02\u{a3b}\u{a3d}\x05\u{15c}\u{af}\x02\u{a3c}\
	\u{a3b}\x03\x02\x02\x02\u{a3c}\u{a3d}\x03\x02\x02\x02\u{a3d}\u{a3e}\x03\
	\x02\x02\x02\u{a3e}\u{a40}\x07\x0d\x02\x02\u{a3f}\u{a3a}\x03\x02\x02\x02\
	\u{a3f}\u{a40}\x03\x02\x02\x02\u{a40}\u{a42}\x03\x02\x02\x02\u{a41}\u{a43}\
	\x05\u{14e}\u{a8}\x02\u{a42}\u{a41}\x03\x02\x02\x02\u{a42}\u{a43}\x03\x02\
	\x02\x02\u{a43}\u{a44}\x03\x02\x02\x02\u{a44}\u{a45}\x07\x04\x02\x02\u{a45}\
	\u{169}\x03\x02\x02\x02\u{a46}\u{a47}\x07\x7c\x02\x02\u{a47}\u{a48}\x07\
	\x0b\x02\x02\u{a48}\u{a49}\x05\u{164}\u{b3}\x02\u{a49}\u{a4a}\x07\x08\x02\
	\x02\u{a4a}\u{a4b}\x05\u{164}\u{b3}\x02\u{a4b}\u{a4c}\x07\x0d\x02\x02\u{a4c}\
	\u{a4d}\x07\x04\x02\x02\u{a4d}\u{16b}\x03\x02\x02\x02\u{a4e}\u{a4f}\x07\
	\x7d\x02\x02\u{a4f}\u{a50}\x07\x0b\x02\x02\u{a50}\u{a51}\x05\u{164}\u{b3}\
	\x02\u{a51}\u{a52}\x07\x08\x02\x02\u{a52}\u{a53}\x05\u{164}\u{b3}\x02\u{a53}\
	\u{a54}\x07\x0d\x02\x02\u{a54}\u{a55}\x07\x04\x02\x02\u{a55}\u{16d}\x03\
	\x02\x02\x02\u{a56}\u{a63}\x07\x7e\x02\x02\u{a57}\u{a58}\x07\x0b\x02\x02\
	\u{a58}\u{a5d}\x05\x02\x02\x02\u{a59}\u{a5a}\x07\x08\x02\x02\u{a5a}\u{a5c}\
	\x05\x02\x02\x02\u{a5b}\u{a59}\x03\x02\x02\x02\u{a5c}\u{a5f}\x03\x02\x02\
	\x02\u{a5d}\u{a5b}\x03\x02\x02\x02\u{a5d}\u{a5e}\x03\x02\x02\x02\u{a5e}\
	\u{a60}\x03\x02\x02\x02\u{a5f}\u{a5d}\x03\x02\x02\x02\u{a60}\u{a61}\x07\
	\x0d\x02\x02\u{a61}\u{a64}\x03\x02\x02\x02\u{a62}\u{a64}\x05\x02\x02\x02\
	\u{a63}\u{a57}\x03\x02\x02\x02\u{a63}\u{a62}\x03\x02\x02\x02\u{a64}\u{a65}\
	\x03\x02\x02\x02\u{a65}\u{a72}\x05\u{170}\u{b9}\x02\u{a66}\u{a67}\x07\x0b\
	\x02\x02\u{a67}\u{a6c}\x05\x02\x02\x02\u{a68}\u{a69}\x07\x08\x02\x02\u{a69}\
	\u{a6b}\x05\x02\x02\x02\u{a6a}\u{a68}\x03\x02\x02\x02\u{a6b}\u{a6e}\x03\
	\x02\x02\x02\u{a6c}\u{a6a}\x03\x02\x02\x02\u{a6c}\u{a6d}\x03\x02\x02\x02\
	\u{a6d}\u{a6f}\x03\x02\x02\x02\u{a6e}\u{a6c}\x03\x02\x02\x02\u{a6f}\u{a70}\
	\x07\x0d\x02\x02\u{a70}\u{a73}\x03\x02\x02\x02\u{a71}\u{a73}\x05\x02\x02\
	\x02\u{a72}\u{a66}\x03\x02\x02\x02\u{a72}\u{a71}\x03\x02\x02\x02\u{a73}\
	\u{a74}\x03\x02\x02\x02\u{a74}\u{a75}\x07\x04\x02\x02\u{a75}\u{16f}\x03\
	\x02\x02\x02\u{a76}\u{a77}\x09\x08\x02\x02\u{a77}\u{171}\x03\x02\x02\x02\
	\u{a78}\u{a79}\x07\u{83}\x02\x02\u{a79}\u{a7a}\x07\x0b\x02\x02\u{a7a}\u{a7b}\
	\x05\u{15c}\u{af}\x02\u{a7b}\u{a7c}\x07\x08\x02\x02\u{a7c}\u{a7d}\x05\u{15c}\
	\u{af}\x02\u{a7d}\u{a7e}\x07\x0d\x02\x02\u{a7e}\u{a7f}\x07\x04\x02\x02\u{a7f}\
	\u{173}\x03\x02\x02\x02\u{a80}\u{a81}\x07\x14\x02\x02\u{a81}\u{a83}\x05\
	\x22\x12\x02\u{a82}\u{a84}\x05\x1e\x10\x02\u{a83}\u{a82}\x03\x02\x02\x02\
	\u{a83}\u{a84}\x03\x02\x02\x02\u{a84}\u{a85}\x03\x02\x02\x02\u{a85}\u{a89}\
	\x07\x04\x02\x02\u{a86}\u{a88}\x05\u{176}\u{bc}\x02\u{a87}\u{a86}\x03\x02\
	\x02\x02\u{a88}\u{a8b}\x03\x02\x02\x02\u{a89}\u{a87}\x03\x02\x02\x02\u{a89}\
	\u{a8a}\x03\x02\x02\x02\u{a8a}\u{a8c}\x03\x02\x02\x02\u{a8b}\u{a89}\x03\
	\x02\x02\x02\u{a8c}\u{a8f}\x07\x15\x02\x02\u{a8d}\u{a8e}\x07\x06\x02\x02\
	\u{a8e}\u{a90}\x05\x1e\x10\x02\u{a8f}\u{a8d}\x03\x02\x02\x02\u{a8f}\u{a90}\
	\x03\x02\x02\x02\u{a90}\u{175}\x03\x02\x02\x02\u{a91}\u{a94}\x05\u{154}\
	\u{ab}\x02\u{a92}\u{a94}\x05\u{174}\u{bb}\x02\u{a93}\u{a91}\x03\x02\x02\
	\x02\u{a93}\u{a92}\x03\x02\x02\x02\u{a94}\u{177}\x03\x02\x02\x02\u{a95}\
	\u{a96}\x07\u{84}\x02\x02\u{a96}\u{a9b}\x05\u{15c}\u{af}\x02\u{a97}\u{a9a}\
	\x05\u{14e}\u{a8}\x02\u{a98}\u{a9a}\x05\u{150}\u{a9}\x02\u{a99}\u{a97}\x03\
	\x02\x02\x02\u{a99}\u{a98}\x03\x02\x02\x02\u{a9a}\u{a9d}\x03\x02\x02\x02\
	\u{a9b}\u{a99}\x03\x02\x02\x02\u{a9b}\u{a9c}\x03\x02\x02\x02\u{a9c}\u{a9e}\
	\x03\x02\x02\x02\u{a9d}\u{a9b}\x03\x02\x02\x02\u{a9e}\u{a9f}\x07\x20\x02\
	\x02\u{a9f}\u{aa0}\x05\u{d2}\x6a\x02\u{aa0}\u{aa1}\x07\x04\x02\x02\u{aa1}\
	\u{ab1}\x03\x02\x02\x02\u{aa2}\u{aa3}\x07\u{85}\x02\x02\u{aa3}\u{aa4}\x05\
	\x02\x02\x02\u{aa4}\u{aa5}\x07\x0b\x02\x02\u{aa5}\u{aa6}\x05\u{15c}\u{af}\
	\x02\u{aa6}\u{aab}\x07\x0d\x02\x02\u{aa7}\u{aaa}\x05\u{14e}\u{a8}\x02\u{aa8}\
	\u{aaa}\x05\u{150}\u{a9}\x02\u{aa9}\u{aa7}\x03\x02\x02\x02\u{aa9}\u{aa8}\
	\x03\x02\x02\x02\u{aaa}\u{aad}\x03\x02\x02\x02\u{aab}\u{aa9}\x03\x02\x02\
	\x02\u{aab}\u{aac}\x03\x02\x02\x02\u{aac}\u{aae}\x03\x02\x02\x02\u{aad}\
	\u{aab}\x03\x02\x02\x02\u{aae}\u{aaf}\x07\x04\x02\x02\u{aaf}\u{ab1}\x03\
	\x02\x02\x02\u{ab0}\u{a95}\x03\x02\x02\x02\u{ab0}\u{aa2}\x03\x02\x02\x02\
	\u{ab1}\u{179}\x03\x02\x02\x02\u{ab2}\u{ab3}\x05\x02\x02\x02\u{ab3}\u{17b}\
	\x03\x02\x02\x02\u{ab4}\u{ab5}\x07\u{86}\x02\x02\u{ab5}\u{ab6}\x07\x04\x02\
	\x02\u{ab6}\u{17d}\x03\x02\x02\x02\u{ab7}\u{ab8}\x07\x0e\x02\x02\u{ab8}\
	\u{abc}\x07\u{87}\x02\x02\u{ab9}\u{aba}\x05\x02\x02\x02\u{aba}\u{abb}\x07\
	\x20\x02\x02\u{abb}\u{abd}\x03\x02\x02\x02\u{abc}\u{ab9}\x03\x02\x02\x02\
	\u{abc}\u{abd}\x03\x02\x02\x02\u{abd}\u{abe}\x03\x02\x02\x02\u{abe}\u{abf}\
	\x07\x3e\x02\x02\u{abf}\u{ac0}\x05\x18\x0d\x02\u{ac0}\u{ac1}\x05\x02\x02\
	\x02\u{ac1}\u{ac3}\x07\x0b\x02\x02\u{ac2}\u{ac4}\x05\u{180}\u{c1}\x02\u{ac3}\
	\u{ac2}\x03\x02\x02\x02\u{ac3}\u{ac4}\x03\x02\x02\x02\u{ac4}\u{ac5}\x03\
	\x02\x02\x02\u{ac5}\u{ac7}\x07\x0d\x02\x02\u{ac6}\u{ac8}\x05\u{132}\u{9a}\
	\x02\u{ac7}\u{ac6}\x03\x02\x02\x02\u{ac7}\u{ac8}\x03\x02\x02\x02\u{ac8}\
	\u{ac9}\x03\x02\x02\x02\u{ac9}\u{aca}\x07\x04\x02\x02\u{aca}\u{17f}\x03\
	\x02\x02\x02\u{acb}\u{ad0}\x05\u{182}\u{c2}\x02\u{acc}\u{acd}\x07\x08\x02\
	\x02\u{acd}\u{acf}\x05\u{182}\u{c2}\x02\u{ace}\u{acc}\x03\x02\x02\x02\u{acf}\
	\u{ad2}\x03\x02\x02\x02\u{ad0}\u{ace}\x03\x02\x02\x02\u{ad0}\u{ad1}\x03\
	\x02\x02\x02\u{ad1}\u{181}\x03\x02\x02\x02\u{ad2}\u{ad0}\x03\x02\x02\x02\
	\u{ad3}\u{ad5}\x05\x18\x0d\x02\u{ad4}\u{ad6}\x05\x02\x02\x02\u{ad5}\u{ad4}\
	\x03\x02\x02\x02\u{ad5}\u{ad6}\x03\x02\x02\x02\u{ad6}\u{183}\x03\x02\x02\
	\x02\u{ad7}\u{ae0}\x05\u{186}\u{c4}\x02\u{ad8}\u{ae0}\x05\u{188}\u{c5}\x02\
	\u{ad9}\u{ae0}\x05\u{18a}\u{c6}\x02\u{ada}\u{ae0}\x05\u{18c}\u{c7}\x02\u{adb}\
	\u{ae0}\x05\u{18e}\u{c8}\x02\u{adc}\u{ae0}\x05\u{194}\u{cb}\x02\u{add}\u{ae0}\
	\x05\u{190}\u{c9}\x02\u{ade}\u{ae0}\x05\u{192}\u{ca}\x02\u{adf}\u{ad7}\x03\
	\x02\x02\x02\u{adf}\u{ad8}\x03\x02\x02\x02\u{adf}\u{ad9}\x03\x02\x02\x02\
	\u{adf}\u{ada}\x03\x02\x02\x02\u{adf}\u{adb}\x03\x02\x02\x02\u{adf}\u{adc}\
	\x03\x02\x02\x02\u{adf}\u{add}\x03\x02\x02\x02\u{adf}\u{ade}\x03\x02\x02\
	\x02\u{ae0}\u{185}\x03\x02\x02\x02\u{ae1}\u{ae2}\x05\x74\x3b\x02\u{ae2}\
	\u{ae3}\x07\x04\x02\x02\u{ae3}\u{ae8}\x03\x02\x02\x02\u{ae4}\u{ae5}\x05\
	\u{d2}\x6a\x02\u{ae5}\u{ae6}\x07\x04\x02\x02\u{ae6}\u{ae8}\x03\x02\x02\x02\
	\u{ae7}\u{ae1}\x03\x02\x02\x02\u{ae7}\u{ae4}\x03\x02\x02\x02\u{ae8}\u{187}\
	\x03\x02\x02\x02\u{ae9}\u{aea}\x07\u{88}\x02\x02\u{aea}\u{aee}\x05\u{184}\
	\u{c3}\x02\u{aeb}\u{aed}\x05\u{184}\u{c3}\x02\u{aec}\u{aeb}\x03\x02\x02\
	\x02\u{aed}\u{af0}\x03\x02\x02\x02\u{aee}\u{aec}\x03\x02\x02\x02\u{aee}\
	\u{aef}\x03\x02\x02\x02\u{aef}\u{af1}\x03\x02\x02\x02\u{af0}\u{aee}\x03\
	\x02\x02\x02\u{af1}\u{af2}\x07\u{89}\x02\x02\u{af2}\u{189}\x03\x02\x02\x02\
	\u{af3}\u{af4}\x07\u{8a}\x02\x02\u{af4}\u{af8}\x05\u{184}\u{c3}\x02\u{af5}\
	\u{af7}\x05\u{184}\u{c3}\x02\u{af6}\u{af5}\x03\x02\x02\x02\u{af7}\u{afa}\
	\x03\x02\x02\x02\u{af8}\u{af6}\x03\x02\x02\x02\u{af8}\u{af9}\x03\x02\x02\
	\x02\u{af9}\u{afb}\x03\x02\x02\x02\u{afa}\u{af8}\x03\x02\x02\x02\u{afb}\
	\u{afc}\x07\u{8b}\x02\x02\u{afc}\u{18b}\x03\x02\x02\x02\u{afd}\u{afe}\x07\
	\x21\x02\x02\u{afe}\u{aff}\x05\u{d2}\x6a\x02\u{aff}\u{b02}\x05\u{184}\u{c3}\
	\x02\u{b00}\u{b01}\x07\x36\x02\x02\u{b01}\u{b03}\x05\u{184}\u{c3}\x02\u{b02}\
	\u{b00}\x03\x02\x02\x02\u{b02}\u{b03}\x03\x02\x02\x02\u{b03}\u{18d}\x03\
	\x02\x02\x02\u{b04}\u{b05}\x07\x3b\x02\x02\u{b05}\u{b06}\x07\x0b\x02\x02\
	\u{b06}\u{b07}\x05\u{d2}\x6a\x02\u{b07}\u{b08}\x07\x0d\x02\x02\u{b08}\u{b09}\
	\x05\u{196}\u{cc}\x02\u{b09}\u{18f}\x03\x02\x02\x02\u{b0a}\u{b0b}\x07\x3c\
	\x02\x02\u{b0b}\u{b0c}\x07\x0b\x02\x02\u{b0c}\u{b0d}\x05\u{184}\u{c3}\x02\
	\u{b0d}\u{b0e}\x07\x04\x02\x02\u{b0e}\u{b0f}\x05\u{d2}\x6a\x02\u{b0f}\u{b10}\
	\x07\x04\x02\x02\u{b10}\u{b11}\x05\u{184}\u{c3}\x02\u{b11}\u{b12}\x07\x0d\
	\x02\x02\u{b12}\u{b13}\x05\u{196}\u{cc}\x02\u{b13}\u{191}\x03\x02\x02\x02\
	\u{b14}\u{b15}\x07\x3f\x02\x02\u{b15}\u{b16}\x07\x04\x02\x02\u{b16}\u{193}\
	\x03\x02\x02\x02\u{b17}\u{b18}\x07\u{8c}\x02\x02\u{b18}\u{b19}\x07\x0b\x02\
	\x02\u{b19}\u{b1a}\x05\u{d2}\x6a\x02\u{b1a}\u{b1b}\x07\x0d\x02\x02\u{b1b}\
	\u{b1c}\x05\u{196}\u{cc}\x02\u{b1c}\u{195}\x03\x02\x02\x02\u{b1d}\u{b23}\
	\x05\u{184}\u{c3}\x02\u{b1e}\u{b1f}\x07\u{8d}\x02\x02\u{b1f}\u{b23}\x07\
	\x04\x02\x02\u{b20}\u{b21}\x07\u{8e}\x02\x02\u{b21}\u{b23}\x07\x04\x02\x02\
	\u{b22}\u{b1d}\x03\x02\x02\x02\u{b22}\u{b1e}\x03\x02\x02\x02\u{b22}\u{b20}\
	\x03\x02\x02\x02\u{b23}\u{197}\x03\x02\x02\x02\u{143}\u{19c}\u{1a2}\u{1a4}\
	\u{1ad}\u{1af}\u{1b5}\u{1ba}\u{1c0}\u{1c6}\u{1c9}\u{1d1}\u{1de}\u{1e0}\u{1e8}\
	\u{1fb}\u{20b}\u{210}\u{21a}\u{220}\u{226}\u{22f}\u{235}\u{239}\u{242}\u{248}\
	\u{24b}\u{251}\u{259}\u{25c}\u{265}\u{26a}\u{279}\u{27f}\u{286}\u{28c}\u{28f}\
	\u{295}\u{29e}\u{2a3}\u{2a9}\u{2b2}\u{2b9}\u{2bd}\u{2c0}\u{2d4}\u{2d7}\u{2e2}\
	\u{2e7}\u{2ee}\u{2f1}\u{2f4}\u{2fb}\u{301}\u{304}\u{309}\u{310}\u{313}\u{316}\
	\u{31c}\u{31f}\u{32a}\u{32e}\u{339}\u{33f}\u{343}\u{34a}\u{34f}\u{359}\u{35f}\
	\u{366}\u{369}\u{372}\u{379}\u{387}\u{390}\u{396}\u{39e}\u{3a8}\u{3aa}\u{3b2}\
	\u{3b8}\u{3c3}\u{3c9}\u{3d5}\u{3e6}\u{3ed}\u{3f8}\u{400}\u{407}\u{40d}\u{41d}\
	\u{424}\u{43d}\u{441}\u{44a}\u{44f}\u{455}\u{45a}\u{45f}\u{465}\u{46a}\u{46f}\
	\u{475}\u{47a}\u{47f}\u{485}\u{48a}\u{48f}\u{495}\u{49e}\u{4a7}\u{4b0}\u{4b9}\
	\u{4c2}\u{4cb}\u{4cf}\u{4db}\u{4df}\u{4e3}\u{4ec}\u{4f0}\u{4fc}\u{500}\u{504}\
	\u{50d}\u{511}\u{51d}\u{521}\u{525}\u{52e}\u{532}\u{53e}\u{542}\u{546}\u{54d}\
	\u{558}\u{563}\u{56e}\u{579}\u{581}\u{587}\u{58d}\u{593}\u{599}\u{5ee}\u{5f5}\
	\u{5fe}\u{608}\u{615}\u{619}\u{61d}\u{621}\u{625}\u{62b}\u{62f}\u{633}\u{637}\
	\u{63a}\u{63d}\u{646}\u{64a}\u{64f}\u{652}\u{659}\u{65c}\u{660}\u{66f}\u{674}\
	\u{677}\u{67a}\u{67f}\u{68d}\u{690}\u{692}\u{699}\u{6a5}\u{6c1}\u{6c9}\u{6cd}\
	\u{6db}\u{6dd}\u{6e9}\u{6f1}\u{700}\u{709}\u{716}\u{719}\u{723}\u{726}\u{729}\
	\u{737}\u{740}\u{743}\u{749}\u{753}\u{758}\u{75d}\u{763}\u{766}\u{770}\u{77b}\
	\u{77e}\u{781}\u{783}\u{78b}\u{796}\u{79d}\u{7a5}\u{7a9}\u{7b1}\u{7b6}\u{7bb}\
	\u{7c2}\u{7c8}\u{7dd}\u{7e3}\u{7ed}\u{7fa}\u{813}\u{81c}\u{81f}\u{833}\u{838}\
	\u{83d}\u{843}\u{849}\u{84e}\u{854}\u{858}\u{865}\u{86c}\u{87b}\u{886}\u{88e}\
	\u{896}\u{89e}\u{8a6}\u{8ae}\u{8bb}\u{8c3}\u{8ca}\u{8cd}\u{8d5}\u{8dd}\u{8e3}\
	\u{8e7}\u{8f0}\u{8fd}\u{906}\u{909}\u{90f}\u{915}\u{920}\u{925}\u{92e}\u{93c}\
	\u{947}\u{94c}\u{952}\u{954}\u{95a}\u{963}\u{96d}\u{973}\u{979}\u{97f}\u{991}\
	\u{9af}\u{9b8}\u{9bb}\u{9be}\u{9c4}\u{9c6}\u{9cf}\u{9d1}\u{9da}\u{9de}\u{9ea}\
	\u{9ed}\u{9f3}\u{9f7}\u{9fa}\u{9fe}\u{a06}\u{a0d}\u{a11}\u{a14}\u{a17}\u{a25}\
	\u{a29}\u{a2c}\u{a2f}\u{a33}\u{a36}\u{a3c}\u{a3f}\u{a42}\u{a5d}\u{a63}\u{a6c}\
	\u{a72}\u{a83}\u{a89}\u{a8f}\u{a93}\u{a99}\u{a9b}\u{aa9}\u{aab}\u{ab0}\u{abc}\
	\u{ac3}\u{ac7}\u{ad0}\u{ad5}\u{adf}\u{ae7}\u{aee}\u{af8}\u{b02}\u{b22}";

